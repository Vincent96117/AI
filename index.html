<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>ğŸ”± TRIDENT V17.5 - Gemini via Worker</title>
  <style>
    body { background:#000; color:#0f0; font-family:monospace; padding:20px; }
    .card { border:1px solid #333; padding:15px; margin-bottom:15px; background:#050505; border-radius:8px; }
    .symbol { font-size:1.8rem; color:#00ffcc; font-weight:bold; }
    .meta { color:#9f9; margin-left:8px; }
    .ai-box { background:#111; padding:12px; color:#fff; border-left:4px solid #0f0; margin-top:10px; white-space:pre-wrap; min-height:80px; }
    .small { color:#666; font-size:12px; }
  </style>
</head>
<body>
  <h2>ğŸ”± TRIDENT V17.5 <span style="color:#4285F4">Gemini (Worker)</span></h2>
  <div class="small">æç¤ºï¼šGemini Key ä¸åœ¨å‰ç«¯ï¼Œæ”¹èµ° Workerã€‚</div>
  <div id="deck"></div>

  <script>
    // âœ… æ”¹æˆä½ çš„ Worker ç¶²å€ï¼ˆéƒ¨ç½²å¾Œæœƒåƒï¼šhttps://xxx.yyy.workers.dev/geminiï¼‰
    const WORKER_URL = "https://YOUR-WORKER.SUBDOMAIN.workers.dev/gemini";

    const BLACKLIST = ["BTCUSDT", "ETHUSDT", "SOLUSDT", "XRPUSDT", "BNBUSDT", "BNXUSDT"];

    const market = {};
    const aiCache = {};         // âœ… ä¿å­˜ AI å›è¦†ï¼Œé¿å…è¢«é‡ç¹ªæ´—æ‰
    let busy = false;
    let lastCallSymbol = "";
    let lastPremiumFetchAt = 0;

    async function init() {
      await refreshPremiumIndex();

      const ws = new WebSocket("wss://fstream.binance.com/ws/!ticker@arr");
      ws.onmessage = (e) => {
        const arr = JSON.parse(e.data);
        for (const t of arr) {
          if (market[t.s]) market[t.s].p = t.c;
        }
        draw();

        // æ¯ 60 ç§’åˆ·æ–°ä¸€æ¬¡ fundingï¼ˆé¿å… fd æ°¸é ä¸æ›´æ–°ï¼‰
        const now = Date.now();
        if (now - lastPremiumFetchAt > 60_000) refreshPremiumIndex().catch(()=>{});
      };
    }

    async function refreshPremiumIndex() {
      const r = await fetch("https://fapi.binance.com/fapi/v1/premiumIndex");
      const d = await r.json();

      for (const i of d) {
        if (i.symbol.endsWith("USDT") && !BLACKLIST.includes(i.symbol)) {
          market[i.symbol] = {
            s: i.symbol,
            fd: parseFloat(i.lastFundingRate) * 100,
            p: market[i.symbol]?.p || i.markPrice
          };
        }
      }
      lastPremiumFetchAt = Date.now();
      draw();
    }

    function getTop3() {
      return Object.values(market)
        .filter(x => x.p)
        .sort((a,b) => Math.abs(b.fd) - Math.abs(a.fd))
        .slice(0,3);
    }

    function ensureCard(symbol) {
      const deck = document.getElementById("deck");
      let card = document.getElementById(`card-${symbol}`);
      if (!card) {
        card = document.createElement("div");
        card.className = "card";
        card.id = `card-${symbol}`;
        card.innerHTML = `
          <div>
            <span class="symbol">${symbol}</span>
            <span class="meta" id="meta-${symbol}"></span>
          </div>
          <div id="ai-${symbol}" class="ai-box">ç³»çµ±æƒæä¸­...</div>
        `;
        deck.appendChild(card);
      }
      return card;
    }

    function draw() {
      const list = getTop3();

      // åªç¢ºä¿ top3 çš„å¡å­˜åœ¨ï¼Œä¸¦æ›´æ–° meta / aiBoxï¼ˆä¸æ•´å€‹æ¸…ç©º deckï¼‰
      for (const item of list) {
        ensureCard(item.s);

        const meta = document.getElementById(`meta-${item.s}`);
        meta.textContent = `[FD: ${item.fd.toFixed(4)}%] [P: ${Number(item.p).toFixed(6)}]`;

        const box = document.getElementById(`ai-${item.s}`);
        if (aiCache[item.s]) box.innerText = aiCache[item.s];
      }

      // âœ… åªåœ¨ä¸å¿™æ™‚å‘¼å«ä¸€æ¬¡ï¼šæŒ‘æœ€å¼· fd çš„é‚£å€‹ï¼ˆé¿å…ä¸€ç›´æ‰“çˆ†ï¼‰
      const target = list[0];
      if (!target) return;

      const isHot = Math.abs(target.fd) >= 0.05;
      if (isHot && !busy && lastCallSymbol !== target.s) {
        callGeminiViaWorker(target);
      }
    }

    async function callGeminiViaWorker(item) {
      busy = true;
      lastCallSymbol = item.s;

      const box = document.getElementById(`ai-${item.s}`);
      box.innerText = ">> AI é€£ç·šä¸­ï¼ˆvia Workerï¼‰...";

      try {
        const response = await fetch(WORKER_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            symbol: item.s,
            fd: item.fd,
            price: item.p
          })
        });

        const data = await response.json();
        if (!response.ok || data.error) throw new Error(data.error || `HTTP ${response.status}`);

        const text = (data.text || "").trim();
        const finalText = ">> " + text;
        aiCache[item.s] = finalText;     // âœ… å­˜èµ·ä¾†
        box.innerText = finalText;

      } catch (err) {
        const msg = "âŒ è­¦å‘Š: " + (err?.message || String(err));
        aiCache[item.s] = msg;
        box.innerText = msg;
      } finally {
        // âœ… å†·å» 10 ç§’ï¼Œé¿å…ç‹‚æ‰“
        setTimeout(() => { busy = false; }, 10_000);
      }
    }

    init();
  </script>
</body>
</html>
