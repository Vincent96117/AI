<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRIDENT V7.6 - 5K Swing Mode (BTC/LIQ/GPT-OSS)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    body { background:#050505; color:#d4d4d8; font-family:'JetBrains Mono', monospace; overflow-x:hidden; }
    .panel { background:#0f0f11; border:1px solid #1f1f23; }
    .muted { color:#71717a; }
    .badge { border:1px solid #27272a; background:#0b0b0d; }
    .ok { color:#22c55e; } .warn { color:#f59e0b; } .bad { color:#ef4444; }
    .card { background:#0f0f11; border:1px solid #1f1f23; border-radius:14px; overflow:hidden; }
    .card-top1 { border:2px solid #22c55e !important; box-shadow:0 0 0 1px rgba(34,197,94,0.2), 0 0 24px rgba(34,197,94,0.15); }
    .kv { background:#0b0b0d; border:1px solid #1f1f23; border-radius:10px; padding:8px 10px; }
    .btn { border:1px solid #27272a; background:#0b0b0d; border-radius:10px; padding:8px 10px; font-weight:700; }
    .btn:hover { filter:brightness(1.1); }
    .btn-blue { border-color:#2563eb; color:#93c5fd; background:rgba(37,99,235,0.12); }
    .btn-green { border-color:#16a34a; color:#86efac; background:rgba(22,163,74,0.12); }
    .btn-amber { border-color:#d97706; color:#fdba74; background:rgba(217,119,6,0.12); }
    .btn-red { border-color:#ef4444; color:#fecaca; background:rgba(239,68,68,0.12); }
    .btn-pin { border-color:#a3a3a3; color:#e5e7eb; background:rgba(163,163,163,0.10); }
    .btn-pin-on { border-color:#fbbf24; color:#fde68a; background:rgba(251,191,36,0.16); }
    .hr { border-top:1px solid #1f1f23; }
    .ai-box { background:#070708; border:1px solid #1f1f23; border-radius:14px; padding:12px; min-height:190px; }
    .stage-setup { color:#fbbf24; }
    .stage-ignite { color:#fb7185; }
    .stage-confirm { color:#22c55e; }
    .stage-chase { color:#ef4444; }
    .stage-cool { color:#71717a; }
    .tiny { font-size:11px; }
    .tiny2 { font-size:10px; }
    input[type="text"], input[type="password"] {
      background:#09090b; border:1px solid #27272a; border-radius:10px; padding:10px 10px; color:#e5e7eb;
      outline:none; font-size:12px;
    }
    input::placeholder { color:#52525b; }
    .heartbeat { width:8px; height:8px; border-radius:999px; display:inline-block; margin-right:8px; background:#3f3f46; box-shadow:none; }
    .hb-on { background:#22c55e; box-shadow:0 0 10px rgba(34,197,94,0.75); }
  </style>
</head>

<body class="p-4">
  <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
    <div class="flex items-center gap-3">
      <span id="hb" class="heartbeat"></span>
      <div>
        <div class="text-white font-black italic text-xl leading-none">TRIDENT <span class="text-emerald-400">V7.6</span></div>
        <div class="tiny muted font-bold tracking-widest uppercase">
          LONG ONLY / 5m(5K)å°æ³¢æ®µ / ç†±æ©Ÿ5~10min / BTCç›¸å°å¼·å¼±åŠ åˆ† / Liquidation feed / AI=GPT-OSS(Groq) / âœ…é‡˜é¸ âœ…æœå°‹ä¸Šæ¦œ âœ…å–®å¹£AIæ›´æ–° âœ…ğŸ—‘ä¸çœ‹æ›¿è£œ
        </div>
      </div>
    </div>

    <div class="flex flex-wrap items-center gap-2">
      <input id="aiKey" type="password" class="w-[280px]" placeholder="è¼¸å…¥ Groq API Keyï¼ˆåªå­˜åœ¨ç€è¦½å™¨ localStorageï¼‰" />
      <button class="btn btn-green" onclick="saveKey()">Save</button>
      <button class="btn" onclick="clearKey()">Clear</button>

     <select id="modelSel" class="btn">
  <option value="openai/gpt-oss-20b">openai/gpt-oss-20b</option>
  <option value="openai/gpt-oss-120b">openai/gpt-oss-120b</option>
  <option value="llama-3.3-70b-versatile">llama-3.3-70b-versatile</option>
  <option value="llama-3.1-8b-instant">llama-3.1-8b-instant</option>
</select>

      <input id="symSearch" type="text" class="w-[160px] uppercase" placeholder="æœå°‹å¹£ (ex: WIF)" />
      <button class="btn btn-amber" onclick="searchAndAdd()">Search & ä¸Šæ¦œ</button>

      <button class="btn btn-green" onclick="testAI()">Test AI</button>
      <button class="btn btn-blue" onclick="runAIOnce(true)">Analyze Now</button>
      <button class="btn btn-amber" onclick="toggleAutoAI()"><span id="autoLbl">Auto AI: ON</span></button>
      <button class="btn btn-red" onclick="hardReset()">RESET</button>
    </div>
  </div>

  <div class="mt-3 panel rounded-xl p-3 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
    <div class="flex flex-wrap items-center gap-3 tiny">
      <span class="badge px-2 py-1 rounded-lg">Universe: <b id="universeN">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">Tracked(Top10): <b id="candN">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">Pinned: <b id="pinN">0</b></span>
      <span class="badge px-2 py-1 rounded-lg">Hidden: <b id="hidN">0</b></span>
      <span class="badge px-2 py-1 rounded-lg">AI Top5: <b id="top5N">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">Pinned #1: <b id="pinnedSym">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">æ›´æ–°: <b id="lastTick">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">Binance: <b id="binStatus" class="muted">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">LIQ: <b id="liqStatus" class="muted">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">BTC: <b id="btcStatus" class="muted">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">AI: <b id="aiStatus" class="muted">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">VP(Today): <b id="vpStatus" class="muted">-</b></span>
    </div>

    <div class="tiny muted">
      5m(5K)å°æ³¢æ®µï¼šå€™é¸éœ€ã€Œç†±æ©Ÿ >=5~10min + è‡³å°‘2å€‹5m bucketã€å³å¯é€² Top10 / é€AIã€‚ä¸¦åŠ å…¥ BTC æŠ—è·Œ/é€†å‹¢åŠ åˆ† + å¼·å¹³(Short/Long)è¨Šè™Ÿã€‚
    </div>
  </div>

  <div class="mt-4 grid grid-cols-1 gap-4">
    <div class="panel rounded-xl p-3">
      <div class="flex items-center justify-between">
        <div class="text-white font-bold">AI Top 5ï¼ˆAI å¾è¿½è¹¤ Top10 è£¡æŒ‘ï¼‰</div>
        <button class="btn tiny" onclick="toggleDebug()">æŸ¥çœ‹ AI åƒåˆ°çš„ Top10 æ‘˜è¦ï¼ˆDebugï¼‰</button>
      </div>
      <div id="cards" class="mt-3 grid grid-cols-1 gap-4"></div>
    </div>

    <div id="debugWrap" class="panel rounded-xl p-3 hidden">
      <div class="text-white font-bold mb-2">AI Inputï¼ˆTop10 æ‘˜è¦ JSONï¼‰</div>
      <pre id="debugJSON" class="ai-box text-[11px] overflow-auto"></pre>
    </div>
  </div>

<script>
/* ===========================
   CONFIG (V7.6 5m Swing Mode + BTC + LIQ + GPT-OSS)
=========================== */
const CONFIG = {
  LONG_ONLY: true,

  UNIVERSE_LIMIT: 90,
  UNIVERSE_REFRESH_MS: 5 * 60 * 1000,

  CANDIDATE_LIMIT: 10,
  CANDIDATE_REFRESH_MS: 3000,

  TOP5_LIMIT: 5,
  AI_INTERVAL_MS: 2 * 60 * 1000,
  AI_INPUT_SIZE: 10,
  MIN_AI_POOL: 10,

  // âœ… æ”¹æˆ 5~10åˆ†é˜å¯é€²æ± ï¼š5m bucket è‡³å°‘2å€‹=10åˆ†é˜
  WARMUP_MIN_MS: 6 * 60 * 1000,
  MIN_HIST_BUCKETS: 2,

  ROLL_5M_MS: 5 * 60 * 1000,
  BUCKET_5M_MS: 5 * 60 * 1000,
  HIST_5M_BUCKETS: 48,

  KLINES_INTERVAL: "5m",
  KLINES_LIMIT: 240, // 20h
  ATR_PERIOD: 14,
  SWING_WINDOW: 24,  // 2h

  VP_5M_LIMIT: 288,
  VP_REFRESH_MS: 2 * 60 * 1000,
  VP_BINS: 24,

  // BTCç›¸å°å¼·å¼±ï¼šBTCè·Œæ™‚ï¼ŒæŠ—è·Œ/é€†å‹¢ä¸Šæ¼²åŠ åˆ†
  BTC_RS: {
    enable: true,
    btcDownGatePct: -0.25,     // BTC 5m <= -0.25% æ‰å•Ÿå‹•ã€ŒæŠ—è·ŒåŠ åˆ†ã€
    rel5mBoostMax: 10,         // æœ€å¤§åŠ åˆ†
    rel5mScale: 12,            // rel(coin-btc) * scale
    rel2hWeight: 0.35          // 2hç›¸å°å¼·å¼±æ¬Šé‡
  },

  // Liquidation feedï¼ˆå¼·å¹³ï¼‰çª—å£
  LIQ: {
    enable: true,
    windowMs: 5 * 60 * 1000,
    minNotionalTag: 250000,    // è¶…éå°±æ‰“ tag
    scoreScale: 6              // score åŠ æ¬Š
  },

  ANTI_CHASE: {
    ret5mPctMax: 1.2,
    distSmaAtrMax: 1.2,
    range20PctMax: 3.2
  },

  THRESH: {
    volZMin: 0.9,
    deltaNotionalMin: 8000,
    imbalanceMin: 0.02,
    preScoreMin: 46
  },

  TRACKING: {
    enabled: true,
    replaceMargin: 3,
  },

  TP_K: [1.3, 2.6, 4.0],

  TOPCAP_EXCLUDE: [
    "BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TRXUSDT","TONUSDT",
    "AVAXUSDT","DOTUSDT","LINKUSDT","MATICUSDT","POLUSDT","SHIBUSDT","1000SHIBUSDT",
    "LTCUSDT","BCHUSDT","ATOMUSDT","UNIUSDT","XLMUSDT","ICPUSDT","FILUSDT","APTUSDT",
    "NEARUSDT","ARBUSDT","OPUSDT"
  ],

  FX_COMMODITY_PREFIX: [
    "XAU","XAG","EUR","GBP","AUD","JPY","CHF","CAD","NZD",
    "BRL","TRY","RUB","ZAR","MXN","PLN","SEK","NOK","DKK","HKD","SGD"
  ],

  EXCLUDE_EXTRA: [
    "USDCUSDT","TUSDUSDT","FDUSDUSDT","USDPUSDT","DAIUSDT"
  ],

  // âœ… é ç†±éšŠåˆ—ï¼šé¿å…ã€ŒklinesReady å¿…é ˆå…ˆ trueã€é€ æˆ Top10 æ°¸é æ¹Šä¸æ»¿
  PREWARM: {
    enable: true,
    tickMs: 900,         // æ¯æ¬¡æ‹¿ä¸€å€‹symbolå»æŠ“K/OIï¼ˆé™ä½è¢«é™æµï¼‰
    maxPerTick: 1
  }
};

/* ===========================
   STATE
=========================== */
let AUTO_AI = true;
let lastAiTs = 0;
let aiBackoffUntil = 0;

let universe = [];
let allowedPerpSet = null;

let symState = {};
let wsAgg = {};
let wsMini = null;

let premiumMap = {};

let trackedTopN = [];
let candidatesTopN = [];

let aiTop5 = [];
let aiBySymbol = {};
let aiHistoryBySymbol = {};

let pinnedSet = new Set();
let manualIncludeSet = new Set();

let hiddenSet = new Set(JSON.parse(localStorage.getItem("HIDDEN_SET") || "[]"));
function saveHiddenSet(){ localStorage.setItem("HIDDEN_SET", JSON.stringify(Array.from(hiddenSet))); }

let pinnedTop1 = { symbol:null, score:-1, confidence:-1, ts:0 };

// BTC stateï¼ˆç”¨ä¾†åšç›¸å°å¼·å¼±ï¼‰
let btc = {
  symbol: "BTCUSDT",
  price: null,
  trades: [],
  ret5mPct: null,
  ret2hPct: null,
  lastTs: 0,
  ws: null
};

// Liquidation feed state
let wsLiq = null;
let liqState = {}; // sym -> { events:[{ts, side, notional}], shortLiqNotional, longLiqNotional, netShortLiq }

/* ===========================
   UI helpers
=========================== */
const $ = (id) => document.getElementById(id);
function nowStr() {
  const d = new Date();
  return d.toLocaleTimeString("zh-TW", { hour12:false });
}
function fmt(n, digits=2) {
  if (n === null || n === undefined || Number.isNaN(n)) return "-";
  return Number(n).toFixed(digits);
}
function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
function setStatus(el, text, cls) {
  const node = $(el);
  node.textContent = text;
  node.className = cls || "muted";
}
function toggleDebug() { $("debugWrap").classList.toggle("hidden"); }

function saveKey() {
  const k = $("aiKey").value.trim();
  if (!k) return alert("è«‹è¼¸å…¥ Groq API Key");
  localStorage.setItem("GROQ_KEY", k);
  alert("å·²ä¿å­˜åˆ° localStorageï¼ˆåƒ…æ­¤ç€è¦½å™¨ï¼‰");
}
function clearKey() {
  localStorage.removeItem("GROQ_KEY");
  $("aiKey").value = "";
  alert("å·²æ¸…é™¤ key");
}
function loadKey() {
  const k = localStorage.getItem("GROQ_KEY") || "";
  $("aiKey").value = k;
}
function toggleAutoAI() {
  AUTO_AI = !AUTO_AI;
  $("autoLbl").textContent = `Auto AI: ${AUTO_AI ? "ON" : "OFF"}`;
}
function updatePinBadge() { $("pinN").textContent = String(pinnedSet.size); }
function updateHiddenBadge() { $("hidN").textContent = String(hiddenSet.size); }

function hardReset() {
  try { if (wsMini) wsMini.close(); } catch {}
  try { if (wsLiq) wsLiq.close(); } catch {}
  try { if (btc.ws) btc.ws.close(); } catch {}
  Object.keys(wsAgg).forEach(s => { try { wsAgg[s].close(); } catch {} });

  wsAgg = {};
  symState = {};
  universe = [];
  allowedPerpSet = null;

  trackedTopN = [];
  candidatesTopN = [];

  aiTop5 = [];
  aiBySymbol = {};
  aiHistoryBySymbol = {};

  pinnedSet = new Set();
  manualIncludeSet = new Set();
  pinnedTop1 = { symbol:null, score:-1, confidence:-1, ts:0 };

  liqState = {};

  btc = { symbol:"BTCUSDT", price:null, trades:[], ret5mPct:null, ret2hPct:null, lastTs:0, ws:null };

  lastAiTs = 0;
  aiBackoffUntil = 0;

  $("cards").innerHTML = "";
  $("debugJSON").textContent = "";
  setStatus("binStatus","é‡ç½®ä¸­â€¦","warn");
  setStatus("liqStatus","-","muted");
  setStatus("btcStatus","-","muted");
  setStatus("aiStatus","-","muted");
  setStatus("vpStatus","-","muted");
  $("universeN").textContent = "-";
  $("candN").textContent = "-";
  $("pinN").textContent = "0";
  $("top5N").textContent = "-";
  $("pinnedSym").textContent = "-";
  updateHiddenBadge();
  boot();
}

function enforcePinnedLimit() {
  const maxPin = CONFIG.CANDIDATE_LIMIT;
  if (pinnedSet.size <= maxPin) return;
  const pins = [...pinnedSet];
  pins.sort((a,b) => (scoreOf(a) - scoreOf(b)));
  const drop = pins[0];
  pinnedSet.delete(drop);
  updatePinBadge();
}

function togglePin(sym) {
  sym = String(sym||"").toUpperCase();
  if (!sym) return;
  if (pinnedSet.has(sym)) pinnedSet.delete(sym);
  else pinnedSet.add(sym);
  enforcePinnedLimit();
  updatePinBadge();
  if (pinnedSet.has(sym) && symState[sym] && !trackedTopN.includes(sym)) trackedTopN.push(sym);
  if (aiTop5.length) renderTop5Cards();
}

/* ===========================
   DELETE/HIDE + auto replace
=========================== */
function backfillTop5Placeholder() {
  const exist = new Set(aiTop5.map(x => x.symbol));
  const pool = candidatesTopN
    .filter(sym => !hiddenSet.has(sym))
    .filter(sym => !exist.has(sym))
    .map(sym => buildSummary(sym))
    .filter(Boolean)
    .sort((a,b) => (b.preScore||0) - (a.preScore||0));

  while (aiTop5.length < CONFIG.TOP5_LIMIT && pool.length) {
    const sum = pool.shift();
    const ph = normalizeAiPick(sum.symbol, sum, { score: sum.preScore, confidence: 50, eta_minutes: "30-60", stage: sum.stage });
    aiBySymbol[sum.symbol] = ph;
    aiTop5.push(ph);
  }
  aiTop5.sort((a,b)=> (b.score-a.score) || (b.confidence-a.confidence));
}

function hideSymbol(sym) {
  sym = String(sym||"").toUpperCase();
  if (!sym) return;

  hiddenSet.add(sym);
  saveHiddenSet();
  updateHiddenBadge();

  if (pinnedTop1?.symbol === sym) pinnedTop1 = { symbol:null, score:-1, confidence:-1, ts:0 };
  pinnedSet.delete(sym);
  manualIncludeSet.delete(sym);
  updatePinBadge();

  universe = universe.filter(x => x !== sym);
  trackedTopN = trackedTopN.filter(x => x !== sym);
  candidatesTopN = candidatesTopN.filter(x => x !== sym);

  aiTop5 = aiTop5.filter(x => x.symbol !== sym);
  delete aiBySymbol[sym];
  delete aiHistoryBySymbol[sym];

  try { if (wsAgg[sym]) wsAgg[sym].close(); } catch {}
  delete wsAgg[sym];
  delete symState[sym];
  delete liqState[sym];

  buildTrackedTopN();

  const key = $("aiKey")?.value?.trim();
  if (key) runAIOnce(true);
  else {
    backfillTop5Placeholder();
    renderTop5Cards();
  }
}

/* ===========================
   Network helpers
=========================== */
async function fetchJSON(url) {
  const res = await fetch(url);
  const txt = await res.text();
  let data;
  try { data = JSON.parse(txt); } catch { throw new Error(`JSON parse fail: ${txt.slice(0,200)}`); }
  if (!res.ok) throw new Error(`HTTP ${res.status}: ${txt.slice(0,200)}`);
  return data;
}
function zscore(x, arr) {
  if (!arr || arr.length < 3) return null;
  const m = arr.reduce((a,b)=>a+b,0) / arr.length;
  const v = arr.reduce((a,b)=>a+(b-m)*(b-m),0) / arr.length;
  const s = Math.sqrt(v);
  if (s === 0) return 0;
  return (x - m) / s;
}
function meanStd(arr) {
  if (!arr || arr.length < 3) return { mean: 0, std: 0 };
  const mean = arr.reduce((a,b)=>a+b,0) / arr.length;
  const v = arr.reduce((a,b)=>a+(b-mean)*(b-mean),0) / arr.length;
  const std = Math.sqrt(v);
  return { mean, std };
}

/* ===========================
   Filters
=========================== */
function isFxCommodity(sym) {
  for (const p of CONFIG.FX_COMMODITY_PREFIX) {
    if (sym.startsWith(p) && sym.endsWith("USDT")) return true;
  }
  return false;
}

/* ===========================
   Binance exchangeInfo / premium / universe
=========================== */
async function refreshExchangeInfo() {
  const ex = await fetchJSON("https://fapi.binance.com/fapi/v1/exchangeInfo");
  const set = new Set();
  for (const s of (ex.symbols || [])) {
    if (s.status !== "TRADING") continue;
    if (s.contractType !== "PERPETUAL") continue;
    if (s.quoteAsset !== "USDT") continue;
    set.add(s.symbol);
  }
  allowedPerpSet = set;
}

async function refreshPremiumAll() {
  const data = await fetchJSON("https://fapi.binance.com/fapi/v1/premiumIndex");
  const map = {};
  for (const r of data) {
    const mark = parseFloat(r.markPrice);
    const idx = parseFloat(r.indexPrice);
    const premiumPct = (idx && mark) ? ((mark - idx) / idx * 100) : null;
    map[r.symbol] = {
      fundingPct: parseFloat(r.lastFundingRate) * 100,
      premiumPct,
      markPrice: mark,
      indexPrice: idx
    };
  }
  premiumMap = map;
}

async function refreshUniverse() {
  if (!allowedPerpSet) await refreshExchangeInfo().catch(()=>{});

  const tickers = await fetchJSON("https://fapi.binance.com/fapi/v1/ticker/24hr");
  const ex = new Set([...CONFIG.TOPCAP_EXCLUDE, ...CONFIG.EXCLUDE_EXTRA]);

  const filtered = tickers
    .filter(t => t.symbol.endsWith("USDT"))
    .filter(t => !hiddenSet.has(t.symbol))
    .filter(t => allowedPerpSet ? allowedPerpSet.has(t.symbol) : true)
    .filter(t => !ex.has(t.symbol))
    .filter(t => !isFxCommodity(t.symbol))
    .map(t => ({ symbol: t.symbol, quoteVolume: parseFloat(t.quoteVolume || "0") }))
    .sort((a,b) => b.quoteVolume - a.quoteVolume)
    .slice(0, CONFIG.UNIVERSE_LIMIT)
    .map(x => x.symbol);

  for (const sym of Array.from(manualIncludeSet)) {
    if (hiddenSet.has(sym)) continue;
    if (allowedPerpSet && !allowedPerpSet.has(sym)) continue;
    if (CONFIG.TOPCAP_EXCLUDE.includes(sym)) continue;
    if (CONFIG.EXCLUDE_EXTRA.includes(sym)) continue;
    if (isFxCommodity(sym)) continue;
    if (!filtered.includes(sym)) filtered.push(sym);
  }

  universe = filtered;
  $("universeN").textContent = universe.length;

  const uSet = new Set(universe);

  for (const sym of Array.from(pinnedSet)) {
    if (!uSet.has(sym)) pinnedSet.delete(sym);
  }
  enforcePinnedLimit();
  updatePinBadge();

  Object.keys(wsAgg).forEach(sym => {
    if (!uSet.has(sym)) {
      try { wsAgg[sym].close(); } catch {}
      delete wsAgg[sym];
      delete symState[sym];
      delete liqState[sym];
      trackedTopN = trackedTopN.filter(x => x !== sym);
    }
  });

  for (const sym of universe) {
    if (!wsAgg[sym]) initAggTrade(sym);
    if (!symState[sym]) initSymbolState(sym);
    if (!liqState[sym]) liqState[sym] = { events:[], shortLiqNotional:0, longLiqNotional:0, netShortLiq:0 };
  }
}

/* ===========================
   Per-symbol state + streams
=========================== */
function initSymbolState(sym) {
  symState[sym] = {
    symbol: sym,
    price: null,
    lastTradeTs: 0,

    trades: [],
    buckets: new Map(),
    bucketIds: [],

    vol5mNotional: null,
    delta5mNotional: null,
    imbalance5m: null,

    volZ5m: null,
    deltaZ5m: null,
    volZcs: null,
    deltaZcs: null,
    histBuckets: 0,

    ret5mPct: null,

    fundingPct: null,
    premiumPct: null,

    oiCurrent: null,
    oiSamples: [],
    oiDelta5m: null,
    oiDelta4h: null,

    klinesReady: false,
    atr14: null,
    swingLow20: null,
    swingHigh20: null,
    range20Pct: null,
    sma20: null,
    distSma20Atr: null,

    // BTCç›¸å°
    btc_ret5m: null,
    btc_ret2h: null,
    rel5m_vs_btc: null,
    rel2h_vs_btc: null,

    // Liquidation
    liqShortNotional5m: 0,
    liqLongNotional5m: 0,
    liqNetShort5m: 0,

    vpToday: null,
    vpLastTs: 0,

    stage: "ç†±æ©Ÿä¸­",
    tags: [],
    preScore: 0,

    firstSeenTs: Date.now(),
  };
}

function initAggTrade(sym) {
  const url = `wss://fstream.binance.com/ws/${sym.toLowerCase()}@aggTrade`;
  const ws = new WebSocket(url);
  wsAgg[sym] = ws;

  ws.onopen = () => {
    $("hb").classList.add("hb-on");
    setStatus("binStatus","WS OK","ok");
  };
  ws.onerror = () => setStatus("binStatus","WS error","warn");
  ws.onclose = () => {
    if (universe.includes(sym) && !hiddenSet.has(sym)) {
      setTimeout(() => {
        if (!wsAgg[sym] || wsAgg[sym].readyState === 3) initAggTrade(sym);
      }, 800 + Math.random()*800);
    }
  };

  ws.onmessage = (ev) => {
    const s = symState[sym];
    if (!s) return;

    const d = JSON.parse(ev.data);

    const ts = d.T;
    const price = parseFloat(d.p);
    const qty = parseFloat(d.q);
    const notional = price * qty;

    const isBuyAgg = !d.m;
    const deltaNotional = isBuyAgg ? notional : -notional;

    s.price = price;
    s.lastTradeTs = ts;

    s.trades.push({ ts, price, notional, deltaNotional, isBuy: isBuyAgg });

    const cutoff = Date.now() - CONFIG.ROLL_5M_MS;
    while (s.trades.length && s.trades[0].ts < cutoff) s.trades.shift();

    if (s.trades.length >= 2) {
      const old = s.trades[0].price;
      if (old > 0) s.ret5mPct = (price / old - 1) * 100;
    }

    const bucketId = Math.floor(ts / CONFIG.BUCKET_5M_MS);
    let b = s.buckets.get(bucketId);
    if (!b) {
      b = { notional: 0, deltaNotional: 0 };
      s.buckets.set(bucketId, b);
      s.bucketIds.push(bucketId);
      while (s.bucketIds.length > CONFIG.HIST_5M_BUCKETS + 3) {
        const id = s.bucketIds.shift();
        s.buckets.delete(id);
      }
    }
    b.notional += notional;
    b.deltaNotional += deltaNotional;

    const curB = s.buckets.get(bucketId);
    if (curB) {
      s.vol5mNotional = curB.notional;
      s.delta5mNotional = curB.deltaNotional;

      const total = curB.notional || 0;
      const delta = curB.deltaNotional || 0;
      const buy = (total + delta) / 2;
      const sell = (total - delta) / 2;
      const denom = buy + sell;
      s.imbalance5m = denom > 0 ? (buy / denom) : null;
    }

    const histIds = s.bucketIds.filter(id => id !== bucketId);
    s.histBuckets = histIds.length;

    const histVol = histIds.map(id => (s.buckets.get(id)?.notional || 0)).filter(x => x > 0);
    const histDelta = histIds.map(id => (s.buckets.get(id)?.deltaNotional || 0));

    if (s.vol5mNotional !== null) s.volZ5m = zscore(s.vol5mNotional, histVol);
    if (s.delta5mNotional !== null) s.deltaZ5m = zscore(s.delta5mNotional, histDelta);

    const p = premiumMap[sym];
    if (p) {
      s.fundingPct = p.fundingPct;
      s.premiumPct = p.premiumPct;
    }

    // é€£å‹• BTC ç›¸å°å¼·å¼± & LIQçª—å£
    updateBtcRelative(sym);
    updateLiqWindow(sym);

    deriveSymbol(sym);
  };
}

/* ===========================
   BTC (aggTrade) for relative strength
=========================== */
function startBTCFeed() {
  try { if (btc.ws) btc.ws.close(); } catch {}
  const ws = new WebSocket("wss://fstream.binance.com/ws/btcusdt@aggTrade");
  btc.ws = ws;

  ws.onopen = () => setStatus("btcStatus","BTC feed OK","ok");
  ws.onerror = () => setStatus("btcStatus","BTC feed error","warn");
  ws.onclose = () => {
    setStatus("btcStatus","BTC feed closed","warn");
    setTimeout(startBTCFeed, 1200);
  };

  ws.onmessage = (ev) => {
    const d = JSON.parse(ev.data);
    const ts = d.T;
    const price = parseFloat(d.p);
    btc.price = price;
    btc.lastTs = ts;

    btc.trades.push({ ts, price });
    const cut5m = Date.now() - 5*60*1000;
    while (btc.trades.length && btc.trades[0].ts < cut5m) btc.trades.shift();

    if (btc.trades.length >= 2) {
      const old = btc.trades[0].price;
      if (old > 0) btc.ret5mPct = (price/old - 1)*100;
    }

    // 2h ret ç”¨è¼ªè©¢Kç·šæ¯”è¼ƒç©©ï¼ˆä¸‹é¢æœ‰ prewarm æœƒæŠ“BTC klinesï¼‰
  };
}

async function refreshBTC2h() {
  try {
    const k = await fetchJSON(`https://fapi.binance.com/fapi/v1/klines?symbol=BTCUSDT&interval=5m&limit=24`); // 2h=24æ ¹
    if (Array.isArray(k) && k.length >= 2) {
      const first = parseFloat(k[0][4]);
      const last = parseFloat(k[k.length-1][4]);
      if (first > 0 && isFinite(last)) btc.ret2hPct = (last/first - 1)*100;
    }
  } catch {}
  const t = `BTC 5m:${fmt(btc.ret5mPct,2)}% / 2h:${fmt(btc.ret2hPct,2)}%`;
  setStatus("btcStatus", t, (btc.ret5mPct!==null && btc.ret5mPct<0) ? "warn" : "muted");
}

function updateBtcRelative(sym) {
  const s = symState[sym];
  if (!s) return;
  s.btc_ret5m = btc.ret5mPct;
  s.btc_ret2h = btc.ret2hPct;
  if (s.ret5mPct !== null && btc.ret5mPct !== null) s.rel5m_vs_btc = s.ret5mPct - btc.ret5mPct;
  if (s.klinesReady && btc.ret2hPct !== null) {
    // coin 2h ret ç”¨è‡ªå·±çš„ swing_window è¿‘ä¼¼ï¼ˆSWING_WINDOW=24æ ¹=2hï¼‰
    // é€™è£¡ç”¨ range/ä½ç½®ä¸ç›´æ¥ç®—2hå›å ±ï¼Œæ”¹åœ¨ ensureKlinesAndOI çš„ k ç‰¹å¾µè£¡è£œ
  }
}

/* ===========================
   Liquidation feed (Binance futures force orders)
=========================== */
function startLiquidationFeed() {
  if (!CONFIG.LIQ.enable) return;
  try { if (wsLiq) wsLiq.close(); } catch {}
  // All market force orders
  const ws = new WebSocket("wss://fstream.binance.com/ws/!forceOrder@arr");
  wsLiq = ws;

  ws.onopen = () => setStatus("liqStatus","LIQ feed OK","ok");
  ws.onerror = () => setStatus("liqStatus","LIQ feed error","warn");
  ws.onclose = () => {
    setStatus("liqStatus","LIQ feed closed","warn");
    setTimeout(startLiquidationFeed, 1500);
  };

  ws.onmessage = (ev) => {
    let arr = [];
    try { arr = JSON.parse(ev.data) || []; } catch { return; }
    const now = Date.now();

    for (const it of arr) {
      const o = it?.o;
      if (!o) continue;
      const sym = String(o.s || "").toUpperCase();
      if (!sym || !symState[sym]) continue;

      const price = parseFloat(o.p);
      const qty = parseFloat(o.q);
      if (!isFinite(price) || !isFinite(qty)) continue;
      const notional = price * qty;

      // Binance forceOrder: o.S side = BUY/SELL
      // è‹¥å‡ºç¾ BUY å¼·å¹³ï¼Œé€šå¸¸æ˜¯ã€Œç©ºå–®è¢«å¼·å¹³ -> è¢«è¿«è²·å…¥ã€= bullish
      const side = String(o.S || "").toUpperCase(); // BUY / SELL
      const st = liqState[sym] || (liqState[sym] = { events:[], shortLiqNotional:0, longLiqNotional:0, netShortLiq:0 });

      st.events.push({ ts: now, side, notional });

      // å…ˆå³æ™‚æ¸…ç†
      const cut = now - CONFIG.LIQ.windowMs;
      while (st.events.length && st.events[0].ts < cut) st.events.shift();

      // é‡æ–°çµ±è¨ˆï¼ˆçª—å£å°ï¼Œç›´æ¥é‡ç®—æ›´ä¹¾æ·¨ï¼‰
      let shortL = 0, longL = 0;
      for (const e of st.events) {
        if (e.side === "BUY") shortL += e.notional; // ç©ºå–®å¼·å¹³=è²·å…¥
        else if (e.side === "SELL") longL += e.notional; // å¤šå–®å¼·å¹³=è³£å‡º
      }
      st.shortLiqNotional = shortL;
      st.longLiqNotional = longL;
      st.netShortLiq = shortL - longL;
    }
  };
}

function updateLiqWindow(sym) {
  const s = symState[sym];
  if (!s || !CONFIG.LIQ.enable) return;
  const st = liqState[sym];
  if (!st) return;
  s.liqShortNotional5m = st.shortLiqNotional || 0;
  s.liqLongNotional5m = st.longLiqNotional || 0;
  s.liqNetShort5m = st.netShortLiq || 0;
}

/* ===========================
   Cross-section z
=========================== */
function computeCrossSectionZ() {
  const list = universe.map(sym => symState[sym]).filter(s => s && s.vol5mNotional !== null && s.delta5mNotional !== null);
  if (list.length < 10) return;

  const vols = list.map(s => s.vol5mNotional).filter(v => v > 0);
  const deltas = list.map(s => s.delta5mNotional);

  const vs = meanStd(vols);
  const ds = meanStd(deltas);

  for (const s of list) {
    s.volZcs = (vs.std > 0) ? (s.vol5mNotional - vs.mean) / vs.std : 0;
    s.deltaZcs = (ds.std > 0) ? (s.delta5mNotional - ds.mean) / ds.std : 0;
  }
}

/* ===========================
   OI + klines (5m) + Today VP
=========================== */
async function ensureKlinesAndOI(sym) {
  const s = symState[sym];
  if (!s) return;

  try {
    const k = await fetchJSON(`https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=${CONFIG.KLINES_INTERVAL}&limit=${CONFIG.KLINES_LIMIT}`);
    computeKlineFeatures(sym, k);
  } catch {}

  try {
    const oi = await fetchJSON(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${sym}`);
    const v = parseFloat(oi.openInterest);
    if (!Number.isNaN(v)) {
      s.oiCurrent = v;
      s.oiSamples.push({ ts: Date.now(), oi: v });
      const cutoff = Date.now() - 4*60*60*1000 - 60*1000;
      while (s.oiSamples.length && s.oiSamples[0].ts < cutoff) s.oiSamples.shift();
      computeOIDeltas(sym);
    }
  } catch {}
}

function computeKlineFeatures(sym, k) {
  const s = symState[sym];
  if (!s || !Array.isArray(k) || k.length < 25) return;

  const candles = k.map(x => ({
    open: parseFloat(x[1]),
    high: parseFloat(x[2]),
    low:  parseFloat(x[3]),
    close:parseFloat(x[4]),
  })).filter(c => [c.open,c.high,c.low,c.close].every(v => !Number.isNaN(v)));

  if (candles.length < 25) return;

  const last20 = candles.slice(-20);
  s.sma20 = last20.reduce((a,c)=>a+c.close,0) / last20.length;

  const w = candles.slice(-CONFIG.SWING_WINDOW);
  s.swingLow20 = Math.min(...w.map(c => c.low));
  s.swingHigh20 = Math.max(...w.map(c => c.high));
  const lastClose = candles[candles.length-1].close;
  s.range20Pct = lastClose > 0 ? ((s.swingHigh20 - s.swingLow20) / lastClose * 100) : null;

  // coin 2h returnï¼ˆSWING_WINDOW=24æ ¹=2hï¼‰
  if (w.length >= 2) {
    const first = w[0].close;
    const last = w[w.length-1].close;
    const coin2h = (first > 0) ? ((last/first - 1) * 100) : null;
    if (coin2h !== null && btc.ret2hPct !== null) {
      s.rel2h_vs_btc = coin2h - btc.ret2hPct;
    }
  }

  const n = CONFIG.ATR_PERIOD;
  const trs = [];
  for (let i=1; i<candles.length; i++) {
    const cur = candles[i];
    const prev = candles[i-1];
    const tr = Math.max(
      cur.high - cur.low,
      Math.abs(cur.high - prev.close),
      Math.abs(cur.low - prev.close)
    );
    trs.push(tr);
  }
  if (trs.length >= n) {
    const lastTR = trs.slice(-n);
    s.atr14 = lastTR.reduce((a,v)=>a+v,0) / lastTR.length;
  }

  if (s.atr14 && s.atr14 > 0 && s.sma20 && lastClose) {
    s.distSma20Atr = Math.abs(lastClose - s.sma20) / s.atr14;
  }

  s.klinesReady = true;
}

function computeOIDeltas(sym) {
  const s = symState[sym];
  if (!s || s.oiSamples.length < 3) return;
  const now = Date.now();

  const getOiAgo = (ms) => {
    const t = now - ms;
    let best = null;
    for (let i=s.oiSamples.length-1; i>=0; i--) {
      if (s.oiSamples[i].ts <= t) { best = s.oiSamples[i]; break; }
    }
    return best ? best.oi : null;
  };

  const oi5m = getOiAgo(5*60*1000);
  const oi4h = getOiAgo(4*60*60*1000);

  if (oi5m !== null && s.oiCurrent !== null) s.oiDelta5m = s.oiCurrent - oi5m;
  if (oi4h !== null && s.oiCurrent !== null) s.oiDelta4h = s.oiCurrent - oi4h;
}

function utcMidnightMs() {
  const now = new Date();
  const y = now.getUTCFullYear();
  const m = now.getUTCMonth();
  const d = now.getUTCDate();
  return Date.UTC(y,m,d,0,0,0,0);
}

async function refreshTodayVP(sym) {
  const s = symState[sym];
  if (!s) return;

  const now = Date.now();
  if (s.vpLastTs && now - s.vpLastTs < CONFIG.VP_REFRESH_MS) return;

  try {
    setStatus("vpStatus","æ›´æ–°ä¸­â€¦","warn");
    const start = utcMidnightMs();
    const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=5m&startTime=${start}&limit=${CONFIG.VP_5M_LIMIT}`;
    const k = await fetchJSON(url);

    if (!Array.isArray(k) || k.length < 20) return;

    const pts = k.map(x => {
      const h = parseFloat(x[2]), l = parseFloat(x[3]), c = parseFloat(x[4]);
      const qv = parseFloat(x[7]);
      const tp = (h+l+c)/3;
      return { p: tp, v: qv };
    }).filter(x => isFinite(x.p) && isFinite(x.v) && x.v > 0);

    if (pts.length < 10) return;

    const pMin = Math.min(...pts.map(x=>x.p));
    const pMax = Math.max(...pts.map(x=>x.p));
    if (pMax <= pMin) return;

    const bins = CONFIG.VP_BINS;
    const step = (pMax - pMin) / bins;
    const hist = new Array(bins).fill(0);

    for (const x of pts) {
      let idx = Math.floor((x.p - pMin) / step);
      if (idx < 0) idx = 0;
      if (idx >= bins) idx = bins-1;
      hist[idx] += x.v;
    }

    const total = hist.reduce((a,b)=>a+b,0);
    if (total <= 0) return;

    let pocIdx = 0;
    for (let i=1;i<hist.length;i++) if (hist[i] > hist[pocIdx]) pocIdx = i;
    const poc = pMin + (pocIdx + 0.5) * step;

    const sorted = hist.map((v,i)=>({v,i})).sort((a,b)=>b.v-a.v);
    let acc = 0;
    const take = new Set();
    for (const it of sorted) {
      take.add(it.i);
      acc += it.v;
      if (acc/total >= 0.7) break;
    }
    const idxs = [...take].sort((a,b)=>a-b);
    const val = pMin + (idxs[0]) * step;
    const vah = pMin + (idxs[idxs.length-1]+1) * step;

    const topNodes = sorted.slice(0,3).map(it => {
      const center = pMin + (it.i + 0.5) * step;
      return { price: center, vol_pct: it.v/total*100 };
    });

    const cur = s.price || pts[pts.length-1].p;
    const priceVsPocPct = (cur && poc) ? ((cur - poc)/cur*100) : null;

    s.vpToday = {
      poc, val, vah, topNodes,
      priceVsPocPct,
      bins,
      totalNotional: total,
      rangePct: (cur>0)?((pMax-pMin)/cur*100):null
    };
    s.vpLastTs = now;
    setStatus("vpStatus", "OK", "ok");
  } catch (e) {
    console.warn("VP fail", sym, e);
    setStatus("vpStatus", "FAIL", "bad");
  }
}

/* ===========================
   Derive: stage / tags / preScore (åŠ å…¥ BTC RS + LIQ)
=========================== */
function deriveSymbol(sym) {
  const s = symState[sym];
  if (!s) return;

  const T = CONFIG.THRESH;

  const antiChase =
    (s.ret5mPct !== null && s.ret5mPct > CONFIG.ANTI_CHASE.ret5mPctMax) ||
    (s.distSma20Atr !== null && s.distSma20Atr > CONFIG.ANTI_CHASE.distSmaAtrMax) ||
    (s.range20Pct !== null && s.range20Pct > CONFIG.ANTI_CHASE.range20PctMax);

  const tags = [];
  const vzEff = (s.volZ5m !== null) ? s.volZ5m : (s.volZcs ?? null);
  const dzEff = (s.deltaZ5m !== null) ? s.deltaZ5m : (s.deltaZcs ?? null);

  if (vzEff !== null && vzEff >= 2.0) tags.push("é‡èƒ½çˆ†é‡");
  else if (vzEff !== null && vzEff >= 1.2) tags.push("é‡èƒ½ç•°å¸¸");

  if (s.delta5mNotional !== null && s.delta5mNotional > 0) tags.push("ä¸»å‹•è²·å·®é¡>0");
  if (s.imbalance5m !== null && s.imbalance5m >= 0.55) tags.push("è²·ç›¤ä½”å„ª");
  if (s.oiDelta5m !== null && s.oiDelta5m > 0) tags.push("OI(5m)ä¸Šå‡");
  if (s.oiDelta4h !== null && s.oiDelta4h > 0) tags.push("OI(4h)ä¸Šå‡");
  if (s.fundingPct !== null && s.fundingPct < 0) tags.push("è³‡é‡‘è²»ç‡åç©º(åˆ©å¤šåšå¤š)");
  if (s.range20Pct !== null && s.range20Pct < 0.9) tags.push("çª„å¹…æ”¶æ–‚");
  if (s.swingHigh20 && s.price && (s.swingHigh20 - s.price)/s.price*100 < 0.25) tags.push("æ¥è¿‘çªç ´ä½");

  // BTC ç›¸å°å¼·å¼± tag
  if (CONFIG.BTC_RS.enable && s.rel5m_vs_btc !== null && btc.ret5mPct !== null) {
    if (btc.ret5mPct <= CONFIG.BTC_RS.btcDownGatePct) {
      if (s.rel5m_vs_btc >= 0.30) tags.push("BTCè·Œ é€†å‹¢æ›´å¼·");
      else if (s.rel5m_vs_btc >= 0.10) tags.push("BTCè·Œ æŠ—è·Œ");
    }
  }

  // Liquidation tagï¼šçŸ­å–®å¼·å¹³ï¼ˆBUYï¼‰å¤šæ–¼å¤šå–®å¼·å¹³ï¼ˆSELLï¼‰ = åå¤š
  if (CONFIG.LIQ.enable) {
    const net = s.liqNetShort5m || 0;
    if (net >= CONFIG.LIQ.minNotionalTag) tags.push("ç©ºå–®å¼·å¹³åå¤š");
    if (net <= -CONFIG.LIQ.minNotionalTag) tags.push("å¤šå–®å¼·å¹³åç©º");
  }

  if (antiChase) tags.push("å·²æ€¥æ‹‰/è¿½åƒ¹é¢¨éšª");
  s.tags = tags;

  const flowOK =
    (s.delta5mNotional !== null && s.delta5mNotional > T.deltaNotionalMin) &&
    (s.imbalance5m !== null && s.imbalance5m >= (0.5 + T.imbalanceMin));

  const volOK = (vzEff !== null && vzEff >= T.volZMin);
  const notDump = (s.ret5mPct === null) ? true : (s.ret5mPct > -1.0);

  const setup = volOK && flowOK && notDump && !antiChase;
  const ignite = setup && (s.price !== null && s.sma20 !== null && s.price > s.sma20);
  const confirm = ignite && (s.swingHigh20 !== null && s.price !== null && s.price >= s.swingHigh20);

  if (antiChase) s.stage = "è¿½åƒ¹é¢¨éšª";
  else if (confirm) s.stage = "è§¸ç™¼";
  else if (ignite) s.stage = "é»ç«";
  else if (setup) s.stage = "è“„å‹¢";
  else s.stage = "å†·å»";

  let score = 50;
  const vz = (vzEff === null) ? 0 : clamp(vzEff, -3, 3);
  const dz = (dzEff === null) ? 0 : clamp(dzEff, -3, 3);

  score += 10 * vz;
  score += 8 * dz;

  if (s.delta5mNotional !== null) score += clamp(s.delta5mNotional / 60000, -8, 12);

  if (s.oiDelta5m !== null && s.oiDelta4h !== null) {
    if (s.oiDelta5m > 0 && s.oiDelta4h > 0) score += 6;
    if (s.oiDelta5m < 0 && s.oiDelta4h < 0) score -= 4;
  }

  if (s.fundingPct !== null && s.fundingPct < 0) score += 3;
  if (s.premiumPct !== null && Math.abs(s.premiumPct) > 0.25) score -= 2;

  // BTC ç›¸å°å¼·å¼±åŠ åˆ†ï¼ˆåªåœ¨ BTC æ˜é¡¯ä¸‹è·Œæ™‚ï¼‰
  if (CONFIG.BTC_RS.enable && s.rel5m_vs_btc !== null && btc.ret5mPct !== null) {
    if (btc.ret5mPct <= CONFIG.BTC_RS.btcDownGatePct) {
      const rel2h = (s.rel2h_vs_btc !== null) ? s.rel2h_vs_btc : 0;
      const relMix = s.rel5m_vs_btc * (1-CONFIG.BTC_RS.rel2hWeight) + rel2h * CONFIG.BTC_RS.rel2hWeight;
      const boost = clamp(relMix * CONFIG.BTC_RS.rel5mScale, 0, CONFIG.BTC_RS.rel5mBoostMax);
      score += boost;
    }
  }

  // Liquidationï¼šçŸ­å–®å¼·å¹³æ·¨é¡ï¼ˆåå¤šï¼‰åŠ åˆ†ï¼›å¤šå–®å¼·å¹³æ·¨é¡ï¼ˆåç©ºï¼‰æ‰£åˆ†
  if (CONFIG.LIQ.enable) {
    const net = s.liqNetShort5m || 0;
    const liqAdj = clamp((net / 1000000) * CONFIG.LIQ.scoreScale, -8, 8);
    score += liqAdj;
  }

  if (antiChase) score -= 18;
  if (s.ret5mPct !== null && s.ret5mPct < -0.6) score -= 6;

  s.preScore = clamp(score, 0, 100);
}

/* ===========================
   Tracking Top10 + Pin protection
=========================== */
function scoreOf(sym) { return (symState[sym]?.preScore ?? 0); }

function updateTrackedTopN(eligibleStates) {
  const keepN = CONFIG.CANDIDATE_LIMIT;
  const margin = CONFIG.TRACKING?.replaceMargin ?? 0;

  const uSet = new Set(universe);
  trackedTopN = trackedTopN.filter(sym => uSet.has(sym) && symState[sym]);

  for (const ps of Array.from(pinnedSet)) {
    if (symState[ps] && !trackedTopN.includes(ps)) trackedTopN.push(ps);
  }

  trackedTopN.sort((a,b) => scoreOf(b) - scoreOf(a));

  const findReplaceableWeak = () => {
    const arr = [...trackedTopN].sort((a,b) => scoreOf(a) - scoreOf(b));
    for (const sym of arr) {
      if (!pinnedSet.has(sym)) return sym;
    }
    return null;
  };

  for (const s of eligibleStates) {
    const sym = s.symbol;
    if (trackedTopN.includes(sym)) continue;

    if (trackedTopN.length < keepN) {
      trackedTopN.push(sym);
      trackedTopN.sort((a,b) => scoreOf(b) - scoreOf(a));
      continue;
    }

    const weakSym = findReplaceableWeak();
    if (!weakSym) continue;

    const weakScore = scoreOf(weakSym);
    const newScore = scoreOf(sym);

    if (newScore > weakScore + margin) {
      trackedTopN = trackedTopN.filter(x => x !== weakSym);
      trackedTopN.push(sym);
      trackedTopN.sort((a,b) => scoreOf(b) - scoreOf(a));
    }
  }

  if (trackedTopN.length > keepN) {
    const pinnedArr = trackedTopN.filter(x => pinnedSet.has(x));
    const others = trackedTopN.filter(x => !pinnedSet.has(x)).sort((a,b)=>scoreOf(b)-scoreOf(a));
    trackedTopN = [...pinnedArr, ...others].slice(0, keepN);
  }
}

/* ===========================
   Candidate selection (ä¿®æ­£ï¼šå…ˆé ç†± klinesï¼Œå†ç”¨ klinesReady åšé–€æª»)
=========================== */
function buildTrackedTopN() {
  computeCrossSectionZ();

  const ex = new Set([...CONFIG.TOPCAP_EXCLUDE, ...CONFIG.EXCLUDE_EXTRA]);

  const arr = universe
    .filter(sym => !hiddenSet.has(sym))
    .filter(sym => !ex.has(sym))
    .filter(sym => !isFxCommodity(sym))
    .map(sym => symState[sym])
    .filter(s => s && s.price !== null)
    // âœ… ç†±æ©Ÿé–€æª»ï¼š>=6min + è‡³å°‘2å€‹bucket
    .filter(s => (Date.now() - s.firstSeenTs) >= CONFIG.WARMUP_MIN_MS)
    .filter(s => (s.histBuckets ?? 0) >= CONFIG.MIN_HIST_BUCKETS)
    // âœ… klinesReady é–€æª»ä¿ç•™ï¼Œä½†ã€Œå·²ä¿®æ­£é ç†±æ©Ÿåˆ¶ã€ä¸æœƒå¡æ­»
    .filter(s => s.klinesReady === true)
    .filter(s => {
      const T = CONFIG.THRESH;
      const longBias = (s.delta5mNotional !== null && s.delta5mNotional > 0) &&
                       (s.imbalance5m !== null && s.imbalance5m >= (0.5 + T.imbalanceMin));
      if (!longBias) return false;
      if (s.preScore < T.preScoreMin) return false;
      if (s.stage === "å†·å»") return false;
      return true;
    })
    .sort((a,b) => b.preScore - a.preScore)
    .slice(0, 40);

  if (CONFIG.TRACKING?.enabled) updateTrackedTopN(arr);

  candidatesTopN = trackedTopN.slice(0, CONFIG.CANDIDATE_LIMIT);
  $("candN").textContent = candidatesTopN.length;
  updatePinBadge();
  updateHiddenBadge();

  for (const sym of candidatesTopN) {
    ensureKlinesAndOI(sym);
    refreshTodayVP(sym);
  }

  const summaries = candidatesTopN.map(sym => buildSummary(sym)).filter(Boolean);
  $("debugJSON").textContent = JSON.stringify({ top10: summaries }, null, 2);
}

/* ===========================
   Summary to AI
=========================== */
function buildSummary(sym) {
  const s = symState[sym];
  if (!s) return null;

  const vzEff = (s.volZ5m !== null) ? s.volZ5m : s.volZcs;

  const vp = s.vpToday;
  return {
    symbol: s.symbol,
    price: s.price,

    ret5m_pct: s.ret5mPct,
    vol5m_notional: s.vol5mNotional,
    volZ_5m: vzEff,

    active_buy_delta_5m_notional: s.delta5mNotional,
    buy_ratio_5m: s.imbalance5m,

    funding_pct: s.fundingPct,
    premium_pct: s.premiumPct,

    oi_delta_5m: s.oiDelta5m,
    oi_delta_4h: s.oiDelta4h,

    // BTC relative
    btc_ret5m_pct: s.btc_ret5m,
    btc_ret2h_pct: s.btc_ret2h,
    rel5m_vs_btc: s.rel5m_vs_btc,
    rel2h_vs_btc: s.rel2h_vs_btc,

    // liquidation
    liq_short_notional_5m: s.liqShortNotional5m,
    liq_long_notional_5m: s.liqLongNotional5m,
    liq_net_short_5m: s.liqNetShort5m,

    atr14: s.atr14,
    swing_low_20: s.swingLow20,
    swing_high_20: s.swingHigh20,
    range_20_pct: s.range20Pct,
    sma20: s.sma20,
    dist_sma20_atr: s.distSma20Atr,

    today_vp: vp ? {
      poc: vp.poc,
      val: vp.val,
      vah: vp.vah,
      price_vs_poc_pct: vp.priceVsPocPct,
      top_nodes: (vp.topNodes || []).map(n => ({ price: n.price, vol_pct: n.vol_pct })),
      day_range_pct: vp.rangePct
    } : null,

    stage: s.stage,
    preScore: s.preScore,
    tags: s.tags,

    kline_interval: CONFIG.KLINES_INTERVAL,
    warmup_minutes: Math.floor((Date.now() - s.firstSeenTs)/60000)
  };
}

/* ===========================
   âœ… Precise TP algorithm (ä¿ç•™ä½ åŸæœ¬çš„ R + é˜»åŠ›ä¿®æ­£)
=========================== */
function uniqNums(arr) {
  const out = [];
  const seen = new Set();
  for (const x of arr) {
    if (!isFinite(x)) continue;
    const k = x.toFixed(12);
    if (seen.has(k)) continue;
    seen.add(k);
    out.push(x);
  }
  return out;
}

function computePreciseTPs(summary, entry, stop) {
  const price = summary.price || 0;
  const atr = (summary.atr14 && summary.atr14 > 0) ? summary.atr14 : Math.max(price * 0.002, 1e-12);

  let entryMid = price;
  if (entry && Array.isArray(entry.zone) && entry.zone.length === 2) {
    entryMid = (Number(entry.zone[0]) + Number(entry.zone[1])) / 2;
  }

  const stopPrice = Number(stop?.price);
  let R = entryMid - stopPrice;
  if (!isFinite(R) || R <= 0) R = Math.max(atr, entryMid * 0.003);

  const minStep = Math.max(0.6 * R, 0.5 * atr);

  const resist = [];
  const vp = summary.today_vp;
  if (vp?.poc) resist.push(Number(vp.poc));
  if (vp?.vah) resist.push(Number(vp.vah));
  if (Array.isArray(vp?.top_nodes)) for (const n of vp.top_nodes) if (n?.price) resist.push(Number(n.price));
  if (summary.swing_high_20) resist.push(Number(summary.swing_high_20));

  const resistUp = uniqNums(resist)
    .filter(x => isFinite(x) && x > entryMid)
    .sort((a,b)=>a-b);

  const ks = CONFIG.TP_K;
  const targets = [];

  for (let i=0; i<3; i++) {
    const floor = entryMid + ks[i]*R;
    let t = resistUp.find(x => x >= floor);
    if (!t) t = floor;

    if (i > 0 && t < targets[i-1] + minStep) t = targets[i-1] + minStep;
    if (t < entryMid + Math.max(ks[0]*R, 0.6*atr)) t = entryMid + Math.max(ks[0]*R, 0.6*atr);

    targets.push(t);
  }

  return {
    entryMid,
    R,
    tps: [
      { price: Number(targets[0].toFixed(12)), pct: 35, logic: `TP1 â‰¥ ${ks[0]}Rï¼Œå„ªå…ˆå°é½Šé˜»åŠ›(VP/ç¯€é»/å‰é«˜)ï¼ŒR=${R.toFixed(6)}` },
      { price: Number(targets[1].toFixed(12)), pct: 35, logic: `TP2 â‰¥ ${ks[1]}Rï¼Œå„ªå…ˆå°é½Šæ›´é é˜»åŠ›æˆ–å»¶ä¼¸` },
      { price: Number(targets[2].toFixed(12)), pct: 30, logic: `TP3 â‰¥ ${ks[2]}Rï¼Œæ³¢æ®µå»¶ä¼¸æ®µï¼ˆå¯æ”¹è¿½è¹¤æ­¢æï¼‰` }
    ]
  };
}

/* ===========================
   Groq AI (ä¿®æ­£ï¼šæ›´å¼·éŸŒ JSON è§£æï¼Œé¿å…ä½ é‡åˆ°çš„ã€Œcontentä¸æ˜¯æœ‰æ•ˆJSONã€)
=========================== */
function extractJSONObject(text) {
  const s = String(text || "").trim()
    .replace(/^```json\s*/i,"")
    .replace(/^```\s*/i,"")
    .replace(/```$/i,"")
    .trim();

  // å…ˆç›´æ¥ parse
  try { return JSON.parse(s); } catch {}

  // å†ç”¨ã€Œç¬¬ä¸€å€‹ { åˆ°æœ€å¾Œä¸€å€‹ }ã€ç¡¬æŠ½
  const i = s.indexOf("{");
  const j = s.lastIndexOf("}");
  if (i >= 0 && j > i) {
    const cut = s.slice(i, j+1);
    try { return JSON.parse(cut); } catch {}
  }
  return null;
}

async function groqChatCompletion({ apiKey, model, messages, maxOut = 400 }) {
  const url = "https://api.groq.com/openai/v1/chat/completions";

  // âœ… 1) JSON mode å…ˆä¸è¦ç”¨ï¼šé¿å…æ¨¡å‹è¼¸å‡ºä¸åˆæ³• JSON æ™‚ç›´æ¥ 400 json_validate_failed
  // âœ… 2) ç”¨ã€Œassistant prefill '{'ã€å¼·è¿«æ¨¡å‹å¾ JSON é–‹å§‹
  const msgs = Array.isArray(messages) ? [...messages] : [];
  msgs.push({ role: "assistant", content: "{" });

  const payload = {
    model,
    messages: msgs,
    temperature: 0.15,
    top_p: 0.9,
    max_completion_tokens: maxOut
    // âŒ ä¸è¦ response_format: { type:"json_object" }
  };

  const res = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${apiKey}`
    },
    body: JSON.stringify(payload)
  });

  const raw = await res.text();
  console.log("[Groq] HTTP", res.status, raw);

  if (!res.ok) {
    // æŠŠ Groq å¯èƒ½å›çš„ failed_generation é¡¯ç¤ºå‡ºä¾†ï¼Œæ–¹ä¾¿ä½  debug
    let errMsg = raw.slice(0, 400);
    try {
      const e = JSON.parse(raw);
      if (e?.error?.failed_generation) errMsg = String(e.error.failed_generation).slice(0, 400);
      if (e?.error?.message) errMsg = String(e.error.message).slice(0, 400);
    } catch {}
    throw new Error(`Groq HTTP ${res.status}: ${errMsg}`);
  }

  let data;
  try { data = JSON.parse(raw); } catch {
    throw new Error("Groq å›æ‡‰ä¸æ˜¯ JSONï¼ˆå¤–å±¤ï¼‰");
  }

  // content å¯èƒ½æœƒæœ‰å‰å¾Œé›œè¨Šï¼Œåšã€ŒæŠ“ç¬¬ä¸€å€‹ { åˆ°æœ€å¾Œä¸€å€‹ }ã€çš„å¼·å¥æ“·å–
  let content = data?.choices?.[0]?.message?.content ?? "";
  content = String(content).trim();

  // ç”±æ–¼æˆ‘å€‘ prefill äº† "{", æœ‰äº›æ¨¡å‹æœƒå›å‰©ä¸‹çš„ JSONï¼ˆä¸å«ç¬¬ä¸€å€‹ {ï¼‰
  // æ‰€ä»¥å¦‚æœæ²’ä»¥ { é–‹é ­ï¼Œå°±è£œå›å»
  if (!content.startsWith("{")) content = "{" + content;

  // å»æ‰ ```json code fenceï¼ˆæœ‰äº›æ¨¡å‹é‚„æ˜¯æœƒåï¼‰
  content = content
    .replace(/^```json\s*/i, "")
    .replace(/^```\s*/i, "")
    .replace(/```$/i, "")
    .trim();

  const i0 = content.indexOf("{");
  const i1 = content.lastIndexOf("}");
  if (i0 < 0 || i1 <= i0) {
    throw new Error("æ¨¡å‹ content æ‰¾ä¸åˆ°å®Œæ•´ JSON å€å¡Šï¼š" + content.slice(0, 200));
  }

  const jsonText = content.slice(i0, i1 + 1);

  try {
    return JSON.parse(jsonText);
  } catch (e) {
    throw new Error("æ¨¡å‹ content ä¸æ˜¯æœ‰æ•ˆ JSONï¼š" + jsonText.slice(0, 200));
  }
}

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type":"application/json", "Authorization": `Bearer ${apiKey}` },
    body: JSON.stringify(payload)
  });

  const raw = await res.text();
  console.log("[Groq] HTTP", res.status, raw);

  if (!res.ok) throw new Error(`Groq HTTP ${res.status}: ${raw.slice(0,200)}`);

  let data;
  try { data = JSON.parse(raw); } catch { throw new Error("Groq å›æ‡‰ä¸æ˜¯ JSONï¼ˆHTTP bodyï¼‰"); }

  const content = data?.choices?.[0]?.message?.content ?? "";
  const obj = extractJSONObject(content);
  if (!obj) throw new Error("æ¨¡å‹ content ä¸æ˜¯æœ‰æ•ˆ JSONï¼ˆå·²å˜—è©¦æŠ½å–ç‰©ä»¶ï¼‰: " + String(content).slice(0,200));
  return obj;
}

/* ===========================
   AI prompts (åŠ å…¥ BTC/LIQ æ¬„ä½èªªæ˜)
=========================== */
function buildAiPrompt(top10Summaries) {
  const system = `
ä½ æ˜¯åŠ å¯†åˆç´„ã€Œåªåšå¤šã€äº¤æ˜“åŠ©æ‰‹ã€‚è«‹å…¨éƒ¨ç”¨ä¸­æ–‡è¼¸å‡ºã€‚
ä½ åªçœ‹åˆ°è¼¸å…¥æ‘˜è¦ï¼ˆä¸å¯å‡è£çœ‹Kç·šåœ–/æ·±åº¦/æ–°èï¼‰ã€‚
ä»»å‹™ï¼šå¾ candidates(10) ä¸­é¸å‡º top5ï¼Œæ‰¾ã€Œ10~60åˆ†é˜å…§å¯èƒ½å‘ä¸Šè¡¨æ…‹ã€ä¸”ã€Œä¸è¿½åƒ¹ã€ï¼Œå 5m(5K)å°æ³¢æ®µã€‚

ã€BTC ç›¸å°å¼·å¼±ï¼ˆåŠ åˆ†è¦å‰‡ï¼‰ã€‘
- è‹¥ btc_ret5m_pct æ˜é¡¯ç‚ºè² ï¼ˆ<= -0.25%ï¼‰ï¼Œè€Œå€™é¸ rel5m_vs_btc / rel2h_vs_btc ç‚ºæ­£ï¼Œè¦–ç‚ºã€ŒæŠ—è·Œ/é€†å‹¢ã€åŠ åˆ†ç†ç”±ã€‚

ã€Liquidation feedï¼ˆå¼·å¹³ï¼‰è§£è®€ã€‘
- liq_net_short_5m = ç©ºå–®å¼·å¹³(BUY) - å¤šå–®å¼·å¹³(SELL)
- è‹¥ liq_net_short_5m æ˜é¡¯ç‚ºæ­£ï¼Œä»£è¡¨ç©ºå–®è¢«å˜ï¼Œæœ‰åˆ©åšå¤šï¼›ç‚ºè² ä»£è¡¨å¤šå–®è¢«æ´—ï¼Œé¢¨éšªè¼ƒå¤§ã€‚

ã€ç²¾æº–æ­¢ç›ˆç¡¬è¦å‰‡ï¼ˆå¿…é ˆéµå®ˆï¼‰ã€‘
å®šç¾©ï¼š
- entry_mid = (entry.zone[0]+entry.zone[1])/2ï¼ˆè‹¥ market ç”¨ current.priceï¼‰
- R = entry_mid - stop.priceï¼ˆåšå¤šï¼ŒR å¿…é ˆ > 0ï¼‰
é˜»åŠ›é›†åˆï¼ˆåªå– entry_mid ä¸Šæ–¹ï¼‰ï¼štoday_vp.pocã€today_vp.vahã€today_vp.top_nodes[].priceã€swing_high_20
è¦å‰‡ï¼ˆ5Kæ³¢æ®µ floorï¼‰ï¼š
- TP1 å¿…é ˆ >= entry_mid + 1.3R
- TP2 å¿…é ˆ >= entry_mid + 2.6R
- TP3 å¿…é ˆ >= entry_mid + 4.0R
- æ¯æ®µ TP é–“è· >= max(0.6R, 0.5*atr14)
é¸åƒ¹ï¼š
- å…ˆç®— floor_i = entry_mid + k_i*R (k=1.3,2.6,4.0)
- åœ¨é˜»åŠ›é›†åˆä¸­æ‰¾ç¬¬ä¸€å€‹ >= floor_i çš„é˜»åŠ›åƒ¹ï¼Œæœ‰å‰‡ç”¨é˜»åŠ›åƒ¹ï¼›å¦å‰‡ç”¨ floor_i
- ä¸¦åœ¨ takeProfit.logic å¯«å‡ºï¼šç”¨åˆ°å“ªå€‹é˜»åŠ›æˆ–ç”¨åˆ° R å€æ•¸

ã€ä¸è¿½åƒ¹ã€‘
è‹¥ ret5m_pct éé«˜æˆ– dist_sma20_atr å¤ªå¤§ï¼Œentry å¿…é ˆæ”¹ç‚ºç­‰å¾…å›è¸©çš„ limit zoneï¼Œä¸å¯è¿½åƒ¹ã€‚

è¼¸å‡ºå¿…é ˆæ˜¯å–®ä¸€ JSON ç‰©ä»¶ï¼ˆä¸è¦ä»»ä½•å¤šé¤˜æ–‡å­—ï¼‰ã€‚
JSON æ ¼å¼ï¼š
{
  "top5":[
    {
      "symbol":"XXXUSDT",
      "score":0-100,
      "confidence":0-100,
      "eta_minutes":"10-30"|"30-60"|"60-120",
      "stage":"è“„å‹¢"|"é»ç«"|"è§¸ç™¼"|"è¿½åƒ¹é¢¨éšª",
      "entry":{"type":"limit"|"market","zone":[low,high],"trigger":"...","logic":"..."},
      "stop":{"price":number,"logic":"..."},
      "takeProfit":[{"price":number,"pct":number,"logic":"..."}],
      "invalidation":"...",
      "reasons":["..."],
      "risks":["..."]
    }
  ]
}
  `.trim();

  const user = {
    mode: "LONG_ONLY",
    note: "å€™é¸å·²æ’é™¤ XAU/XAG/å¤–åŒ¯ã€ä¹Ÿæ’é™¤å¤§å¹£ï¼›è³‡æ–™å±¬ 5m(5K)å°æ³¢æ®µã€‚åŒ…å« BTC ç›¸å°å¼·å¼± & Liquidation feedã€‚",
    candidates: top10Summaries
  };

  return [
    { role:"system", content: system },
    { role:"user", content: JSON.stringify(user) }
  ];
}

function buildAiPromptSingle(symbol, currentSummary, prevAdvice) {
  const system = `
ä½ æ˜¯åŠ å¯†åˆç´„ã€Œåªåšå¤šã€äº¤æ˜“åŠ©æ‰‹ã€‚è«‹å…¨éƒ¨ç”¨ä¸­æ–‡è¼¸å‡ºã€‚
ä½ æœƒæ”¶åˆ° currentï¼ˆæœ€æ–°æ‘˜è¦ï¼‰èˆ‡ previousï¼ˆä¸Šä¸€æ¬¡å»ºè­°ï¼‰ã€‚
ä»»å‹™ï¼šé‡å°åŒä¸€å¹£ç¨®ï¼ŒåŸºæ–¼ current èˆ‡ previous çš„å·®ç•°ï¼Œè¼¸å‡ºæ›´æ–°å¾Œçš„å»ºè­°ï¼ˆå 5m(5K)å°æ³¢æ®µï¼‰ã€‚
å¿…é ˆçµ¦ï¼šscore/confidence/eta_minutes/entry/stop/takeProfit/invalidation/reasons/risks

ã€BTC ç›¸å°å¼·å¼±ã€‘
- BTC ä¸‹è·Œæ™‚ï¼ˆbtc_ret5m_pct<=-0.25ï¼‰ï¼Œè‹¥ rel5m_vs_btc/rel2h_vs_btc ç‚ºæ­£ï¼Œè«‹å¯«ç‚ºç†ç”±ï¼ˆæŠ—è·Œ/é€†å‹¢ï¼‰ã€‚

ã€Liquidation feedï¼ˆå¼·å¹³ï¼‰ã€‘
- liq_net_short_5m > 0ï¼šç©ºå–®è¢«å˜ï¼ˆåå¤šï¼‰ï¼›<0ï¼šå¤šå–®è¢«æ´—ï¼ˆåç©ºé¢¨éšªï¼‰ã€‚

ã€ç²¾æº–æ­¢ç›ˆç¡¬è¦å‰‡ï¼ˆå¿…é ˆéµå®ˆï¼‰ã€‘
- entry_mid = (entry.zone[0]+entry.zone[1])/2ï¼ˆè‹¥ market ç”¨ current.priceï¼‰
- R = entry_mid - stop.priceï¼ˆåšå¤š R>0ï¼‰
é˜»åŠ›é›†åˆï¼štoday_vp.pocã€today_vp.vahã€today_vp.top_nodes[].priceã€swing_high_20ï¼ˆåƒ…å– entry_mid ä¸Šæ–¹ï¼‰
- TP1 >= entry_mid + 1.3R
- TP2 >= entry_mid + 2.6R
- TP3 >= entry_mid + 4.0R
- TP é–“è· >= max(0.6R, 0.5*atr14)
é¸åƒ¹ï¼šç”¨é˜»åŠ›åƒ¹å„ªå…ˆï¼Œå¦å‰‡ç”¨ R å€æ•¸ floorï¼›ä¸¦åœ¨ logic å¯«æ˜ä¾æ“šã€‚

è‹¥ current é¡¯ç¤ºè¿½åƒ¹é¢¨éšªï¼Œentry å¿…é ˆæ”¹æˆç­‰å¾…å›è¸©çš„ limit zoneï¼ˆä¸å¯è¿½åƒ¹ï¼‰ã€‚
è¼¸å‡ºå¿…é ˆæ˜¯å–®ä¸€ JSON ç‰©ä»¶ï¼ˆä¸è¦å¤šé¤˜æ–‡å­—ï¼‰ï¼š
{
  "symbol":"XXXUSDT",
  "score":0-100,
  "confidence":0-100,
  "eta_minutes":"10-30"|"30-60"|"60-120",
  "stage":"è“„å‹¢"|"é»ç«"|"è§¸ç™¼"|"è¿½åƒ¹é¢¨éšª",
  "entry":{"type":"limit"|"market","zone":[low,high],"trigger":"...","logic":"..."},
  "stop":{"price":number,"logic":"..."},
  "takeProfit":[{"price":number,"pct":number,"logic":"..."}],
  "invalidation":"...",
  "reasons":["..."],
  "risks":["..."]
}
  `.trim();

  const user = { mode:"LONG_ONLY", symbol, current: currentSummary, previous: prevAdvice || null };

  return [
    { role:"system", content: system },
    { role:"user", content: JSON.stringify(user) }
  ];
}

function stageClass(stage) {
  if (stage === "è“„å‹¢") return "stage-setup";
  if (stage === "é»ç«") return "stage-ignite";
  if (stage === "è§¸ç™¼") return "stage-confirm";
  if (stage === "è¿½åƒ¹é¢¨éšª") return "stage-chase";
  return "stage-cool";
}

/* ===========================
   Normalize (force TP by algorithm if too close)
=========================== */
function normalizeAiPick(sym, summary, pick) {
  const price = summary.price || 0;
  const atr = (summary.atr14 && summary.atr14 > 0) ? summary.atr14 : (price * 0.002);

  const safe = (x, fallback) => (x === null || x === undefined || Number.isNaN(x)) ? fallback : x;

  const out = {
    symbol: sym,
    score: clamp(safe(pick.score, summary.preScore || 50), 0, 100),
    confidence: clamp(safe(pick.confidence, 60), 0, 100),
    eta_minutes: pick.eta_minutes || "30-60",
    stage: pick.stage || summary.stage || "è“„å‹¢",
    direction: "åšå¤š",

    entry: (pick.entry && typeof pick.entry === "object") ? pick.entry : null,
    stop: (pick.stop && typeof pick.stop === "object") ? pick.stop : null,
    takeProfit: Array.isArray(pick.takeProfit) ? pick.takeProfit : [],
    invalidation: pick.invalidation || "",
    reasons: Array.isArray(pick.reasons) ? pick.reasons : [],
    risks: Array.isArray(pick.risks) ? pick.risks : [],
  };

  if (!out.entry) {
    const vp = summary.today_vp;
    const z1 = vp?.val ? vp.val : (price - 0.8*atr);
    const z2 = vp?.poc ? Math.min(vp.poc, price - 0.3*atr) : (price - 1.2*atr);
    const lo = Math.min(z1,z2), hi = Math.max(z1,z2);
    out.entry = {
      type: (summary.stage === "è§¸ç™¼") ? "market" : "limit",
      zone: [Number(lo.toFixed(12)), Number(hi.toFixed(12))],
      trigger: (summary.stage === "è§¸ç™¼") ? "è§¸ç™¼éšæ®µå¯å¸‚åƒ¹åˆ†æ‰¹é€²" : "ç­‰å¾…å›è¸©é€²å…¥å€é–“åˆ†æ‰¹ï¼Œä¸è¿½åƒ¹",
      logic: "5m(5K)æ³¢æ®µï¼šçºŒåŠ› + å›è¸©åˆ° VP/ATR æ”¯æ’å€"
    };
  }

  if (!out.stop) {
    const low = summary.swing_low_20 || (price - 2*atr);
    const stopPrice = (low - 0.4 * atr);
    out.stop = { price: Number(stopPrice.toFixed(12)), logic: "5m swing low ä¸‹æ–¹ + 0.4ATR ä½œå¤±æ•ˆé»" };
  } else {
    out.stop.price = Number(out.stop.price);
  }

  const tpNeedFix = (() => {
    if (!out.takeProfit || out.takeProfit.length < 3) return true;
    const entryMid = (out.entry?.zone?.length === 2) ? ((Number(out.entry.zone[0]) + Number(out.entry.zone[1]))/2) : price;
    const R = entryMid - Number(out.stop?.price);
    if (!isFinite(R) || R <= 0) return true;

    const ks = CONFIG.TP_K;
    const tps = out.takeProfit.map(x => Number(x.price)).filter(x=>isFinite(x)).sort((a,b)=>a-b);
    if (tps.length < 3) return true;

    if (tps[0] < entryMid + ks[0]*R) return true;
    if (tps[1] < entryMid + ks[1]*R) return true;
    if (tps[2] < entryMid + ks[2]*R) return true;

    const minStep = Math.max(0.6*R, 0.5*(summary.atr14 || atr || 0));
    if (tps[1] - tps[0] < minStep) return true;
    if (tps[2] - tps[1] < minStep) return true;

    return false;
  })();

  if (tpNeedFix) {
    const tpPack = computePreciseTPs(summary, out.entry, out.stop);
    out.takeProfit = tpPack.tps;
    out.reasons = (out.reasons || []);
    out.reasons.unshift(`å·²å¥—ç”¨5m(5K)ç²¾æº–æ­¢ç›ˆï¼šfloor=${CONFIG.TP_K.join("/") }R + é˜»åŠ›(VP/ç¯€é»/å‰é«˜)ï¼ŒR=${tpPack.R.toFixed(6)}`);
  } else {
    out.takeProfit = out.takeProfit
      .map(tp => ({ price: Number(tp.price), pct: Number(tp.pct ?? 0), logic: String(tp.logic ?? "") }))
      .filter(tp => isFinite(tp.price))
      .sort((a,b)=>a.price-b.price);
  }

  if (!out.invalidation) out.invalidation = "è·Œç ´ stop æˆ– 5m ä¸»å‹•è²·å·®é¡è½‰è² ä¸”é‡èƒ½é€€æ½®";
  if (!out.reasons.length) out.reasons = ["å€™é¸æ± å…§ç•°å¸¸åˆ†æ•¸è¼ƒé«˜ï¼ˆé‡èƒ½/ä¸»å‹•è²·/OI/BTCç›¸å°/å¼·å¹³ç¶œåˆï¼‰"];
  if (!out.risks.length) out.risks = ["è‹¥ 5m æ¼²å¹…å¿«é€Ÿæ“´å¤§å±¬è¿½åƒ¹é¢¨éšªï¼Œéœ€ç­‰å›è¸©å†é€²"];

  return out;
}

/* ===========================
   Batch AI + Single AI
=========================== */
async function runAIOnce(force=false) {
  const now = Date.now();
  if (!force) {
    if (!AUTO_AI) return;
    if (now < aiBackoffUntil) return;
    if (now - lastAiTs < CONFIG.AI_INTERVAL_MS) return;
  }

  const poolSyms = candidatesTopN.slice(0, CONFIG.AI_INPUT_SIZE);
  if (poolSyms.length < CONFIG.MIN_AI_POOL) {
    setStatus("aiStatus", `ç­‰å¾… Top10 æˆå½¢ï¼ˆç›®å‰ ${poolSyms.length}/${CONFIG.MIN_AI_POOL}ï¼‰`, "warn");
    return;
  }

  const key = $("aiKey").value.trim();
  if (!key) { setStatus("aiStatus","ç¼º Groq Key","bad"); return; }

  const model = $("modelSel").value;
  setStatus("aiStatus", "AI åˆ†æä¸­â€¦", "warn");

  await Promise.all(poolSyms.map(sym => refreshTodayVP(sym)));

  const summaries = poolSyms.map(sym => buildSummary(sym)).filter(Boolean);
  $("debugJSON").textContent = JSON.stringify({ top10: summaries }, null, 2);

  try {
    const messages = buildAiPrompt(summaries);
    const obj = await groqChatCompletion({ apiKey:key, model, messages, maxOut: 520 });

    const top5Raw = Array.isArray(obj.top5) ? obj.top5 : [];
    if (!top5Raw.length) throw new Error("AI JSON ç¼º top5");

    const by = {};
    const picks = [];
    const topSet = new Set(poolSyms);

    for (const p of top5Raw) {
      const sym = (p.symbol || "").toUpperCase();
      if (!topSet.has(sym)) continue;
      const sum = summaries.find(x => x.symbol === sym) || summaries[0];
      const norm = normalizeAiPick(sym, sum, p);
      by[sym] = norm;
      picks.push(norm);

      aiHistoryBySymbol[sym] = (aiHistoryBySymbol[sym] || []).slice(-1);
      aiHistoryBySymbol[sym].push({ ts: Date.now(), advice: norm });

      if (picks.length >= CONFIG.TOP5_LIMIT) break;
    }

    if (picks.length < CONFIG.TOP5_LIMIT) {
      const remain = summaries
        .filter(x => !by[x.symbol])
        .sort((a,b) => (b.preScore||0) - (a.preScore||0));
      for (const r of remain) {
        const norm = normalizeAiPick(r.symbol, r, {});
        by[r.symbol] = norm;
        picks.push(norm);

        aiHistoryBySymbol[r.symbol] = (aiHistoryBySymbol[r.symbol] || []).slice(-1);
        aiHistoryBySymbol[r.symbol].push({ ts: Date.now(), advice: norm });

        if (picks.length >= CONFIG.TOP5_LIMIT) break;
      }
    }

    picks.sort((a,b) => (b.score - a.score) || (b.confidence - a.confidence));

    aiTop5 = picks;
    aiBySymbol = by;

    const top1 = picks[0];
    if (!pinnedTop1.symbol) {
      pinnedTop1 = { symbol: top1.symbol, score: top1.score, confidence: top1.confidence, ts: Date.now() };
    } else {
      const same = pinnedTop1.symbol === top1.symbol;
      const stronger = (top1.score >= pinnedTop1.score + 4) || (top1.confidence >= pinnedTop1.confidence + 8);
      if (!same && stronger) pinnedTop1 = { symbol: top1.symbol, score: top1.score, confidence: top1.confidence, ts: Date.now() };
    }

    lastAiTs = Date.now();
    setStatus("aiStatus", `AI OK (${model}) @ ${nowStr()}`, "ok");
    renderTop5Cards();

  } catch (e) {
    const msg = String(e?.message || e);
    console.error(e);

    if (msg.includes("429")) {
      aiBackoffUntil = Date.now() + 45*1000;
      setStatus("aiStatus", "AI 429 é™æµï¼Œbackoff 45s", "bad");
    } else {
      setStatus("aiStatus", "AI FAIL: " + msg.slice(0,90), "bad");
    }
  }
}

async function runAISingle(symbol) {
  const sym = String(symbol || "").toUpperCase();
  if (!symState[sym]) return alert("é€™å€‹å¹£ç›®å‰æ²’æœ‰ stateï¼ˆå¯èƒ½ä¸åœ¨ Top10ï¼‰");

  const key = $("aiKey").value.trim();
  if (!key) return alert("è«‹å…ˆè¼¸å…¥ Groq Key");
  const model = $("modelSel").value;

  await ensureKlinesAndOI(sym);
  await refreshTodayVP(sym);

  const current = buildSummary(sym);
  if (!current) return alert("summary ç”Ÿæˆå¤±æ•—ï¼ˆå¯èƒ½åƒ¹æ ¼é‚„æ²’åˆ°ï¼‰");

  const prev = aiBySymbol[sym] || (aiHistoryBySymbol[sym]?.slice(-1)?.[0]?.advice ?? null);

  setStatus("aiStatus", `å–®å¹£æ›´æ–°ä¸­ï¼š${sym} â€¦`, "warn");

  try {
    const messages = buildAiPromptSingle(sym, current, prev);
    const obj = await groqChatCompletion({ apiKey:key, model, messages, maxOut: 520 });

    const norm = normalizeAiPick(sym, current, obj);

    aiBySymbol[sym] = norm;
    aiHistoryBySymbol[sym] = (aiHistoryBySymbol[sym] || []).slice(-1);
    aiHistoryBySymbol[sym].push({ ts: Date.now(), advice: norm });

    const idx = aiTop5.findIndex(x => x.symbol === sym);
    if (idx >= 0) {
      aiTop5[idx] = norm;
      aiTop5.sort((a,b) => (b.score - a.score) || (b.confidence - a.confidence));
    }

    setStatus("aiStatus", `å–®å¹£æ›´æ–° OKï¼š${sym} @ ${nowStr()}`, "ok");
    renderTop5Cards();
  } catch (e) {
    console.error(e);
    setStatus("aiStatus", `å–®å¹£æ›´æ–° FAILï¼š${sym}`, "bad");
    alert("å–®å¹£æ›´æ–°å¤±æ•—ï¼š" + (e?.message || e));
  }
}

async function testAI() {
  const key = $("aiKey").value.trim();
  if (!key) return alert("è«‹å…ˆè¼¸å…¥ Groq API Key");
  const model = $("modelSel").value;

  try {
    setStatus("aiStatus", "Test AIâ€¦", "warn");
    const obj = await groqChatCompletion({
      apiKey: key,
      model,
      maxOut: 160,
      messages: [
        { role:"system", content:"åªè¼¸å‡º JSON ç‰©ä»¶ï¼Œä¸è¦ä»»ä½•å¤šé¤˜æ–‡å­—ã€‚" },
        { role:"user", content: JSON.stringify({ ping:"pong", now: Date.now() }) }
      ]
    });
    console.log("Test AI OK:", obj);
    setStatus("aiStatus", `Test OK (${model})`, "ok");
    alert("Test AI OKï¼ˆçœ‹ Consoleï¼‰");
  } catch (e) {
    console.error(e);
    setStatus("aiStatus", "Test FAIL", "bad");
    alert("Test AI FAIL: " + (e?.message || e));
  }
}

/* ===========================
   Search -> include + pin + AI update
=========================== */
function normSymbol(input) {
  let s = (input || "").trim().toUpperCase();
  if (!s) return "";
  if (!s.endsWith("USDT")) s = s + "USDT";
  return s;
}

async function searchAndAdd() {
  const raw = $("symSearch")?.value || "";
  const sym = normSymbol(raw);
  if (!sym) return alert("è«‹è¼¸å…¥å¹£ç¨®ï¼Œä¾‹å¦‚ WIF æˆ– WIFUSDT");

  if (isFxCommodity(sym)) return alert("å·²æ’é™¤å¤–åŒ¯ / é»ƒé‡‘ç™½éŠ€é¡ï¼š" + sym);
  if (CONFIG.TOPCAP_EXCLUDE.includes(sym)) return alert("å·²æ’é™¤å¤§å¸‚å€¼å‰25ï¼š" + sym);
  if (CONFIG.EXCLUDE_EXTRA.includes(sym)) return alert("å·²æ’é™¤ç©©å®šå¹£ï¼š" + sym);

  if (hiddenSet.has(sym)) {
    hiddenSet.delete(sym);
    saveHiddenSet();
    updateHiddenBadge();
  }

  try {
    if (!allowedPerpSet) await refreshExchangeInfo();
    if (allowedPerpSet && !allowedPerpSet.has(sym)) {
      return alert("é€™ä¸æ˜¯ USDT æ°¸çºŒåˆç´„æˆ–ä¸å¯äº¤æ˜“ï¼š" + sym);
    }
  } catch {}

  manualIncludeSet.add(sym);

  if (!universe.includes(sym)) universe.push(sym);
  if (!symState[sym]) initSymbolState(sym);
  if (!wsAgg[sym]) initAggTrade(sym);
  if (!liqState[sym]) liqState[sym] = { events:[], shortLiqNotional:0, longLiqNotional:0, netShortLiq:0 };

  pinnedSet.add(sym);
  enforcePinnedLimit();
  updatePinBadge();

  if (!trackedTopN.includes(sym)) trackedTopN.push(sym);
  trackedTopN.sort((a,b) => scoreOf(b) - scoreOf(a));

  while (trackedTopN.length > CONFIG.CANDIDATE_LIMIT) {
    const weak = [...trackedTopN].sort((a,b)=>scoreOf(a)-scoreOf(b)).find(x => !pinnedSet.has(x));
    if (!weak) break;
    trackedTopN = trackedTopN.filter(x => x !== weak);
  }

  await ensureKlinesAndOI(sym);
  await refreshTodayVP(sym);

  const sum = buildSummary(sym);
  if (sum) {
    const placeholder = normalizeAiPick(sym, sum, { score: sum.preScore, confidence: 55, eta_minutes: "30-60", stage: sum.stage });
    aiBySymbol[sym] = placeholder;

    if (!aiTop5.find(x => x.symbol === sym)) aiTop5.unshift(placeholder);
    aiTop5.sort((a,b) => (b.score-a.score) || (b.confidence-a.confidence));

    while (aiTop5.length > CONFIG.TOP5_LIMIT) {
      const weak = [...aiTop5].sort((a,b)=>a.score-b.score).find(x => !pinnedSet.has(x.symbol));
      if (!weak) break;
      aiTop5 = aiTop5.filter(x => x.symbol !== weak.symbol);
    }
    renderTop5Cards();
  }

  try { await runAISingle(sym); } catch {}

  $("symSearch").value = "";
}

/* ===========================
   Render
=========================== */
function renderTop5Cards() {
  $("top5N").textContent = aiTop5.length;
  $("pinnedSym").textContent = pinnedTop1.symbol || "-";

  const wrap = $("cards");
  wrap.innerHTML = "";

  const pinned1 = pinnedTop1.symbol;

  let list = [...aiTop5];
  if (pinned1) {
    const idx = list.findIndex(x => x.symbol === pinned1);
    if (idx > 0) {
      const t = list.splice(idx,1)[0];
      list.unshift(t);
    }
  }

  for (const p of list) {
    const sum = buildSummary(p.symbol);
    const isTop1 = (p.symbol === pinned1);
    const isPinned = pinnedSet.has(p.symbol);

    const tags = (sum?.tags || []).slice(0,6).map(t => `<span class="badge px-2 py-1 rounded-lg tiny2">${t}</span>`).join(" ");
    const stage = sum?.stage || p.stage || "-";

    const tpText = (p.takeProfit || []).slice(0,3).map(tp => `TP ${fmt(tp.price,6)}ï¼ˆ${fmt(tp.pct,0)}%ï¼‰`).join(" / ");
    const reasons = (p.reasons||[]).slice(0,5).map(x=>`â€¢ ${x}`).join("\n") || "â€¢ -";
    const risks = (p.risks||[]).slice(0,4).map(x=>`â€¢ ${x}`).join("\n") || "â€¢ -";
    const entryZone = p.entry?.zone ? `${fmt(p.entry.zone[0],6)} ~ ${fmt(p.entry.zone[1],6)}` : "-";

    const vp = sum?.today_vp;
    const vpLine = vp ? `POC:${fmt(vp.poc,6)} VA:${fmt(vp.val,6)}~${fmt(vp.vah,6)} Î”POC:${fmt(vp.price_vs_poc_pct,2)}%` : "-";
    const vpNodes = vp?.top_nodes ? vp.top_nodes.map(n=>`${fmt(n.price,6)}(${fmt(n.vol_pct,1)}%)`).join(" / ") : "-";

    const warmMin = sum?.warmup_minutes ?? "-";

    const btcLine = `BTC(5m):${fmt(sum?.btc_ret5m_pct,2)}% | ç›¸å°(5m):${fmt(sum?.rel5m_vs_btc,2)}%`;
    const liqLine = `ç©ºå¹³-å¤šå¹³(5m): ${fmt(sum?.liq_net_short_5m,0)} | ç©ºå¹³:${fmt(sum?.liq_short_notional_5m,0)} / å¤šå¹³:${fmt(sum?.liq_long_notional_5m,0)}`;

    const card = document.createElement("div");
    card.className = `card p-4 ${isTop1 ? "card-top1" : ""}`;

    card.innerHTML = `
      <div class="grid grid-cols-1 xl:grid-cols-2 gap-4">
        <div>
          <div class="flex items-start justify-between gap-3">
            <div>
              <div class="flex items-center gap-2">
                <div class="text-white font-black text-xl">${p.symbol}</div>
                <button class="btn tiny ${isPinned ? "btn-pin-on" : "btn-pin"}" onclick="togglePin('${p.symbol}')">
                  ${isPinned ? "ğŸ“Œ é‡˜é¸ä¸­" : "ğŸ“Œ é‡˜é¸"}
                </button>
                <button class="btn tiny btn-red" onclick="hideSymbol('${p.symbol}')">ğŸ—‘ ä¸çœ‹</button>
              </div>
              <div class="tiny muted mt-1">
                åƒ¹æ ¼: <b class="text-zinc-200">${fmt(sum?.price, 6)}</b>
                <span class="mx-2 muted">|</span>
                5mæ¼²è·Œ: <b class="${(sum?.ret5m_pct||0)>=0 ? "ok":"bad"}">${fmt(sum?.ret5m_pct,2)}%</b>
                <span class="mx-2 muted">|</span>
                å‰ç«¯åˆ†: <b>${fmt(sum?.preScore,0)}</b>
                <span class="mx-2 muted">|</span>
                ç†±æ©Ÿ: <b>${warmMin}m</b>
                <span class="mx-2 muted">|</span>
                K: <b>${sum?.kline_interval || "-"}</b>
              </div>
              <div class="tiny mt-2 ${stageClass(stage)} font-bold">éšæ®µï¼š${stage}</div>
              <div class="tiny mt-2 muted">${btcLine}</div>
              <div class="tiny mt-1 muted">${liqLine}</div>
            </div>
          </div>

          <div class="mt-3 flex flex-wrap gap-2">${tags || `<span class="muted tiny">tags: -</span>`}</div>

          <div class="mt-3 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
            <div class="kv tiny">é‡èƒ½Z(5m): <b>${fmt(sum?.volZ_5m,2)}</b></div>
            <div class="kv tiny">ä¸»å‹•è²·å·®é¡(5m): <b>${fmt(sum?.active_buy_delta_5m_notional,0)}</b></div>
            <div class="kv tiny">è²·å…¥æ¯”(5m): <b>${fmt(sum?.buy_ratio_5m,3)}</b></div>

            <div class="kv tiny">OIÎ”(5m): <b>${fmt(sum?.oi_delta_5m,2)}</b></div>
            <div class="kv tiny">OIÎ”(4h): <b>${fmt(sum?.oi_delta_4h,2)}</b></div>
            <div class="kv tiny">è³‡é‡‘è²»ç‡(%): <b>${fmt(sum?.funding_pct,3)}</b> / premium(%): <b>${fmt(sum?.premium_pct,3)}</b></div>

            <div class="kv tiny">ATR14(5K): <b>${fmt(sum?.atr14,6)}</b></div>
            <div class="kv tiny">SwingLow(çª—å£): <b>${fmt(sum?.swing_low_20,6)}</b></div>
            <div class="kv tiny">SwingHigh(çª—å£): <b>${fmt(sum?.swing_high_20,6)}</b></div>

            <div class="kv tiny">Range(%): <b>${fmt(sum?.range_20_pct,2)}</b></div>
            <div class="kv tiny">distSMA20/ATR: <b>${fmt(sum?.dist_sma20_atr,2)}</b></div>
            <div class="kv tiny">ä»Šæ—¥æˆäº¤åˆ†å¸ƒ: <b>${vpLine}</b></div>
            <div class="kv tiny">VPç¯€é»: <b>${vpNodes}</b></div>
          </div>
        </div>

        <div class="ai-box">
          <div class="flex items-center justify-between gap-2">
            <div class="text-white font-bold">AI å»ºè­°ï¼ˆä¸­æ–‡ï¼‰</div>
            <div class="flex items-center gap-2">
              <button class="btn tiny btn-blue" onclick="runAISingle('${p.symbol}')">ğŸ¤– AIæ›´æ–°</button>
              <div class="tiny muted">æ¨¡å‹ï¼š${$("modelSel").value}</div>
            </div>
          </div>

          <div class="mt-2 tiny">
            æ–¹å‘ï¼š<b class="ok">åšå¤š</b>
            <span class="mx-2 muted">|</span>
            åˆ†æ•¸ï¼š<b>${fmt(p.score,0)}</b>
            <span class="mx-2 muted">|</span>
            ä¿¡å¿ƒï¼š<b>${fmt(p.confidence,0)}/100</b>
          </div>

          <div class="mt-1 tiny">
            ETAï¼š<b>${p.eta_minutes || "-"}</b>
            <span class="mx-2 muted">|</span>
            éšæ®µï¼š<b class="${stageClass(p.stage)}">${p.stage || "-"}</b>
          </div>

          <div class="hr my-2"></div>

          <div class="tiny"><b>é€²å ´</b>ï¼š${p.entry?.type || "-"} | å€é–“ï¼š<b>${entryZone}</b></div>
          <div class="tiny muted">è§¸ç™¼ï¼š${p.entry?.trigger || "-"}</div>

          <div class="mt-1 tiny"><b>åœæ</b>ï¼š<b class="bad">${fmt(p.stop?.price,6)}</b></div>
          <div class="tiny muted">å¤±æ•ˆï¼š${p.invalidation || "-"}</div>

          <div class="mt-1 tiny"><b>æ­¢ç›ˆ</b>ï¼š${tpText || "-"}</div>

          <div class="hr my-2"></div>
          <div class="tiny"><b>ç†ç”±</b>ï¼š</div>
          <pre class="tiny2 whitespace-pre-wrap muted">${reasons}</pre>
          <div class="tiny"><b>é¢¨éšª</b>ï¼š</div>
          <pre class="tiny2 whitespace-pre-wrap muted">${risks}</pre>

          <div class="tiny muted mt-2">æ›´æ–°ï¼š${nowStr()}</div>
        </div>
      </div>
    `;
    wrap.appendChild(card);
  }
}

/* ===========================
   miniTicker
=========================== */
function startMiniTicker() {
  const ws = new WebSocket("wss://fstream.binance.com/ws/!miniTicker@arr");
  wsMini = ws;

  ws.onopen = () => {
    $("hb").classList.add("hb-on");
    setStatus("binStatus","WS OK","ok");
  };
  ws.onerror = () => setStatus("binStatus","WS error","warn");
  ws.onclose = () => {
    setStatus("binStatus","WS closed","warn");
    setTimeout(() => startMiniTicker(), 1200);
  };
  ws.onmessage = () => { $("lastTick").textContent = nowStr(); };
}

/* ===========================
   âœ… Prewarm queue (ä¿®å¾© Top10 å¡æ­»æ ¸å¿ƒ)
=========================== */
let prewarmIdx = 0;
async function prewarmTick() {
  if (!CONFIG.PREWARM.enable) return;
  if (!universe.length) return;

  // æ¯æ¬¡æœ€å¤šæŠ“ 1 å€‹ï¼Œé¿å…é™æµ
  for (let i=0; i<CONFIG.PREWARM.maxPerTick; i++) {
    const sym = universe[prewarmIdx % universe.length];
    prewarmIdx++;
    const s = symState[sym];
    if (!s) continue;
    // å„ªå…ˆæŠŠ klinesReady å¡«æ»¿
    if (!s.klinesReady) {
      await ensureKlinesAndOI(sym);
      break;
    }
  }
}

/* ===========================
   Main
=========================== */
async function boot() {
  loadKey();
  $("autoLbl").textContent = `Auto AI: ${AUTO_AI ? "ON" : "OFF"}`;
  updatePinBadge();
  updateHiddenBadge();

  setTimeout(() => {
    const inp = $("symSearch");
    if (inp) inp.addEventListener("keypress", (e) => { if (e.key === "Enter") searchAndAdd(); });
  }, 0);

  setStatus("binStatus","åˆå§‹åŒ–â€¦","warn");
  setStatus("liqStatus","åˆå§‹åŒ–â€¦","warn");
  setStatus("btcStatus","åˆå§‹åŒ–â€¦","warn");
  setStatus("aiStatus","-","muted");
  setStatus("vpStatus","-","muted");

  startMiniTicker();
  startBTCFeed();
  startLiquidationFeed();

  await refreshExchangeInfo().catch(()=>{});
  await refreshPremiumAll().catch(()=>{});
  await refreshUniverse().catch(e => console.error(e));

  // å…ˆæŠ“ä¸€æ¬¡ BTC 2h
  await refreshBTC2h();

  setInterval(() => refreshPremiumAll().catch(()=>{}), 60*1000);
  setInterval(() => refreshUniverse().catch(()=>{}), CONFIG.UNIVERSE_REFRESH_MS);

  // âœ… è®“ klinesReady å…ˆã€Œè‡ªå‹•é ç†±ã€èµ·ä¾†
  setInterval(() => prewarmTick().catch(()=>{}), CONFIG.PREWARM.tickMs);

  setInterval(() => {
    buildTrackedTopN();
    if (aiTop5.length) renderTop5Cards();
  }, CONFIG.CANDIDATE_REFRESH_MS);

  // é€±æœŸæ›´æ–°ï¼šOI/klinesï¼ˆå€™é¸ï¼‰+ VP
  setInterval(() => {
    for (const sym of candidatesTopN) ensureKlinesAndOI(sym);
  }, 60*1000);

  setInterval(() => {
    for (const sym of candidatesTopN) refreshTodayVP(sym);
  }, CONFIG.VP_REFRESH_MS);

  // BTC 2hé€±æœŸæ›´æ–°
  setInterval(() => refreshBTC2h(), 60*1000);

  setInterval(() => runAIOnce(false), 1500);
  setTimeout(() => runAIOnce(true), 12000);
}

boot();
</script>
</body>
</html>
