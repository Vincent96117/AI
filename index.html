<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>âš¡ TRIDENT V7 â€” Anomaly â†’ Top5 â†’ Groq AI (Long-only)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    body { background:#050505; color:#d4d4d8; font-family:'JetBrains Mono', monospace; overflow-x:hidden; }
    .panel { background:#0b0b0d; border:1px solid #1f1f23; border-radius:14px; }
    .card { background:#0f0f11; border:1px solid #1f1f23; border-radius:14px; }
    .card-strong { border:2px solid #22c55e !important; box-shadow: 0 0 18px rgba(34,197,94,0.18); }
    .muted { color:#8b8b93; }
    .kv { background:#0b0b0d; border:1px solid #1f1f23; border-radius:10px; padding:10px; }
    .btn { border:1px solid #2a2a2f; background:#101014; border-radius:10px; padding:8px 10px; font-weight:800; font-size:12px; }
    .btn:hover { filter:brightness(1.12); }
    .btn-blue { background:#0b3a78; border-color:#2e7df0; color:#e8f1ff; }
    .btn-green { background:#0b5a3c; border-color:#22c55e; color:#eafff4; }
    .btn-amber { background:#6a3d00; border-color:#f59e0b; color:#fff7e6; }
    .btn-red { background:#5a0b0b; border-color:#ef4444; color:#ffecec; }

    .badge { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; font-size:11px; font-weight:900; border:1px solid #2a2a2f; }
    .b-setup { background:rgba(245,158,11,0.12); border-color:rgba(245,158,11,0.35); color:#ffd18a;}
    .b-ignite{ background:rgba(249,115,22,0.12); border-color:rgba(249,115,22,0.35); color:#ffbc8a;}
    .b-confirm{ background:rgba(34,197,94,0.12); border-color:rgba(34,197,94,0.35); color:#b7ffd3;}
    .b-risk { background:rgba(239,68,68,0.12); border-color:rgba(239,68,68,0.35); color:#ffb7b7;}
    .b-warm { background:rgba(148,163,184,0.10); border-color:rgba(148,163,184,0.25); color:#d7e1f0;}

    .hb { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .hb-on { background:#22c55e; box-shadow:0 0 12px #22c55e; }
    .hb-off { background:#6b7280; }
    .hb-ai { background:#60a5fa; box-shadow:0 0 12px rgba(96,165,250,0.7); }

    .grid-m { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:10px; }
    @media (max-width: 1100px){ .grid-m{ grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    @media (max-width: 760px){ .grid-m{ grid-template-columns: repeat(1, minmax(0, 1fr)); } }

    .ai-box { background:#09090b; border:1px solid #1f1f23; border-radius:12px; padding:12px; min-height:220px; }
    .ai-title { font-weight:1000; color:#fff; }
    .ai-line { font-size:12px; line-height:1.5; margin-top:6px; }
    .ai-warn { color:#ffb7b7; font-weight:900; }
    .ai-ok { color:#b7ffd3; font-weight:900; }

    .chart-box { height:0; opacity:0; overflow:hidden; transition:all .25s ease; border-top:0px solid transparent; }
    .chart-box.active { height:300px; opacity:1; border-top:1px solid #2a2a2f; margin-top:10px; }
  </style>
</head>

<body class="p-4 h-screen flex flex-col gap-3">

  <!-- Top Bar -->
  <div class="panel p-3 flex flex-col gap-3">
    <div class="flex items-start justify-between gap-3 flex-wrap">
      <div class="flex items-center gap-3">
        <span id="hb" class="hb hb-off"></span>
        <div>
          <div class="text-white text-xl font-black italic leading-none">
            TRIDENT <span class="text-emerald-400">V7</span>
          </div>
          <div class="text-[10px] muted font-bold tracking-widest uppercase">
            Long-only â€¢ Anomaly-first â€¢ Top5 stabilized â€¢ Groq AI
          </div>
        </div>
      </div>

      <div class="flex items-center gap-2 flex-wrap">
        <input id="apiKey" type="password" placeholder="è¼¸å…¥ Groq API Keyï¼ˆåªå­˜åœ¨ä½ ç€è¦½å™¨ï¼‰"
               class="bg-zinc-900 border border-zinc-700 text-[12px] px-3 py-2 rounded text-white outline-none w-[320px] max-w-full" />
        <button class="btn btn-green" id="btnSaveKey">Save</button>
        <button class="btn" id="btnClearKey">Clear</button>

        <select id="modelSel" class="bg-zinc-900 border border-zinc-700 text-[12px] px-2 py-2 rounded text-white outline-none">
          <option value="openai/gpt-oss-20b">openai/gpt-oss-20bï¼ˆJSON schema åš´æ ¼ï¼‰</option>
          <option value="openai/gpt-oss-120b">openai/gpt-oss-120bï¼ˆJSON schema åš´æ ¼ï¼‰</option>
          <option value="llama-3.3-70b-versatile">llama-3.3-70b-versatileï¼ˆJSON objectï¼‰</option>
        </select>

        <button class="btn btn-green" id="btnTestAI">Test AI</button>
        <button class="btn btn-blue" id="btnAnalyzeTop">Analyze Topï¼ˆAIï¼‰</button>

        <label class="text-[12px] font-black flex items-center gap-2 select-none">
          <input id="autoAI" type="checkbox" class="scale-110" checked />
          AutoAI(2m)
        </label>

        <button class="btn btn-red" id="btnReset">RESET</button>
      </div>
    </div>

    <div class="flex items-center justify-between gap-2 flex-wrap">
      <div class="text-[12px]">
        <span class="muted">ç‹€æ…‹ï¼š</span>
        <span id="statusTxt" class="font-black">åˆå§‹åŒ–â€¦</span>
        <span class="muted">ï½œUniverseï¼š</span><span id="uCnt" class="font-black">0</span>
        <span class="muted">ï½œDeepï¼š</span><span id="dCnt" class="font-black">0</span>
        <span class="muted">ï½œTop5ï¼š</span><span id="tCnt" class="font-black">0</span>
        <span class="muted">ï½œChampionï¼š</span><span id="champTxt" class="font-black">-</span>
      </div>
      <div class="text-[11px] muted">
        æ¬Šé‡ï¼ˆLong-onlyï¼‰ï¼šæ³¢å‹•0.22ï½œOI0.25ï½œä¸»å‹•è²·å…¥0.28ï½œé‡èƒ½0.15ï½œå½¢æ…‹0.10ï½œè¿½åƒ¹æ‡²ç½°ï¼ˆå‹•æ…‹ï¼‰
      </div>
    </div>
  </div>

  <!-- Top5 Container -->
  <div class="panel p-3 flex-1 overflow-y-auto">
    <div class="flex items-center justify-between mb-2">
      <div class="text-white font-black text-lg">Top 5 å€™é¸ï¼ˆæœ€å¼·é–å®šç½®é ‚ï¼‰</div>
      <div class="text-[12px] muted">æ›´æ–°ï¼š<span id="updTime">-</span></div>
    </div>
    <div id="cards" class="flex flex-col gap-3"></div>
  </div>

<script>
/* =========================
   CONFIG
========================= */

const BINANCE_REST = "https://fapi.binance.com";
const BINANCE_WS_BASE = "wss://fstream.binance.com/ws";

const GROQ_ENDPOINT = "https://api.groq.com/openai/v1/chat/completions";

// ä½ è¦æ’é™¤ã€Œå¸‚å€¼å‰ 25ã€ï¼šå‰ç«¯ç„¡æ³•å¯é å³æ™‚æŠ“å¸‚å€¼æ’è¡Œï¼Œæ‰€ä»¥é€™è£¡ç”¨å¯ç·¨è¼¯éœæ…‹æ¸…å–®ã€‚
// ä½ è¦ºå¾—å°‘/å¤šï¼Œè‡ªå·±åŠ æ¸›ï¼ˆè¦ 100% è·Ÿå¸‚å€¼æ’è¡Œä¸€è‡´ï¼Œå°±å¿…é ˆä¸² CoinGecko/CMCï¼‰ã€‚
const EXCLUDE_TOP_MCAP_25 = new Set([
  "BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TRXUSDT","AVAXUSDT","LINKUSDT",
  "DOTUSDT","MATICUSDT","POLUSDT","LTCUSDT","BCHUSDT","ATOMUSDT","XLMUSDT","SHIBUSDT","UNIUSDT","ETCUSDT",
  "ICPUSDT","FILUSDT","APTUSDT","ARBUSDT","OPUSDT"
]);

// å…¶å®ƒæ’é™¤ï¼šä½ ä¸æƒ³çœ‹çš„æˆ–å¤ªç‰¹æ®Šçš„
const EXCLUDE_EXTRA = new Set([
  "BTCUSDT","ETHUSDT","BNXUSDT"
]);

const MIN_QUOTE_VOL_24H = 8_000_000;     // éæ¿¾æ­»é­šï¼ˆ24h quoteVolumeï¼‰
const UNIVERSE_SIZE = 80;                // å…ˆå¾ 24h é‡èƒ½æŒ‘å‡ºå‰ N å€‹ï¼ˆå†æ’é™¤ topcapï¼‰
const DEEP_SIZE = 30;                    // æ·±åº¦æŠ“è³‡æ–™çš„æ•¸é‡ï¼ˆé¿å… API æ‰“çˆ†ï¼‰
const TOP_SIZE = 5;

const DEEP_REFRESH_MS = 20_000;          // æ·±åº¦è¼ªè©¢
const FAST_REFRESH_MS = 30_000;          // 24h ticker æ›´æ–°
const TOP_WS_ROLLING_MS = 5 * 60 * 1000; // WS è¨ˆç®— 5 åˆ†é˜ rolling
const AUTO_AI_COOLDOWN_MS = 120_000;     // Auto AI æœ€å°é–“éš” 2 åˆ†é˜
const AI_MAX_TOKENS = 420;               // æ§åˆ¶è¼¸å‡ºé•·åº¦ï¼ˆGroq ç”¨ max_completion_tokensï¼‰:contentReference[oaicite:1]{index=1}

const HYSTERESIS_RATIO = 1.10;           // æ–°ç‹è‡³å°‘æ¯”èˆŠç‹å¼· 10% æ‰æ›ï¼ˆé¿å…æ¦œä¸€ç›´è·³ï¼‰

/* =========================
   STATE
========================= */

const S = {
  apiKey: "",
  model: "openai/gpt-oss-20b",
  autoAI: true,

  lastFastAt: 0,
  lastDeepAt: 0,
  lastAutoAiAt: 0,
  backoffUntil: 0,

  universe: [],
  deepList: [],

  // symbol -> object
  data: new Map(),

  // Top5 + champion lock
  top: [],
  champion: { symbol: null, score: -Infinity },

  // WS per symbol (top5 only)
  ws: new Map(),
};

function nowTs(){ return Date.now(); }
function fmtTime(ts){
  const d = new Date(ts);
  return d.toLocaleTimeString('zh-TW', { hour12:false });
}

function setHB(mode){
  const hb = document.getElementById("hb");
  hb.classList.remove("hb-on","hb-off","hb-ai");
  if(mode==="on") hb.classList.add("hb-on");
  else if(mode==="ai") hb.classList.add("hb-ai");
  else hb.classList.add("hb-off");
}

function setStatus(t){
  document.getElementById("statusTxt").innerText = t;
}

function updateHeaderCounts(){
  document.getElementById("uCnt").innerText = S.universe.length;
  document.getElementById("dCnt").innerText = S.deepList.length;
  document.getElementById("tCnt").innerText = S.top.length;
  document.getElementById("champTxt").innerText = S.champion.symbol ? `${S.champion.symbol} (${S.champion.score.toFixed(2)})` : "-";
}

/* =========================
   SAFE FETCH
========================= */

async function fetchJson(url, opts = {}, timeoutMs = 10_000){
  const ctrl = new AbortController();
  const t = setTimeout(()=>ctrl.abort(), timeoutMs);
  try{
    const res = await fetch(url, { ...opts, signal: ctrl.signal });
    const txt = await res.text();
    let js = null;
    try { js = txt ? JSON.parse(txt) : null; } catch(e){}
    if(!res.ok){
      const err = new Error(`HTTP ${res.status}`);
      err.status = res.status;
      err.body = js ?? txt;
      throw err;
    }
    return js;
  } finally {
    clearTimeout(t);
  }
}

/* =========================
   BINANCE DATA
========================= */

async function getTickers24h(){
  return await fetchJson(`${BINANCE_REST}/fapi/v1/ticker/24hr`);
}

async function getKlines1m(symbol, limit=240){
  return await fetchJson(`${BINANCE_REST}/fapi/v1/klines?symbol=${symbol}&interval=1m&limit=${limit}`);
}

async function getPremiumIndex(symbol){
  return await fetchJson(`${BINANCE_REST}/fapi/v1/premiumIndex?symbol=${symbol}`);
}

async function getOpenInterestHist(symbol, period, limit=2){
  // period: 5m, 4h
  return await fetchJson(`${BINANCE_REST}/futures/data/openInterestHist?symbol=${symbol}&period=${period}&limit=${limit}`);
}

async function getTakerRatio(symbol, period, limit=2){
  // period: 5m, 4h
  return await fetchJson(`${BINANCE_REST}/futures/data/takerlongshortRatio?symbol=${symbol}&period=${period}&limit=${limit}`);
}

/* =========================
   MATH HELPERS
========================= */

function mean(arr){ return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }
function std(arr){
  if(arr.length < 2) return 0;
  const m = mean(arr);
  const v = mean(arr.map(x=>(x-m)*(x-m)));
  return Math.sqrt(v);
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function ema(prev, cur, alpha){
  if(prev==null || !isFinite(prev)) return cur;
  return prev*(1-alpha) + cur*alpha;
}
function pct(a,b){
  // (b-a)/a
  if(!isFinite(a) || a===0) return 0;
  return (b-a)/a;
}

/* =========================
   FEATURE EXTRACTION (1m klines)
========================= */

function extractFromKlines(kl){
  // kline: [ openTime, open, high, low, close, volume, closeTime, quoteVolume, trades, takerBuyBaseVol, takerBuyQuoteVol, ignore]
  const closes = kl.map(k=>+k[4]);
  const highs  = kl.map(k=>+k[2]);
  const lows   = kl.map(k=>+k[3]);
  const qvol   = kl.map(k=>+k[7]); // quote volume
  const last = closes[closes.length-1];

  // returns (log-ish)
  const rets = [];
  for(let i=1;i<closes.length;i++){
    rets.push(Math.log(closes[i]/closes[i-1]));
  }

  const baseVol = std(rets.slice(0, rets.length-5)); // ~4h baseline
  const vol5 = std(rets.slice(rets.length-5));
  const volAnom = baseVol>0 ? (vol5/baseVol) : 0;

  const ret5m = pct(closes[closes.length-6], last) * 100;

  // SMA20 + ATR14
  const sma20 = mean(closes.slice(-20));
  const tr = [];
  for(let i=1;i<closes.length;i++){
    const h = highs[i], l = lows[i], pc = closes[i-1];
    tr.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc)));
  }
  const atr14 = mean(tr.slice(-14));
  const distSmaAtr = atr14>0 ? (last - sma20)/atr14 : 0; // >0 above SMA20

  // volume anomaly (5m vs baseline 4h avg 5m block)
  const last5Q = qvol.slice(-5).reduce((a,b)=>a+b,0);
  const blocks = [];
  for(let i=0;i<qvol.length-5;i+=5){
    blocks.push(qvol.slice(i,i+5).reduce((a,b)=>a+b,0));
  }
  const bMean = mean(blocks);
  const bStd = std(blocks);
  const volZ = bStd>0 ? (last5Q - bMean)/bStd : 0;

  // simple pattern tags
  const tag = [];
  const hh20 = Math.max(...highs.slice(-20));
  const ll20 = Math.min(...lows.slice(-20));
  const rangePct = (hh20-ll20)/last*100;

  if(last > hh20*0.9995) tag.push("çªç ´è¿‘20æ ¹é«˜é»");
  if(rangePct < 0.8) tag.push("çª„å¹…æ”¶æ–‚");
  if(ret5m > 0 && distSmaAtr < 1.2 && volZ > 1.2) tag.push("é‡å¢ç·©æ¼²");
  if(ret5m > 0.9) tag.push("çŸ­ç·šå·²æ€¥æ‹‰");
  if(distSmaAtr > 2.0) tag.push("åé›¢å‡ç·šåå¤§");

  return { last, volAnom, ret5m, distSmaAtr, volZ, tags: tag };
}

/* =========================
   STAGE + SCORE (Long-only)
========================= */

function stageAndScore(m){
  // m: merged metrics
  // Key: want early but anti-chase
  const warm = m.warmup !== "ok";
  if(warm){
    return { stage:"ç†±æ©Ÿä¸­", badge:"b-warm", score:0, why:"è³‡æ–™ç†±æ©Ÿä¸è¶³ï¼ˆç­‰ 1~2 åˆ†é˜æœƒå¥½å¾ˆå¤šï¼‰" };
  }

  // chase penalty
  let chase = 0;
  if(m.ret5m > 0.9) chase += (m.ret5m-0.9)*12;
  if(m.distSmaAtr > 2.0) chase += (m.distSmaAtr-2.0)*18;

  // bullish ingredients
  const volPart = clamp((m.volAnom - 1.0) * 18, -10, 60);     // volatility anomaly
  const oiPart  = clamp(m.oiZ * 16, -20, 60);
  const flowPart= clamp(m.flowZ * 18, -25, 70);
  const vPart   = clamp(m.volZ * 10, -15, 40);
  const patPart = (m.tags.includes("çªç ´è¿‘20æ ¹é«˜é»") ? 16 : 0) + (m.tags.includes("çª„å¹…æ”¶æ–‚") ? 10 : 0) + (m.tags.includes("é‡å¢ç·©æ¼²") ? 10 : 0);

  let score = 0.22*volPart + 0.25*oiPart + 0.28*flowPart + 0.15*vPart + 0.10*patPart;
  score -= chase;

  // stage logic
  let stage = "è“„å‹¢", badge = "b-setup", why = [];
  if(score < 6){ stage="è§€æœ›"; badge="b-warm"; why.push("ç¶œåˆå„ªå‹¢ä¸è¶³"); }
  else {
    // Setup
    if(m.volAnom > 1.25) why.push("æ³¢å‹•ç‡ä¸Šå‡ï¼ˆç•°å¸¸ï¼‰");
    if(m.oiZ > 0.8) why.push("OI æŠ¬å‡ï¼ˆåå¤šï¼‰");
    if(m.flowZ > 0.8) why.push("ä¸»å‹•è²·å…¥å¢å¼·");
    if(m.volZ > 1.0) why.push("é‡èƒ½æ”¾å¤§");
    if(m.tags.includes("çª„å¹…æ”¶æ–‚")) why.push("æ”¶æ–‚æ•´ç†");
    if(m.tags.includes("çªç ´è¿‘20æ ¹é«˜é»")) why.push("çªç ´è¨Šè™Ÿ");

    // Ignite
    if(m.flowZ > 1.2 && m.oiZ > 0.9 && m.ret5m > -0.2 && m.volZ > 0.8){
      stage = "é»ç«"; badge="b-ignite";
    }
    // Confirm
    if(m.tags.includes("çªç ´è¿‘20æ ¹é«˜é»") && m.flowZ > 1.2 && m.volZ > 1.2 && m.ret5m > 0.15 && m.ret5m < 0.9){
      stage = "è§¸ç™¼"; badge="b-confirm";
    }

    // Risk / anti-chase
    if(chase > 10){
      stage = "è¿½åƒ¹é¢¨éšª"; badge="b-risk";
      why.push("çŸ­ç·šå·²æ‹‰é«˜ / åé›¢å‡ç·šå¤ªå¤šï¼ˆä¸è¿½ï¼‰");
    }
  }

  score = clamp(score, -50, 100);

  return { stage, badge, score, why: why.join("ã€") || "-" };
}

/* =========================
   WS (Top5 only) for 5m Active Buy Delta
========================= */

function ensureWsFor(symbol){
  if(S.ws.has(symbol)) return;
  const url = `${BINANCE_WS_BASE}/${symbol.toLowerCase()}@aggTrade`;
  const ws = new WebSocket(url);

  const bucket = {
    ws,
    trades: [], // {t, buyNotional, sellNotional}
    buy5m: 0,
    sell5m: 0
  };

  ws.onopen = ()=>{};
  ws.onerror = ()=>{};
  ws.onclose = ()=>{ S.ws.delete(symbol); };

  ws.onmessage = (e)=>{
    const d = JSON.parse(e.data);
    const t = d.T || nowTs();
    const price = +d.p;
    const qty = +d.q;
    const notional = price * qty;

    // m=true => buyer is maker => taker sell
    const isTakerBuy = !d.m;
    const buyN = isTakerBuy ? notional : 0;
    const sellN= isTakerBuy ? 0 : notional;

    bucket.trades.push({ t, buyN, sellN });
    bucket.buy5m += buyN;
    bucket.sell5m += sellN;

    // purge older than 5m
    const cut = nowTs() - TOP_WS_ROLLING_MS;
    while(bucket.trades.length && bucket.trades[0].t < cut){
      const x = bucket.trades.shift();
      bucket.buy5m -= x.buyN;
      bucket.sell5m-= x.sellN;
    }

    const obj = S.data.get(symbol);
    if(obj){
      obj.buy5m = bucket.buy5m;
      obj.sell5m= bucket.sell5m;
      const denom = (bucket.buy5m + bucket.sell5m);
      obj.imb5m = denom>0 ? (bucket.buy5m - bucket.sell5m)/denom : null; // -1..1
      obj.delta5m = bucket.buy5m - bucket.sell5m; // notional
      obj.lastTickTs = nowTs();
    }
  };

  S.ws.set(symbol, bucket);
}

function trimWsToTop5(){
  const keep = new Set(S.top.map(x=>x.symbol));
  for(const [sym, b] of S.ws.entries()){
    if(!keep.has(sym)){
      try{ b.ws.close(); }catch(e){}
      S.ws.delete(sym);
    }
  }
  // ensure ws for each top
  for(const sym of keep) ensureWsFor(sym);
}

/* =========================
   SCAN PIPELINE
========================= */

async function fastScan(){
  S.lastFastAt = nowTs();
  setStatus("Fast scanï¼šæ›´æ–° 24h tickerâ€¦");
  const tickers = await getTickers24h();

  const list = tickers
    .filter(x => x.symbol && x.symbol.endsWith("USDT"))
    .filter(x => !EXCLUDE_TOP_MCAP_25.has(x.symbol))
    .filter(x => !EXCLUDE_EXTRA.has(x.symbol))
    .filter(x => +x.quoteVolume >= MIN_QUOTE_VOL_24H);

  // å…ˆç”¨é‡èƒ½æ’åºï¼Œå– Universe
  list.sort((a,b)=> (+b.quoteVolume) - (+a.quoteVolume));
  S.universe = list.slice(0, UNIVERSE_SIZE).map(x=>({
    symbol: x.symbol,
    lastPrice: +x.lastPrice,
    quoteVolume: +x.quoteVolume,
    priceChangePercent: +x.priceChangePercent
  }));

  // deepListï¼šå¾ universe æŒ‘ä¸€æ‰¹ï¼ˆé¿å…å…¨æ‰“ï¼‰
  // é€™è£¡åå‘ã€Œä¸è¦å·²ç¶“å¤§å™´ã€ï¼š24h æ¼²å¹…éå¤§é™æ¬Š
  const scored = S.universe.map(u=>{
    const chase24 = Math.max(0, (u.priceChangePercent - 12)); // >12% ç•¶è¿½åƒ¹é¢¨éšª
    const s = Math.log10(u.quoteVolume+1) * 10 - chase24*1.2;
    return { ...u, fastScore:s };
  }).sort((a,b)=>b.fastScore-a.fastScore);

  S.deepList = scored.slice(0, DEEP_SIZE).map(x=>x.symbol);
  updateHeaderCounts();

  setStatus("Fast scanï¼šå®Œæˆ");
}

async function deepScan(){
  S.lastDeepAt = nowTs();
  setStatus("Deep scanï¼šæŠ“ Kç·š/OI/ä¸»å‹•è²·å…¥/è³‡è²»â€¦");

  const symbols = [...S.deepList];
  const concurrency = 5;
  let idx = 0;

  async function worker(){
    while(idx < symbols.length){
      const sym = symbols[idx++];
      try{
        await updateSymbolDeep(sym);
      } catch(e){
        // ignore per-symbol
      }
    }
  }

  const jobs = [];
  for(let i=0;i<concurrency;i++) jobs.push(worker());
  await Promise.all(jobs);

  computeTop5();
  trimWsToTop5();
  render();

  setStatus("Deep scanï¼šå®Œæˆ");
}

function warmupState(obj){
  // æˆ‘å€‘è¦çš„è³‡æ–™ï¼šKlines(240) + OI(5m/4h) + taker(4h) + premium
  const need = ["k240","oi5","oi4","tk4","prem"];
  const ok = need.every(k => obj._ok && obj._ok[k]);
  return ok ? "ok" : "warming";
}

async function updateSymbolDeep(symbol){
  const obj = S.data.get(symbol) || {
    symbol,
    lastPrice: null,

    // from klines
    volAnom: null, ret5m: null, distSmaAtr: null, volZ: null, tags: [],

    // OI
    oi5m: null, oi4h: null, oiZ: null,

    // taker ratio
    flow4h: null, flowZ: null,

    // premium / funding
    premiumPct: null, fundingRatePct: null, premZ: null,

    // WS rolling (top5 only)
    delta5m: null, imb5m: null, buy5m: null, sell5m: null,

    // stage
    stage: "ç†±æ©Ÿä¸­", stageWhy:"-", scoreRaw: 0, scoreEma: null,

    // ai
    ai: { ts:0, data:null, text:"å°šæœªåˆ†æï¼šæŒ‰å³ä¸Šã€Geminiã€‘(å·²æ”¹ Groq) æˆ–ã€Analyze Topã€‘", err:null },

    // bookkeeping
    _ok: {}
  };

  // pull in price from universe
  const uni = S.universe.find(x=>x.symbol===symbol);
  if(uni) obj.lastPrice = uni.lastPrice;

  // 1) klines 240
  try{
    const kl = await getKlines1m(symbol, 240);
    const ex = extractFromKlines(kl);
    obj.lastPrice = ex.last;
    obj.volAnom = ex.volAnom;
    obj.ret5m = ex.ret5m;
    obj.distSmaAtr = ex.distSmaAtr;
    obj.volZ = ex.volZ;
    obj.tags = ex.tags;
    obj._ok.k240 = true;
  }catch(e){ obj._ok.k240 = false; }

  // 2) OI 5m / 4h
  try{
    const oi5 = await getOpenInterestHist(symbol, "5m", 2);
    if(oi5 && oi5.length>=2){
      const a = +oi5[0].sumOpenInterest, b=+oi5[1].sumOpenInterest;
      obj.oi5m = (b-a);
      // zï¼šç”¨ç›¸å°è®ŠåŒ–ç²—ä¼°ï¼ˆå‰ç«¯å¾ˆé›£æ‹¿åˆ°å®Œæ•´åˆ†å¸ƒï¼‰
      const base = Math.max(1e-9, Math.abs(a));
      const r = (b-a)/base;
      obj.oi5r = r;
    }
    obj._ok.oi5 = true;
  }catch(e){ obj._ok.oi5 = false; }

  try{
    const oi4 = await getOpenInterestHist(symbol, "4h", 2);
    if(oi4 && oi4.length>=2){
      const a = +oi4[0].sumOpenInterest, b=+oi4[1].sumOpenInterest;
      obj.oi4h = (b-a);
      const base = Math.max(1e-9, Math.abs(a));
      const r = (b-a)/base;
      obj.oi4r = r;
    }
    obj._ok.oi4 = true;
  }catch(e){ obj._ok.oi4 = false; }

  // OI Zï¼šæŠŠ 5m ç›¸å°è®ŠåŒ– èˆ‡ 4h ç›¸å°è®ŠåŒ– åšä¸€å€‹åˆæˆï¼ˆåã€ŒçŸ­æœŸçªç„¶æŠ¬å‡ã€ï¼‰
  if(isFinite(obj.oi5r) && isFinite(obj.oi4r)){
    // ç›´è¦ºï¼šçŸ­æœŸæ¯”é•·æœŸæ›´å¼· => æ­£
    obj.oiZ = clamp((obj.oi5r - 0.25*obj.oi4r) * 420, -3, 4); // scaling
  } else {
    obj.oiZ = null;
  }

  // 3) taker ratio 4hï¼ˆçµ¦ä½ é•·é€±æœŸä¸»å‹•è²·å…¥å·®é¡ï¼‰
  try{
    const tk4 = await getTakerRatio(symbol, "4h", 2);
    if(tk4 && tk4.length>=2){
      const last = tk4[1];
      const buy = +last.buyVol;
      const sell= +last.sellVol;
      obj.flow4h = (buy - sell); // base qty
      // flowZï¼šç”¨ buySellRatio åé›¢ 1 ä¼°ï¼ˆ>1 ä»£è¡¨è²·å¼·ï¼‰
      const r = +last.buySellRatio;
      obj.flowZ = clamp((r - 1.0) * 3.2, -3, 4);
    }
    obj._ok.tk4 = true;
  }catch(e){ obj._ok.tk4 = false; }

  // 4) premium/funding
  try{
    const p = await getPremiumIndex(symbol);
    const mark = +p.markPrice;
    const idxp = +p.indexPrice;
    const prem = (idxp>0) ? (mark-idxp)/idxp*100 : 0;
    obj.premiumPct = prem;
    obj.fundingRatePct = (+p.lastFundingRate)*100;
    // premZï¼šç²—ä¼°ï¼ˆçŸ­ç·šåå¤šæ™‚ prem>0ï¼‰
    obj.premZ = clamp(prem * 4.0, -3, 3);
    obj._ok.prem = true;
  }catch(e){ obj._ok.prem = false; }

  // warmup?
  obj.warmup = warmupState(obj);

  // stage+score (need imb5m/delta5m from WS only for Top5; for othersç”¨ flowZ ä»£æ›¿)
  const flowZ = isFinite(obj.imb5m) ? clamp(obj.imb5m*3.5, -3, 4) : (isFinite(obj.flowZ)?obj.flowZ:0);
  const merged = {
    warmup: obj.warmup,
    volAnom: obj.volAnom ?? 0,
    ret5m: obj.ret5m ?? 0,
    distSmaAtr: obj.distSmaAtr ?? 0,
    volZ: obj.volZ ?? 0,
    tags: obj.tags ?? [],
    oiZ: isFinite(obj.oiZ) ? obj.oiZ : 0,
    flowZ: flowZ,
  };

  const st = stageAndScore(merged);
  obj.stage = st.stage;
  obj.stageWhy = st.why;
  obj.scoreRaw = st.score;
  obj.scoreEma = ema(obj.scoreEma, obj.scoreRaw, 0.22);

  S.data.set(symbol, obj);
}

function computeTop5(){
  // candidate: symbols in deep list with scoreEma
  const arr = [...S.data.values()]
    .filter(x => S.deepList.includes(x.symbol))
    .map(x=>{
      const score = (x.scoreEma ?? x.scoreRaw ?? 0);
      return { symbol:x.symbol, score, stage:x.stage };
    })
    .sort((a,b)=> b.score - a.score);

  const best = arr[0];

  // champion lock
  if(!S.champion.symbol && best){
    S.champion = { symbol: best.symbol, score: best.score };
  } else if(best && best.symbol !== S.champion.symbol){
    if(best.score >= S.champion.score * HYSTERESIS_RATIO){
      S.champion = { symbol: best.symbol, score: best.score };
    }
  } else if(best && best.symbol === S.champion.symbol){
    // keep updated score
    S.champion.score = best.score;
  }

  // Top list: champion first, then next best excluding champion
  const top = [];
  if(S.champion.symbol){
    top.push({ symbol:S.champion.symbol, score:S.champion.score, stage:(S.data.get(S.champion.symbol)?.stage)||"-" });
  }
  for(const x of arr){
    if(top.length>=TOP_SIZE) break;
    if(x.symbol===S.champion.symbol) continue;
    top.push(x);
  }
  S.top = top;
  updateHeaderCounts();
}

/* =========================
   RENDER
========================= */

function stageBadge(stage){
  if(stage==="è“„å‹¢") return ["b-setup","ğŸŸ¨ è“„å‹¢"];
  if(stage==="é»ç«") return ["b-ignite","ğŸŸ§ é»ç«"];
  if(stage==="è§¸ç™¼") return ["b-confirm","ğŸŸ© è§¸ç™¼"];
  if(stage==="è¿½åƒ¹é¢¨éšª") return ["b-risk","â›” è¿½åƒ¹é¢¨éšª"];
  if(stage==="è§€æœ›") return ["b-warm","âšª è§€æœ›"];
  return ["b-warm","â³ ç†±æ©Ÿä¸­"];
}

function num(x, d=2){
  if(x==null || !isFinite(x)) return "-";
  return (+x).toFixed(d);
}

function money(x){
  if(x==null || !isFinite(x)) return "-";
  const a = Math.abs(x);
  if(a>=1e9) return (x/1e9).toFixed(2)+"B";
  if(a>=1e6) return (x/1e6).toFixed(2)+"M";
  if(a>=1e3) return (x/1e3).toFixed(2)+"K";
  return x.toFixed(0);
}

function render(){
  document.getElementById("updTime").innerText = fmtTime(nowTs());
  setHB("on");

  const root = document.getElementById("cards");
  root.innerHTML = "";

  for(let rank=0; rank<S.top.length; rank++){
    const {symbol, score} = S.top[rank];
    const obj = S.data.get(symbol);
    if(!obj) continue;

    const [bClass, bTxt] = stageBadge(obj.stage);
    const isChampion = (symbol === S.champion.symbol);

    const card = document.createElement("div");
    card.className = `card p-3 ${isChampion ? "card-strong" : ""}`;

    const tags = (obj.tags && obj.tags.length) ? obj.tags.join("ã€") : "-";

    const aiText = renderAiReadable(obj);

    card.innerHTML = `
      <div class="flex items-start justify-between gap-2 flex-wrap">
        <div class="flex items-center gap-2">
          <div class="text-white font-black text-lg">${symbol}</div>
          <span class="badge ${bClass}">${bTxt}</span>
          ${isChampion ? `<span class="badge b-confirm">ğŸ† æœ€å¼·é–å®š</span>` : `<span class="badge b-warm">#${rank+1}</span>`}
          <span class="badge b-warm">score ${score.toFixed(2)}</span>
        </div>

        <div class="flex items-center gap-2">
          <button class="btn btn-green" data-ai="${symbol}">AIï¼ˆGroqï¼‰</button>
          <button class="btn" data-tv="${symbol}">VIEW</button>
        </div>
      </div>

      <div class="mt-2 grid grid-cols-1 lg:grid-cols-3 gap-3">
        <!-- Left metrics -->
        <div class="lg:col-span-2">
          <div class="text-[12px] muted mb-2">å‹æ…‹æ¨™ç±¤ï¼š<span class="text-white font-black">${tags}</span></div>

          <div class="grid-m">
            <div class="kv"><div class="muted text-[11px]">æ³¢å‹•ç•°å¸¸æ¯”ï¼ˆ5m/4hï¼‰</div><div class="text-white font-black text-[14px]">${num(obj.volAnom,2)}</div></div>
            <div class="kv"><div class="muted text-[11px]">æˆäº¤é‡ç•°å¸¸Zï¼ˆ5m vs 4hï¼‰</div><div class="text-white font-black text-[14px]">${num(obj.volZ,2)}</div></div>
            <div class="kv"><div class="muted text-[11px]">5åˆ†é˜æ¼²è·Œ</div><div class="text-white font-black text-[14px]">${num(obj.ret5m,2)}%</div></div>

            <div class="kv"><div class="muted text-[11px]">OI è®ŠåŒ–ï¼ˆ5mï¼‰</div><div class="text-white font-black text-[14px]">${money(obj.oi5m)}</div></div>
            <div class="kv"><div class="muted text-[11px]">OI è®ŠåŒ–ï¼ˆ4hï¼‰</div><div class="text-white font-black text-[14px]">${money(obj.oi4h)}</div></div>
            <div class="kv"><div class="muted text-[11px]">OI ç•°å¸¸Zï¼ˆåˆæˆï¼‰</div><div class="text-white font-black text-[14px]">${num(obj.oiZ,2)}</div></div>

            <div class="kv"><div class="muted text-[11px]">ä¸»å‹•è²·å…¥å·®é¡ï¼ˆ5m, WS notionalï¼‰</div><div class="text-white font-black text-[14px]">${obj.delta5m==null? "ï¼ˆTop5 WS è¨ˆç®—ä¸­ï¼‰" : money(obj.delta5m)}</div></div>
            <div class="kv"><div class="muted text-[11px]">ä¸»å‹•è²·å…¥æ¯”ä¾‹ï¼ˆ5m, -1~+1ï¼‰</div><div class="text-white font-black text-[14px]">${obj.imb5m==null? "-" : num(obj.imb5m,3)}</div></div>
            <div class="kv"><div class="muted text-[11px]">ä¸»å‹•è²·å…¥å¼·åº¦Zï¼ˆç”¨ 4h ratio æˆ– WSï¼‰</div><div class="text-white font-black text-[14px]">${num((isFinite(obj.imb5m)? clamp(obj.imb5m*3.5,-3,4) : obj.flowZ),2)}</div></div>

            <div class="kv"><div class="muted text-[11px]">æº¢åƒ¹ premiumï¼ˆ%ï¼‰</div><div class="text-white font-black text-[14px]">${num(obj.premiumPct,3)}%</div></div>
            <div class="kv"><div class="muted text-[11px]">è³‡é‡‘è²»ç‡ fundingï¼ˆ%ï¼‰</div><div class="text-white font-black text-[14px]">${num(obj.fundingRatePct,4)}%</div></div>
            <div class="kv"><div class="muted text-[11px]">åé›¢å‡ç·šï¼ˆä»¥ ATRï¼‰</div><div class="text-white font-black text-[14px]">${num(obj.distSmaAtr,2)}</div></div>
          </div>

          <div class="mt-2 text-[12px]">
            <span class="muted">ç‹€æ…‹è§£é‡‹ï¼š</span>
            <span class="text-white font-black">${obj.stageWhy || "-"}</span>
          </div>

          <div id="chart-${symbol}" class="chart-box"></div>
        </div>

        <!-- Right AI -->
        <div class="ai-box">
          <div class="ai-title">AI åˆ¤è®€ï¼ˆä¸­æ–‡ï¼‰</div>
          <div class="ai-line muted">æ¨¡å‹ï¼š${S.model} ï½œ max_tokensï¼š${AI_MAX_TOKENS}</div>
          <div class="ai-line">${aiText}</div>
        </div>
      </div>
    `;

    root.appendChild(card);

    // bind buttons
    card.querySelector(`[data-ai="${symbol}"]`).onclick = ()=> analyzeOne(symbol, true);
    card.querySelector(`[data-tv="${symbol}"]`).onclick = ()=> toggleTV(symbol);
  }
}

function toggleTV(symbol){
  const el = document.getElementById(`chart-${symbol}`);
  if(!el) return;

  if(el.classList.contains("active")){
    el.classList.remove("active");
    setTimeout(()=>{ el.innerHTML=""; }, 250);
    return;
  }
  el.classList.add("active");
  const cid = `tv-${symbol}-${Math.random().toString(16).slice(2)}`;
  el.innerHTML = `<div id="${cid}" style="width:100%; height:100%;"></div>`;
  new TradingView.widget({
    autosize:true,
    symbol: "BINANCE:" + symbol + "PERP",
    interval: "1",
    theme: "dark",
    style: "1",
    hide_top_toolbar: true,
    hide_legend: true,
    save_image: false,
    container_id: cid
  });
}

/* =========================
   GROQ AI
========================= */

function hasKey(){
  return !!(S.apiKey && S.apiKey.trim().length > 10);
}

function groqSupportsStrict(model){
  return model.startsWith("openai/gpt-oss-");
}

function buildAiPayload(symbol){
  const o = S.data.get(symbol);
  const top = S.top.map(x=>x.symbol);
  const summary = {
    symbol,
    long_only: true,
    stage: o.stage,
    score: Math.round(clamp((o.scoreEma ?? o.scoreRaw ?? 0),0,100)),
    price: o.lastPrice,
    ret5m_pct: o.ret5m,
    vol_anom_ratio: o.volAnom,
    volZ_5m: o.volZ,
    oi5m: o.oi5m,
    oi4h: o.oi4h,
    oiZ: o.oiZ,
    active_delta_5m_notional: o.delta5m,
    active_imbalance_5m: o.imb5m,
    active_flowZ: (isFinite(o.imb5m)? clamp(o.imb5m*3.5,-3,4) : o.flowZ),
    premium_pct: o.premiumPct,
    funding_pct: o.fundingRatePct,
    dist_sma20_atr: o.distSmaAtr,
    tags: o.tags,
    top5: top,
    note: "è«‹ç”¨ç¹é«”ä¸­æ–‡ã€‚è«‹ä¸€å®šè¼¸å‡º JSONï¼Œä¸è¦ä»»ä½•å¤šé¤˜æ–‡å­—ã€‚"
  };

  const schema = {
    type: "object",
    additionalProperties: false,
    properties: {
      symbol: { type:"string" },
      direction: { type:"string", enum:["åšå¤š","è§€æœ›"] },
      score: { type:"integer", minimum:0, maximum:100 },
      confidence: { type:"integer", minimum:0, maximum:100 },
      eta_minutes: { type:"string", description:"ä¾‹å¦‚ 5-15 è¡¨ç¤ºé è¨ˆ 5~15 åˆ†é˜å…§è¡¨æ…‹", pattern:"^\\d{1,3}-\\d{1,3}$" },
      stage: { type:"string", enum:["è“„å‹¢","é»ç«","è§¸ç™¼","è¿½åƒ¹é¢¨éšª","ç†±æ©Ÿä¸­","è§€æœ›"] },

      entry: {
        type:"object",
        additionalProperties:false,
        properties:{
          type:{ type:"string", enum:["å¸‚åƒ¹","é™åƒ¹","åˆ†æ‰¹"] },
          price:{ type:"number" },
          zone:{ type:"string" },
          logic:{ type:"string" }
        },
        required:["type","price","zone","logic"]
      },

      stop: {
        type:"object",
        additionalProperties:false,
        properties:{
          price:{ type:"number" },
          logic:{ type:"string" }
        },
        required:["price","logic"]
      },

      take_profit: {
        type:"array",
        maxItems: 3,
        items:{
          type:"object",
          additionalProperties:false,
          properties:{
            price:{ type:"number" },
            portion:{ type:"number", minimum:0, maximum:1 },
            logic:{ type:"string" }
          },
          required:["price","portion","logic"]
        }
      },

      invalidation: { type:"array", maxItems: 6, items:{ type:"string" } },
      reasons: { type:"array", maxItems: 6, items:{ type:"string" } },
      risk_notes: { type:"array", maxItems: 6, items:{ type:"string" } }
    },
    required:["symbol","direction","score","confidence","eta_minutes","stage","entry","stop","take_profit","invalidation","reasons","risk_notes"]
  };

  const system = [
    "ä½ æ˜¯åˆç´„äº¤æ˜“ç­–ç•¥åˆ†æåŠ©æ‰‹ã€‚",
    "åªåšå¤šï¼ˆlong-onlyï¼‰ï¼šè‹¥ä¸é©åˆåšå¤šï¼Œdirection è«‹å›ã€Œè§€æœ›ã€ã€‚",
    "ä½ è¦é æ¸¬ã€å¹¾åˆ†é˜å…§å¯èƒ½è¡¨æ…‹ã€ï¼Œè¼¸å‡º eta_minutes å€é–“ï¼ˆä¾‹å¦‚ 5-15ï¼‰ã€‚",
    "ä½ å¿…é ˆæä¾›ï¼šåˆ†æ•¸(score 0~100)ã€ä¿¡å¿ƒ(confidence 0~100)ã€éšæ®µ(stage)ã€é€²å ´(entry)ã€åœæ(stop)ã€åˆ†æ‰¹æ­¢ç›ˆ(take_profit)ã€å¤±æ•ˆæ¢ä»¶(invalidation)ã€ç†ç”±(reasons)ã€é¢¨éšªæç¤º(risk_notes)ã€‚",
    "å‹™å¿… anti-chaseï¼šå¦‚æœå·²æ€¥æ‹‰/åé›¢å‡ç·šéå¤§/è¿½åƒ¹é¢¨éšªï¼Œstage=è¿½åƒ¹é¢¨éšªï¼Œdirection=è§€æœ› æˆ– é™ä½ä¿¡å¿ƒã€‚",
    "æ‰€æœ‰æ–‡å­—ç”¨ç¹é«”ä¸­æ–‡ã€‚",
    "åªèƒ½è¼¸å‡º JSONï¼ˆä¸å¾—æœ‰ä»»ä½•å¤šé¤˜æ–‡å­—ï¼‰ã€‚"
  ].join("\n");

  const req = {
    model: S.model,
    messages: [
      { role:"system", content: system },
      { role:"user", content: JSON.stringify(summary) }
    ],
    temperature: 0.2,
    top_p: 0.95,
    max_completion_tokens: AI_MAX_TOKENS
  };

  // Structured Outputs (JSON schema strict) for openai/gpt-oss-* :contentReference[oaicite:2]{index=2}
  if(groqSupportsStrict(S.model)){
    req.response_format = {
      type: "json_schema",
      json_schema: {
        name: "trident_long_signal",
        strict: true,
        schema
      }
    };
  } else {
    // JSON object mode fallback :contentReference[oaicite:3]{index=3}
    req.response_format = { type:"json_object" };
  }

  return req;
}

function tryParseJsonLoose(s){
  if(!s) return null;
  try { return JSON.parse(s); } catch(e){}
  // fallback: extract first {...}
  const a = s.indexOf("{");
  const b = s.lastIndexOf("}");
  if(a>=0 && b>a){
    try { return JSON.parse(s.slice(a,b+1)); } catch(e){}
  }
  return null;
}

async function groqCall(payload){
  if(!hasKey()) throw new Error("NO_KEY");

  const res = await fetch(GROQ_ENDPOINT, {
    method:"POST",
    headers:{
      "Content-Type":"application/json",
      "Authorization": "Bearer " + S.apiKey.trim()
    },
    body: JSON.stringify(payload)
  });

  const txt = await res.text();
  let js = null;
  try{ js = txt ? JSON.parse(txt) : null; }catch(e){}

  if(!res.ok){
    const err = new Error(`HTTP ${res.status}`);
    err.status = res.status;
    err.body = js ?? txt;
    throw err;
  }

  // expected: choices[0].message.content is JSON text (or already JSON in some modes)
  const content = js?.choices?.[0]?.message?.content;
  const parsed = (typeof content === "string") ? tryParseJsonLoose(content) : (content ?? null);
  return { raw: js, content, parsed };
}

function renderAiReadable(o){
  const a = o.ai?.data;
  const err = o.ai?.err;

  if(err){
    return `<span class="ai-warn">AIéŒ¯èª¤ï¼š</span> ${escapeHtml(err)}`;
  }
  if(!a){
    return `<span class="muted">${escapeHtml(o.ai?.text || "å°šæœªåˆ†æ")}</span>`;
  }

  const dir = a.direction || "è§€æœ›";
  const conf = (a.confidence ?? 0);
  const eta = a.eta_minutes || "-";
  const stage = a.stage || "-";
  const score = a.score ?? "-";

  const entry = a.entry || {};
  const stop = a.stop || {};
  const tp = Array.isArray(a.take_profit) ? a.take_profit : [];

  const reasons = Array.isArray(a.reasons) ? a.reasons : [];
  const inv = Array.isArray(a.invalidation) ? a.invalidation : [];
  const risk = Array.isArray(a.risk_notes) ? a.risk_notes : [];

  const dirCls = (dir==="åšå¤š") ? "ai-ok" : "ai-warn";

  return `
    <div><span class="${dirCls}">æ–¹å‘ï¼š</span><b>${escapeHtml(dir)}</b>ã€€<span class="muted">ï½œ</span> åˆ†æ•¸ï¼š<b>${escapeHtml(String(score))}</b>ã€€<span class="muted">ï½œ</span> ä¿¡å¿ƒï¼š<b>${escapeHtml(String(conf))}/100</b></div>
    <div class="ai-line">é è¨ˆè¡¨æ…‹ï¼š<b>${escapeHtml(eta)}</b> åˆ†é˜ã€€<span class="muted">ï½œ</span> éšæ®µï¼š<b>${escapeHtml(stage)}</b></div>

    <hr class="my-2 border-zinc-800"/>

    <div class="ai-line"><b>é€²å ´ï¼š</b>${escapeHtml(entry.type||"-")}ã€€${entry.price? ("@ "+escapeHtml(String(entry.price))) : ""}ã€€<span class="muted">${escapeHtml(entry.zone||"")}</span></div>
    <div class="ai-line"><b>åœæï¼š</b>${stop.price? ("@ "+escapeHtml(String(stop.price))) : "-"}ã€€<span class="muted">${escapeHtml(stop.logic||"")}</span></div>

    <div class="ai-line"><b>æ­¢ç›ˆï¼š</b>${
      tp.length ? tp.map(x=>`@${x.price}ï¼ˆ${Math.round((x.portion||0)*100)}%ï¼‰`).join("ã€") : "-"
    }</div>

    <div class="ai-line"><b>å¤±æ•ˆæ¢ä»¶ï¼š</b>${inv.length ? inv.map(escapeHtml).join("ï¼›") : "-"}</div>

    <div class="ai-line"><b>ç†ç”±ï¼š</b>${reasons.length ? reasons.map(escapeHtml).join("ï¼›") : "-"}</div>

    <div class="ai-line"><b>é¢¨éšªï¼š</b>${risk.length ? risk.map(escapeHtml).join("ï¼›") : "-"}</div>

    <div class="ai-line muted">æ›´æ–°ï¼š${fmtTime(o.ai.ts || nowTs())}</div>
  `;
}

function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

async function analyzeOne(symbol, manual=false){
  const o = S.data.get(symbol);
  if(!o) return;

  if(!hasKey()){
    o.ai.err = "æœªè¼¸å…¥ Groq API Keyï¼ˆä¸Šæ–¹è¼¸å…¥å¾ŒæŒ‰ Saveï¼‰";
    o.ai.data = null;
    o.ai.ts = nowTs();
    render();
    return;
  }

  // backoff
  if(nowTs() < S.backoffUntil){
    o.ai.err = `AI backoff ä¸­ï¼ˆ${Math.ceil((S.backoffUntil-nowTs())/1000)}sï¼‰`;
    o.ai.data = null;
    o.ai.ts = nowTs();
    render();
    return;
  }

  // â€œçºŒåŠ›æ‰è¨ªå•AIâ€ï¼šè‡ªå‹•åªåœ¨ é»ç«/è§¸ç™¼ è§¸ç™¼ï¼›æ‰‹å‹•å¯å¼·åˆ¶
  if(!manual && !(o.stage==="é»ç«" || o.stage==="è§¸ç™¼")){
    return;
  }

  o.ai.err = null;
  o.ai.data = null;
  o.ai.text = "AI åˆ†æä¸­â€¦";
  o.ai.ts = nowTs();
  render();

  setHB("ai");

  const payload = buildAiPayload(symbol);

  try{
    const out = await groqCall(payload);

    if(!out.parsed){
      o.ai.err = "HTTP 200ï¼Œä½† AI å›è¦†ä¸æ˜¯æœ‰æ•ˆ JSONï¼ˆå·²è¦æ±‚ JSON æ¨¡å¼ï¼‰";
      o.ai.text = out.content ? String(out.content).slice(0,600) : "(empty)";
      o.ai.data = null;
    } else {
      o.ai.data = out.parsed;
      o.ai.err = null;
      o.ai.text = "";
    }
    o.ai.ts = nowTs();
  } catch(e){
    // rate limit / quota
    const status = e.status || 0;
    if(status === 429){
      // simple backoff
      S.backoffUntil = nowTs() + 45_000;
      o.ai.err = "AI 429ï¼šè«‹æ±‚å¤ªå¯†ï¼Œå·²è‡ªå‹• backoff 45s";
    } else if(String(e.message)==="NO_KEY"){
      o.ai.err = "æœªè¼¸å…¥ Groq API Key";
    } else {
      o.ai.err = `AI å¤±æ•—ï¼š${e.message || e}`;
    }
    o.ai.data = null;
    o.ai.ts = nowTs();
  } finally {
    setHB("on");
    render();
  }
}

async function analyzeTopAuto(manual=false){
  if(S.top.length < 3) return;

  // cooldown
  if(!manual && (nowTs() - S.lastAutoAiAt < AUTO_AI_COOLDOWN_MS)) return;

  // only analyze best 3 in Top5
  const list = [...S.top]
    .sort((a,b)=>b.score-a.score)
    .slice(0,3)
    .map(x=>x.symbol);

  // â€œçºŒåŠ›æ‰è¨ªå•AIâ€ï¼šè‡³å°‘æœ‰ä¸€æ”¯åœ¨é»ç«/è§¸ç™¼æ‰è·‘
  if(!manual){
    const ok = list.some(sym => {
      const o = S.data.get(sym);
      return o && (o.stage==="é»ç«" || o.stage==="è§¸ç™¼");
    });
    if(!ok) return;
  }

  S.lastAutoAiAt = nowTs();
  for(const sym of list){
    await analyzeOne(sym, true);
  }
}

/* =========================
   UI EVENTS
========================= */

function loadKey(){
  const k = localStorage.getItem("TRIDENT_GROQ_KEY") || "";
  if(k){
    S.apiKey = k;
    document.getElementById("apiKey").value = k;
  }
  const m = localStorage.getItem("TRIDENT_GROQ_MODEL") || "";
  if(m){
    S.model = m;
    document.getElementById("modelSel").value = m;
  }
  const a = localStorage.getItem("TRIDENT_AUTO_AI");
  if(a!=null){
    S.autoAI = (a === "1");
    document.getElementById("autoAI").checked = S.autoAI;
  }
}

document.getElementById("btnSaveKey").onclick = ()=>{
  const v = document.getElementById("apiKey").value.trim();
  if(v.length < 10){
    alert("Key å¤ªçŸ­æˆ–ç©ºçš„");
    return;
  }
  S.apiKey = v;
  localStorage.setItem("TRIDENT_GROQ_KEY", v);
  alert("å·²å„²å­˜ Groq Keyï¼ˆå­˜åœ¨ä½ çš„ç€è¦½å™¨ localStorageï¼‰");
};

document.getElementById("btnClearKey").onclick = ()=>{
  S.apiKey = "";
  document.getElementById("apiKey").value = "";
  localStorage.removeItem("TRIDENT_GROQ_KEY");
  alert("å·²æ¸…é™¤ Key");
};

document.getElementById("modelSel").onchange = (e)=>{
  S.model = e.target.value;
  localStorage.setItem("TRIDENT_GROQ_MODEL", S.model);
  render();
};

document.getElementById("autoAI").onchange = (e)=>{
  S.autoAI = e.target.checked;
  localStorage.setItem("TRIDENT_AUTO_AI", S.autoAI ? "1":"0");
};

document.getElementById("btnTestAI").onclick = async ()=>{
  // just analyze champion if exists else first deep
  const sym = S.champion.symbol || S.deepList[0];
  if(!sym){ alert("å°šæœªæœ‰å€™é¸å¹£"); return; }
  await analyzeOne(sym, true);
  if(S.data.get(sym)?.ai?.err) alert("Test AI FAILï¼š" + S.data.get(sym).ai.err);
  else alert("Test AI OKï¼ˆçœ‹å³å´ AI å€ï¼‰");
};

document.getElementById("btnAnalyzeTop").onclick = async ()=>{
  await analyzeTopAuto(true);
};

document.getElementById("btnReset").onclick = ()=>{
  location.reload();
};

/* =========================
   MAIN LOOP
========================= */

async function loop(){
  try{
    // initial
    if(!S.universe.length){
      await fastScan();
      await deepScan();
      render();
    }

    // fast refresh
    if(nowTs() - S.lastFastAt > FAST_REFRESH_MS){
      await fastScan();
    }

    // deep refresh
    if(nowTs() - S.lastDeepAt > DEEP_REFRESH_MS){
      await deepScan();
    }

    // auto AI
    if(S.autoAI){
      await analyzeTopAuto(false);
    }

    setStatus("é‹ä½œä¸­");
    updateHeaderCounts();
  } catch(e){
    setStatus("éŒ¯èª¤ï¼š" + (e.message || e));
  } finally {
    setTimeout(loop, 1500);
  }
}

(async function boot(){
  loadKey();
  setStatus("å•Ÿå‹•ä¸­â€¦");
  setHB("off");
  await fastScan();
  await deepScan();
  computeTop5();
  trimWsToTop5();
  render();
  loop();
})();
</script>

</body>
</html>
