<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRIDENT V7 - Long-only Anomaly Scanner (Front-end Only)</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background:#050505; color:#d4d4d8; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .card { background:#0f0f11; border:1px solid #1f1f23; }
    .pill { border:1px solid #2a2a31; background:#0b0b0d; }
    .muted { color:#71717a; }
    .mono { font-variant-numeric: tabular-nums; }
    .ok { color:#22c55e; }
    .bad { color:#ef4444; }
    .warn { color:#f59e0b; }
    .badge { border:1px solid #2a2a31; background:#0b0b0d; padding:2px 8px; border-radius:999px; font-size:11px; }
    .locked { border:2px solid rgba(34,197,94,0.5) !important; box-shadow: 0 0 18px rgba(34,197,94,0.12); }
  </style>
</head>
<body class="p-4">

  <!-- Top bar -->
  <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between mb-4">
    <div class="flex items-center gap-3">
      <span id="hb" class="inline-block w-2 h-2 rounded-full bg-zinc-600"></span>
      <div>
        <div class="text-white font-black italic text-xl leading-none">
          TRIDENT <span class="text-emerald-400">V7</span> <span class="text-zinc-500 text-sm font-bold">LONG ONLY</span>
        </div>
        <div class="text-[11px] muted">
          ç•°å¸¸å„ªå…ˆæƒæ â†’ Top5 â†’ Geminiï¼ˆTopKï¼‰Â· æœ€å¼·é–å®šè¿½è¹¤ï¼ˆé™¤éæ›´å¼·æ‰åˆ‡æ›ï¼‰
        </div>
        <div id="status" class="text-[11px] muted mono mt-1">status: -</div>
      </div>
    </div>

    <div class="flex flex-col md:flex-row gap-2 md:items-end">
      <div class="flex gap-2 items-center">
        <input id="geminiKey" type="password" placeholder="è²¼ä¸Š Gemini API Keyï¼ˆåªå­˜æœ¬æ©Ÿ localStorageï¼‰"
               class="w-80 max-w-full px-3 py-2 rounded text-[12px] bg-zinc-900 border border-zinc-700 text-white outline-none" />
        <button id="saveKeyBtn" class="px-3 py-2 rounded text-[12px] font-bold bg-zinc-800 text-zinc-200 hover:bg-zinc-700">Save</button>
        <button id="clearKeyBtn" class="px-3 py-2 rounded text-[12px] font-bold bg-zinc-900 text-zinc-400 border border-zinc-700 hover:bg-zinc-800">Clear</button>
      </div>

      <div class="flex gap-2 items-center">
        <button id="testGeminiBtn" class="px-3 py-2 rounded text-[12px] font-bold bg-emerald-700 hover:bg-emerald-600 text-white">
          Test Gemini
        </button>
        <button id="analyzeBtn" class="px-3 py-2 rounded text-[12px] font-black bg-blue-600 hover:bg-blue-500 text-white">
          åˆ†æ Topï¼ˆGeminiï¼‰
        </button>
        <button id="resetBtn" class="px-3 py-2 rounded text-[12px] font-bold bg-zinc-900 text-zinc-400 border border-zinc-700 hover:bg-zinc-800">
          RESET
        </button>
      </div>
    </div>
  </div>

  <!-- Main -->
  <div class="card rounded-lg p-4">
    <div class="flex items-center justify-between mb-3">
      <div class="text-white font-black">Top 5 å€™é¸ï¼ˆæœ€å¼·é–å®šç½®é ‚ï¼‰</div>
      <div class="text-[11px] muted mono">
        æ›´æ–°ï¼š<span id="lastUpdate">-</span> Â· æ¨¡å‹ï¼š<span id="modelName">-</span> Â· max_out=<span id="maxOut">-</span> Â· TopK=<span id="topkUI">-</span> Â· Auto=<span id="autoOn">-</span>
      </div>
    </div>

    <div id="top5" class="flex flex-col gap-3"></div>
  </div>

<script>
/* ===================== CONFIG ===================== */
const CFG = {
  EXCLUDE: new Set(['BTCUSDT','ETHUSDT','SOLUSDT','XRPUSDT','BNBUSDT','BNXUSDT']),

  // windows
  WIN_5M_POINTS: 100,      // 5m w/ 3s tick (approx)
  HIST_4H_POINTS: 240,     // 4h w/ 1-min samples

  // anomaly-first gates
  VOL_Z_TH: 1.8,
  FUND_Z_TH: 1.2,
  CANDIDATE_MAX: 40,

  // anti-chase
  MAX_RET_5M_PCT: 0.9,
  MAX_ABS_PREMIUM_PCT: 0.25,
  MAX_RANGE_Z: 2.5,

  // robust warmup (minutes)
  ROBUST_MIN_HIST: 6,

  // OI throttling
  OI_CHECK_MAX: 12,
  OI_REFRESH_MS: 60_000,

  // LONG-only filters (ä½ å¯èª¿)
  LONG_FLOW_IMB_MIN: 0.03,       // ä¸»å‹•è²·å…¥æ¯”ä¾‹è‡³å°‘ > 0.03
  LONG_REQUIRE_FLOW: false,      // true=ä¸€å®šè¦æœ‰imb/deltaæ‰é€²ï¼›false=æ²’flowè³‡æ–™æ™‚å…è¨±ä»£ç†æ¢ä»¶
  LONG_REQUIRE_OI_POS: false,    é•·æœŸå¯é–‹ï¼šOI 5m å¿…é ˆ >=0 æ‰åšå¤šï¼ˆæœƒæ›´åš´æ ¼ï¼‰
  LONG_REQUIRE_PREM_SLOPE_POS: true, // è³‡è²»/æº¢åƒ¹æ–œç‡åå¤šæ›´ä¹¾æ·¨

  // scoring weights
  W_VOLZ: 1.5,
  W_FUNDZ_POS: 0.9,        // fundZ æ­£å‘çå‹µï¼ˆåšå¤šï¼‰
  W_FUNDZ_NEG_PEN: 0.7,    // fundZ è² å‘æ‰£åˆ†
  W_VOL5MZ: 0.7,
  W_IMB5M: 1.0,
  W_DELTAQ: 0.8,           // ä¸»å‹•è²·å…¥å·®é¡ï¼ˆé‡‘é¡ï¼‰æ¬Šé‡ï¼ˆç”¨ zscoreï¼‰
  W_OI5MZ_POS: 0.6,
  W_OI5MZ_NEG_PEN: 0.5,
  W_ALIGN: 0.6,

  // strongest lock behavior
  LOCK_SWITCH_RATIO: 1.06,  // æ–°çš„ç¬¬ä¸€ååˆ†æ•¸ > locked*1.06 æ‰åˆ‡
  LOCK_SWITCH_ABS: 1.0,     // æˆ–è€… > locked + 1.0 æ‰åˆ‡
  LOCK_MIN_HOLD_MS: 90_000, // æœ€å¼·è‡³å°‘æŒæœ‰ 90s æ‰å…è¨±åˆ‡ï¼ˆé¿å…è·³ä¾†è·³å»ï¼‰

  // Gemini
  GEMINI: {
    MODEL: "gemini-2.5-flash",
    TOPK: 3,
    MAX_OUTPUT_TOKENS: 420,
    TEMP: 0.2,
    AUTO_INTERVAL_MS: 120000,     // æœ€å¤šå…©åˆ†é˜è·‘ä¸€æ¬¡
    AUTO_CHECK_MS: 30000,
    SYMBOL_COOLDOWN_MS: 300000    // åŒå¹£ 5 åˆ†é˜å…§ä¸é‡è¤‡å•
  }
};

document.getElementById('modelName').innerText = CFG.GEMINI.MODEL;
document.getElementById('maxOut').innerText = CFG.GEMINI.MAX_OUTPUT_TOKENS;
document.getElementById('topkUI').innerText = CFG.GEMINI.TOPK;

/* ===================== UTILS ===================== */
class Ring {
  constructor(n){ this.n=n; this.a=[]; this.i=0; }
  push(x){
    if (this.a.length < this.n) this.a.push(x);
    else { this.a[this.i] = x; this.i = (this.i+1) % this.n; }
  }
  values(){
    if (this.a.length < this.n || this.i===0) return this.a.slice();
    return this.a.slice(this.i).concat(this.a.slice(0,this.i));
  }
  get size(){ return this.a.length; }
  last(){
    if (this.a.length===0) return null;
    if (this.a.length < this.n) return this.a[this.a.length-1];
    const idx = (this.i - 1 + this.n) % this.n;
    return this.a[idx];
  }
}
function median(arr){
  if (!arr.length) return 0;
  const a = arr.slice().sort((x,y)=>x-y);
  const m = Math.floor(a.length/2);
  return a.length%2 ? a[m] : (a[m-1]+a[m])/2;
}
function mad(arr, med){
  if (!arr.length) return 0;
  const dev = arr.map(x=>Math.abs(x - med));
  return median(dev);
}
function robustZ(x, hist){
  if (!hist || hist.length < CFG.ROBUST_MIN_HIST) return null;
  const med = median(hist);
  const m = mad(hist, med) || 1e-12;
  return (x - med) / (1.4826*m);
}
function linSlope(y){
  const n = y.length;
  if (n < 6) return 0;
  let sx=0, sy=0, sxx=0, sxy=0;
  for (let i=0;i<n;i++){ sx+=i; sy+=y[i]; sxx+=i*i; sxy+=i*y[i]; }
  const den = n*sxx - sx*sx;
  if (Math.abs(den) < 1e-12) return 0;
  return (n*sxy - sx*sy) / den;
}
function fmt(x, d=3){
  if (x===null || x===undefined || Number.isNaN(x)) return '-';
  const v = Number(x);
  if (!Number.isFinite(v)) return '-';
  return v.toFixed(d);
}
function pct(x, d=2){ return fmt(x, d) + '%'; }
function sign(x, eps=1e-6){ return x>eps?1:(x<-eps?-1:0); }
function escapeHtml(s){
  return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}
function hashStr(s){
  let h=2166136261;
  for (let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
  return (h>>>0).toString(16);
}
function nowMs(){ return Date.now(); }

/* ===================== CHINESE MAPPERS ===================== */
function patternCN(p){
  const m = {
    "breakout-pending": "çªç ´å‰å…†ï¼ˆå¾…è¡¨æ…‹ï¼‰",
    "continuation-pullback": "ä¸­ç¹¼å›è¸©ï¼ˆçºŒèµ°ï¼‰",
    "reversal": "åè½‰å‹æ…‹",
    "squeeze": "æ“ å£“æ”¶æ–‚ï¼ˆå¾…æ”¾é‡ï¼‰",
    "chop": "ç›¤æ•´é›œè¨Š"
  };
  return m[p] || (p || "-");
}
function biasCN(b){
  const m = { "LONG":"åå¤š", "SHORT":"åç©º", "NEUTRAL":"è§€æœ›" };
  return m[b] || (b || "-");
}
function typeCN(t){
  const m = { "stop":"çªç ´å–®", "limit":"é™åƒ¹å–®", "market":"å¸‚åƒ¹" };
  return m[t] || (t || "-");
}

/* ===================== STATE ===================== */
const S = new Map();        // symbol -> state
let wsMark = null;
let wsKline = null;

let symbolsAll = [];
let candidates = [];        // symbols
let topList = [];           // [{sym,score}]
let displayList = [];       // [{sym,score}] locked-first

let lastHeartbeat = 0;
let lastCandidateHash = "";
let lastTopAt = 0;

// strongest lock
let lockedSym = null;
let lockedAt = 0;

// Gemini store per symbol (for right side display)
const aiBySym = new Map();
const lastGeminiSymAt = new Map();
let lastAutoGeminiAt = 0;
let lastTopHashGemini = "";

function stOf(sym){
  if (S.has(sym)) return S.get(sym);
  const st = {
    sym,

    // markPrice stream fields
    lastP: null,
    lastI: null,
    lastR: null,
    retRing: new Ring(CFG.WIN_5M_POINTS),   // log returns
    premRing: new Ring(CFG.WIN_5M_POINTS),  // premium fraction

    // minute sampled hist (4h)
    rvHist: new Ring(CFG.HIST_4H_POINTS),
    premSlopeHist: new Ring(CFG.HIST_4H_POINTS),
    lastSampleAt: 0,

    // derived
    rv5m: null,
    ret5mPct: null,
    premNow: null,          // %
    premSlope: null,        // scaled
    volZ: null,
    fundZ: null,

    // candidate kline 5m
    k5Bars: [],
    vol5Hist: new Ring(48),
    imb5Hist: new Ring(48),
    rangeHist: new Ring(48),
    deltaQHist: new Ring(48),

    // last values
    vol5mZ: null,
    imb5m: null,
    imb4h: null,
    rangeZ: null,

    delta5mQuote: null,
    delta4hQuote: null,
    deltaQZ: null,

    // OI
    oi: { ts: 0, dOi5m: null, oi5mZ: null, dOi4h: null },

    // structure/patterns
    patternTags: [],
    levels: { swingHigh: null, swingLow: null, mid: null },
    dist: { toHighPct: null, toLowPct: null, medianRangePct: null },

    // scoring
    dirHint: 0,
    score: null
  };
  S.set(sym, st);
  return st;
}

/* ===================== BINANCE UNIVERSE ===================== */
async function loadUniverse(){
  const ex = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo').then(r=>r.json());
  symbolsAll = (ex.symbols || [])
    .filter(x => x.status === 'TRADING' && x.contractType === 'PERPETUAL' && x.quoteAsset === 'USDT')
    .map(x => x.symbol)
    .filter(s => !CFG.EXCLUDE.has(s));
}

/* ===================== MARKPRICE WS (3s) ===================== */
function connectMark(){
  if (wsMark) try{ wsMark.close(); }catch(_){}
  wsMark = new WebSocket('wss://fstream.binance.com/ws/!markPrice@arr');

  wsMark.onopen = () => { lastHeartbeat = nowMs(); };

  wsMark.onmessage = (ev) => {
    lastHeartbeat = nowMs();
    const arr = JSON.parse(ev.data);

    for (const u of arr){
      const sym = u.s;
      if (!sym || CFG.EXCLUDE.has(sym)) continue;

      const st = stOf(sym);
      const p = Number(u.p);
      const i = Number(u.i);
      const r = Number(u.r);

      if (Number.isFinite(p) && st.lastP){
        st.retRing.push(Math.log(p / st.lastP));
      }
      st.lastP = Number.isFinite(p) ? p : st.lastP;
      st.lastI = Number.isFinite(i) ? i : st.lastI;
      st.lastR = Number.isFinite(r) ? r : st.lastR;

      if (st.lastP && st.lastI){
        st.premRing.push((st.lastP - st.lastI) / st.lastI);
      }
    }
  };

  wsMark.onclose = () => setTimeout(connectMark, 2000);
  wsMark.onerror = () => { try{ wsMark.close(); }catch(_){} };
}

/* ===================== METRICS SAMPLING ===================== */
function sampleMetrics(){
  const now = nowMs();
  for (const st of S.values()){
    if (st.retRing.size < 20 || st.premRing.size < 20) continue;

    const rets = st.retRing.values();
    let sum = 0, sumsq = 0;
    for (const x of rets){ sum += x; sumsq += x*x; }

    st.ret5mPct = (Math.exp(sum) - 1) * 100;
    st.rv5m = Math.sqrt(sumsq) * 100;

    const prem = st.premRing.last(); // fraction
    st.premNow = prem * 100;         // %
    st.premSlope = linSlope(st.premRing.values()) * 1e4;

    if (!st.lastSampleAt || (now - st.lastSampleAt >= 60_000)){
      st.rvHist.push(st.rv5m);
      st.premSlopeHist.push(st.premSlope);
      st.lastSampleAt = now;
    }

    st.volZ = robustZ(st.rv5m, st.rvHist.values());
    st.fundZ = robustZ(st.premSlope, st.premSlopeHist.values());
  }
}

/* ===================== CANDIDATES (anomaly-first) ===================== */
function computeCandidates(){
  const arr = [];
  for (const st of S.values()){
    if (st.volZ === null) continue;

    const volPass  = Math.abs(st.volZ) >= CFG.VOL_Z_TH;
    const retPass  = (st.ret5mPct !== null) && (Math.abs(st.ret5mPct) <= CFG.MAX_RET_5M_PCT);
    const premPass = (st.premNow !== null) && (Math.abs(st.premNow) <= CFG.MAX_ABS_PREMIUM_PCT);

    if (!volPass || !retPass || !premPass) continue;

    const fundPass = (st.fundZ !== null) ? (Math.abs(st.fundZ) >= CFG.FUND_Z_TH) : false;
    const preScore = Math.abs(st.volZ) + 0.6*Math.abs(st.fundZ || 0) + (fundPass ? 0.4 : 0);

    arr.push({ sym: st.sym, preScore });
  }

  arr.sort((a,b)=>b.preScore - a.preScore);
  candidates = arr.slice(0, CFG.CANDIDATE_MAX).map(x=>x.sym);
}

/* ===================== KLINE 5m for candidates ===================== */
function connectKlineForCandidates(){
  const hash = candidates.join('|');
  if (hash === lastCandidateHash) return;
  lastCandidateHash = hash;

  if (wsKline) try{ wsKline.close(); }catch(_){}
  if (!candidates.length) return;

  const streams = candidates.map(s => `${s.toLowerCase()}@kline_5m`);
  const url = `wss://fstream.binance.com/stream?streams=${streams.join('/')}`;
  wsKline = new WebSocket(url);

  wsKline.onmessage = (ev) => {
    const msg = JSON.parse(ev.data);
    const data = msg.data;
    if (!data || data.e !== 'kline') return;

    const sym = data.s;
    const k = data.k;
    if (!k || !k.x) return; // only closed 5m candle

    const st = stOf(sym);
    const o = Number(k.o), h = Number(k.h), l = Number(k.l), c = Number(k.c);
    const v = Number(k.v);     // total base volume
    const V = Number(k.V);     // taker buy base volume
    const range = (c > 0) ? ((h - l) / c) : 0;

    // ä¸»å‹•è²·å…¥æ¯”ä¾‹ï¼ˆ-1~+1ï¼‰
    const imb = (v > 0) ? ((2*V - v) / v) : 0;

    // âœ… ä¸»å‹•è²·å…¥å·®é¡ï¼ˆç”¨ quote é‡‘é¡è¿‘ä¼¼ï¼‰
    const deltaBase = (2*V - v);
    const deltaQuote = deltaBase * c;

    st.vol5Hist.push(v);
    st.imb5Hist.push(imb);
    st.rangeHist.push(range);
    st.deltaQHist.push(deltaQuote);

    st.k5Bars.push({ t:k.T, o,h,l,c,v,V, imb, range, deltaQuote });
    if (st.k5Bars.length > 80) st.k5Bars.shift();

    st.imb5m = imb;
    st.delta5mQuote = deltaQuote;

    // 4h values (48 bars)
    const vols = st.vol5Hist.values();
    const imbs = st.imb5Hist.values();
    let wSum=0, vSum=0;
    for (let i=0;i<Math.min(vols.length, imbs.length); i++){
      wSum += imbs[i] * vols[i];
      vSum += vols[i];
    }
    st.imb4h = vSum > 0 ? (wSum / vSum) : 0;

    const dq = st.deltaQHist.values();
    st.delta4hQuote = dq.reduce((a,b)=>a+b, 0);

    st.vol5mZ = robustZ(v, st.vol5Hist.values());
    st.rangeZ = robustZ(range, st.rangeHist.values());
    st.deltaQZ = robustZ(deltaQuote, st.deltaQHist.values());

    computeLocalPattern(st);
    computeDistanceFeatures(st);
  };

  wsKline.onclose = () => setTimeout(connectKlineForCandidates, 1500);
  wsKline.onerror = () => { try{ wsKline.close(); }catch(_){} };
}

/* ===================== PATTERN / STRUCTURE ===================== */
function computeLocalPattern(st){
  const bars = st.k5Bars;
  if (bars.length < 3) { st.patternTags = []; return; }

  const last = bars[bars.length-1];
  const prev = bars[bars.length-2];
  const prev2 = bars[bars.length-3];
  const tags = [];

  const body = Math.abs(last.c - last.o);
  const rng = Math.max(1e-12, last.h - last.l);
  const bodyPct = body / rng;

  const upperWick = last.h - Math.max(last.o, last.c);
  const lowerWick = Math.min(last.o, last.c) - last.l;

  if (bodyPct < 0.2) tags.push("åå­—/çŒ¶è±«");
  if (lowerWick > 2*body && upperWick < body) tags.push("éŒ˜å­ç·šå‚¾å‘");
  if (upperWick > 2*body && lowerWick < body) tags.push("æµæ˜Ÿç·šå‚¾å‘");

  if (last.h < prev.h && last.l > prev.l) tags.push("å…§åŒ…ç·š");

  const lastBull = last.c > last.o;
  const prevBull = prev.c > prev.o;
  const lastBodyHi = Math.max(last.o, last.c);
  const lastBodyLo = Math.min(last.o, last.c);
  const prevBodyHi = Math.max(prev.o, prev.c);
  const prevBodyLo = Math.min(prev.o, prev.c);

  if (lastBull && !prevBull && lastBodyHi >= prevBodyHi && lastBodyLo <= prevBodyLo) tags.push("å¤šæ–¹åå™¬");
  if (!lastBull && prevBull && lastBodyHi >= prevBodyHi && lastBodyLo <= prevBodyLo) tags.push("ç©ºæ–¹åå™¬");

  const rArr = st.rangeHist.values();
  if (rArr.length >= 20){
    const medR = median(rArr);
    if (last.range < 0.75*medR) tags.push("æ³¢å¹…æ”¶æ–‚");
    if (last.range > 1.6*medR) tags.push("æ³¢å¹…æ“´å¼µ");
  }

  const vArr = st.vol5Hist.values();
  if (vArr.length >= 20){
    const medV = median(vArr);
    if (last.v > 1.8*medV) tags.push("é‡èƒ½æ”¾å¤§");
    if (last.v < 0.6*medV) tags.push("é‡èƒ½èç¸®");
  }

  if (Math.sign(prev2.imb) === Math.sign(prev.imb) && Math.sign(prev.imb) === Math.sign(last.imb) && Math.abs(last.imb) > 0.08){
    tags.push("ä¸»å‹•è²·é€£çºŒåå¤š");
  }

  // structure levels (last 20 bars)
  const seg = bars.slice(-20);
  const swingHigh = Math.max(...seg.map(b=>b.h));
  const swingLow  = Math.min(...seg.map(b=>b.l));
  st.levels.swingHigh = swingHigh;
  st.levels.swingLow = swingLow;
  st.levels.mid = (swingHigh + swingLow)/2;

  st.patternTags = tags;
}

function computeDistanceFeatures(st){
  if (!st.lastP || !st.levels.swingHigh || !st.levels.swingLow) return;

  const p = st.lastP;
  st.dist.toHighPct = (st.levels.swingHigh - p) / p * 100;
  st.dist.toLowPct  = (p - st.levels.swingLow) / p * 100;

  const r = st.rangeHist.values();
  if (r.length >= 10){
    st.dist.medianRangePct = median(r) * 100;
  }
}

/* ===================== OI (throttled) ===================== */
async function fetchOI(sym){
  const st = stOf(sym);
  const now = nowMs();
  if (now - st.oi.ts < CFG.OI_REFRESH_MS) return;

  const url5 = `https://fapi.binance.com/futures/data/openInterestHist?symbol=${sym}&period=5m&limit=50`;
  const url4 = `https://fapi.binance.com/futures/data/openInterestHist?symbol=${sym}&period=4h&limit=2`;

  const [d5, d4] = await Promise.all([
    fetch(url5).then(r=>r.json()).catch(()=>null),
    fetch(url4).then(r=>r.json()).catch(()=>null),
  ]);

  function sortByTs(a){ return (a||[]).slice().sort((x,y)=>(x.timestamp||0)-(y.timestamp||0)); }

  const a5 = sortByTs(d5);
  if (a5.length >= 10){
    const series = a5.map(x => Number(x.sumOpenInterestValue ?? x.sumOpenInterest));
    const diffs = [];
    for (let i=1;i<series.length;i++) diffs.push(series[i] - series[i-1]);
    const lastDiff = diffs[diffs.length-1];
    const hist = diffs.slice(0, -1);

    st.oi.dOi5m = lastDiff;
    st.oi.oi5mZ = robustZ(lastDiff, hist);
  }

  const a4 = sortByTs(d4);
  if (a4.length === 2){
    const s0 = Number(a4[0].sumOpenInterestValue ?? a4[0].sumOpenInterest);
    const s1 = Number(a4[1].sumOpenInterestValue ?? a4[1].sumOpenInterest);
    st.oi.dOi4h = (s1 - s0);
  }

  st.oi.ts = now;
}

async function refreshOIForStrongOnes(){
  const scored = candidates.map(sym=>{
    const st = stOf(sym);
    const s = Math.abs(st.volZ||0) + 0.7*Math.max(0,(st.fundZ||0)) + 0.6*Math.max(0,(st.deltaQZ||0)) + 0.7*Math.max(0,(st.imb5m||0));
    return {sym, s};
  }).sort((a,b)=>b.s-a.s).slice(0, CFG.OI_CHECK_MAX);

  for (const x of scored){
    await fetchOI(x.sym);
  }
}

/* ===================== TOP5 SCORE + STRONGEST LOCK ===================== */
function passLongOnly(st){
  const hasFlow = (st.imb5m !== null && st.delta5mQuote !== null);

  const flowLong =
    hasFlow &&
    (st.imb5m > CFG.LONG_FLOW_IMB_MIN) &&
    (st.delta5mQuote > 0);

  const proxyLong =
    (!hasFlow) &&
    (!CFG.LONG_REQUIRE_FLOW) &&
    (CFG.LONG_REQUIRE_PREM_SLOPE_POS ? ((st.premSlope || 0) > 0) : true) &&
    ((st.fundZ === null) ? true : (st.fundZ >= 0)); // proxy: funding slope not bearish

  if (CFG.LONG_REQUIRE_FLOW) return flowLong;
  return flowLong || proxyLong;
}

function computeTopAndLock(){
  const arr = [];

  for (const sym of candidates){
    const st = stOf(sym);
    if (st.volZ === null) continue;

    // basic "not too late"
    const rangeOk = (st.rangeZ === null) ? true : (Math.abs(st.rangeZ) <= CFG.MAX_RANGE_Z);
    if (!rangeOk) continue;

    // Long-only filter
    if (!passLongOnly(st)) continue;

    // direction hint
    st.dirHint = 1; // Long-only view

    // scoring
    let score = 0;

    // anomaly (vol always good as "attention")
    score += CFG.W_VOLZ * Math.abs(st.volZ || 0);

    // funding slope directional
    const fz = (st.fundZ || 0);
    if (fz >= 0) score += CFG.W_FUNDZ_POS * fz;
    else score -= CFG.W_FUNDZ_NEG_PEN * Math.abs(fz);

    // volume anomaly
    score += CFG.W_VOL5MZ * Math.max(0, (st.vol5mZ || 0));

    // flow (imbalance)
    score += CFG.W_IMB5M * Math.max(0, (st.imb5m || 0));

    // taker delta quote zscore
    score += CFG.W_DELTAQ * Math.max(0, (st.deltaQZ || 0));

    // OI directional
    const oz = (st.oi.oi5mZ || 0);
    if (oz >= 0) score += CFG.W_OI5MZ_POS * oz;
    else score -= CFG.W_OI5MZ_NEG_PEN * Math.abs(oz);

    // optional stricter long confirmations
    if (CFG.LONG_REQUIRE_PREM_SLOPE_POS && (st.premSlope || 0) <= 0) score -= 0.8;
    if (CFG.LONG_REQUIRE_OI_POS && (st.oi.dOi5m || 0) < 0) score -= 0.8;

    // anti-chase penalty
    if (st.ret5mPct !== null && Math.abs(st.ret5mPct) > CFG.MAX_RET_5M_PCT) score -= 1.2;

    // "flow missing" penalty (still allow proxy but lower)
    const hasFlow = (st.imb5m !== null && st.delta5mQuote !== null);
    if (!hasFlow) score -= 0.8;

    // align bonus: flowLong + positive prem slope
    const align = (hasFlow && st.imb5m > 0 && (st.premSlope || 0) > 0) ? 1 : 0;
    score += CFG.W_ALIGN * align;

    st.score = score;
    arr.push({ sym, score });
  }

  arr.sort((a,b)=>b.score - a.score);
  topList = arr.slice(0, 25); // for lock check / debug

  // update lock
  const top1 = arr[0] || null;
  const now = nowMs();

  if (!lockedSym && top1){
    lockedSym = top1.sym;
    lockedAt = now;
  } else if (lockedSym){
    const lockedRow = arr.find(x=>x.sym === lockedSym);
    if (!lockedRow && top1){
      lockedSym = top1.sym;
      lockedAt = now;
    } else if (lockedRow && top1 && top1.sym !== lockedSym){
      const holdOk = (now - lockedAt) >= CFG.LOCK_MIN_HOLD_MS;
      const ratioOk = top1.score > lockedRow.score * CFG.LOCK_SWITCH_RATIO;
      const absOk   = top1.score > lockedRow.score + CFG.LOCK_SWITCH_ABS;

      if (holdOk && (ratioOk || absOk)){
        lockedSym = top1.sym;
        lockedAt = now;
      }
    }
  }

  // build display list: locked first, then next best until 5
  const out = [];
  if (lockedSym){
    const r = arr.find(x=>x.sym === lockedSym);
    if (r) out.push(r);
  }
  for (const r of arr){
    if (out.length >= 5) break;
    if (out.find(x=>x.sym === r.sym)) continue;
    out.push(r);
  }
  displayList = out;

  lastTopAt = now;
  document.getElementById('lastUpdate').innerText = new Date(lastTopAt).toLocaleTimeString();
}

/* ===================== GEMINI ===================== */
function getGeminiKey(){
  const k = document.getElementById('geminiKey').value.trim();
  return k || (localStorage.getItem('GEMINI_API_KEY') || "");
}
function saveGeminiKey(){
  const k = document.getElementById('geminiKey').value.trim();
  if (!k) return alert("Key ç©ºçš„");
  localStorage.setItem('GEMINI_API_KEY', k);
  alert("å·²å­˜åˆ° localStorageï¼ˆåªåœ¨é€™å°ç€è¦½å™¨ï¼‰");
}
function clearGeminiKey(){
  localStorage.removeItem('GEMINI_API_KEY');
  document.getElementById('geminiKey').value = "";
  alert("å·²æ¸…é™¤");
}

function safeParseJson(maybe){
  let s = String(maybe || "").trim();
  s = s.replace(/^```(?:json)?/i, "").replace(/```$/i, "").trim();

  const first = s.indexOf("{");
  const last  = s.lastIndexOf("}");
  if (first !== -1 && last !== -1 && last > first){
    s = s.slice(first, last + 1);
  }
  return JSON.parse(s);
}

function buildGeminiPrompt(sym){
  const st = stOf(sym);

  const lastBars = st.k5Bars.slice(-6).map(b => ({
    o:+b.o, h:+b.h, l:+b.l, c:+b.c,
    v:+b.v,
    imb:+b.imb,
    dQ:+b.deltaQuote
  }));

  const summary = {
    symbol: sym,

    // anomalies
    vol_z: st.volZ,
    fund_z: st.fundZ,
    vol5m_z: st.vol5mZ,
    deltaQ_z: st.deltaQZ,
    oi_z_5m: st.oi.oi5mZ,

    // flow
    imb_5m: st.imb5m,
    imb_4h: st.imb4h,
    taker_delta_5m_quote: st.delta5mQuote,
    taker_delta_4h_quote: st.delta4hQuote,

    // OI
    oi_d_5m: st.oi.dOi5m,
    oi_d_4h: st.oi.dOi4h,

    // anti-chase
    ret_5m_pct: st.ret5mPct,
    premium_pct: st.premNow,
    range_z: st.rangeZ,

    // structure
    pattern_tags: st.patternTags,
    levels: st.levels,
    dist_to_swingHigh_pct: st.dist.toHighPct,
    dist_to_swingLow_pct: st.dist.toLowPct,
    median_range_5m_pct: st.dist.medianRangePct,

    last_price: st.lastP,
    last_6x_5m: lastBars
  };

  return `
ä½ æ˜¯ã€Œåˆç´„çŸ­ç·šï¼ˆ5~10åˆ†é˜ï¼‰åšå¤šè¨Šè™Ÿå¯©æ ¸å“¡ã€ï¼Œåªèƒ½æ ¹æ“šæˆ‘æä¾›çš„æ‘˜è¦ JSON åˆ¤æ–·ï¼Œä¸å¯ä½¿ç”¨å¤–éƒ¨è³‡è¨Šã€‚
ç›®æ¨™ï¼šåªè©•ä¼°ã€åšå¤šã€‘æ©Ÿæœƒã€‚è‹¥ä¸é©åˆåšå¤šï¼Œbias å¿…é ˆå› NEUTRALã€‚
ä½ å¿…é ˆè¼¸å‡ºä¸­æ–‡é‚è¼¯ï¼ˆlogic/notes éƒ½ç”¨ä¸­æ–‡ï¼‰ï¼Œä¸¦çµ¦å‡ºã€Œé è¨ˆå¹¾åˆ†é˜å…§è¡¨æ…‹ã€çš„å€é–“ã€‚

ã€è¡¨æ…‹å®šç¾©ã€‘ï¼š
- çªç ´è¡¨æ…‹ï¼šçªç ´è¿‘ 20 æ ¹ 5m çš„ swingHigh
- å›è¸©çºŒèµ°è¡¨æ…‹ï¼šå›è¸© mid æˆ– swingHigh é™„è¿‘å¾Œé‡æ–°èµ°å¼·ï¼ˆéœ€ flow/OI æ”¯æŒï¼‰

ã€æ‘˜è¦ JSONã€‘
${JSON.stringify(summary)}

ã€åªèƒ½è¼¸å‡ºåš´æ ¼ JSONï¼Œä¸è¦ä»»ä½•å¤šé¤˜æ–‡å­—ã€‘
schema:
{
  "symbol": "string",
  "bias": "LONG|NEUTRAL",
  "confidence": number,
  "pattern": "breakout-pending|continuation-pullback|reversal|squeeze|chop",
  "eta_minutes": { "min": number, "max": number, "logic": "string" },
  "trigger": { "price": number, "logic": "string" },
  "entry": { "type": "stop|limit|market", "price": number, "logic": "string" },
  "stop": { "price": number, "logic": "string" },
  "takeProfit": [ { "price": number, "logic": "string" } ],
  "invalidation": "string",
  "notes": [ "string" ]
}
  `.trim();
}

async function callGeminiFor(sym){
  const key = getGeminiKey();
  if (!key) throw new Error("ç¼ºå°‘ Gemini keyï¼ˆå…ˆè²¼ä¸Šå† Saveï¼‰");

  const url = `https://generativelanguage.googleapis.com/v1beta/models/${CFG.GEMINI.MODEL}:generateContent`;
  const body = {
    contents: [{ role: "user", parts: [{ text: buildGeminiPrompt(sym) }] }],
    generationConfig: {
      temperature: CFG.GEMINI.TEMP,
      max_output_tokens: CFG.GEMINI.MAX_OUTPUT_TOKENS,
      response_mime_type: "application/json"
    }
  };

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type":"application/json", "x-goog-api-key": key },
    body: JSON.stringify(body)
  });

  const raw = await res.text();
  if (!res.ok) throw new Error(`Gemini HTTP ${res.status}: ${raw.slice(0,220)}`);

  const json = JSON.parse(raw);
  const text = json?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";

  try {
    return safeParseJson(text);
  } catch (e) {
    // fallback object (still show in UI)
    const st = stOf(sym);
    return {
      symbol: sym,
      bias: "NEUTRAL",
      confidence: 0,
      pattern: "chop",
      eta_minutes: { min: 0, max: 0, logic: "Gemini å›å‚³ç„¡æ³•è§£ææˆ JSONï¼ˆçœ‹ notes rawï¼‰" },
      trigger: { price: st.lastP || 0, logic: "-" },
      entry: { type: "market", price: st.lastP || 0, logic: "å›å‚³é JSON" },
      stop: { price: st.lastP || 0, logic: "-" },
      takeProfit: [],
      invalidation: "-",
      notes: [String(text).slice(0,400)]
    };
  }
}

/* ===================== AI SUMMARY (Chinese) ===================== */
function formatAiCN(ai){
  const eta = ai?.eta_minutes ? `${ai.eta_minutes.min}~${ai.eta_minutes.max} åˆ†é˜` : "-";
  const trig = ai?.trigger?.price ?? "-";
  const entry = ai?.entry ? `${typeCN(ai.entry.type)} @ ${ai.entry.price ?? "-"}` : "-";
  const stop  = ai?.stop?.price ?? "-";
  const tps   = Array.isArray(ai?.takeProfit) ? ai.takeProfit.map(x=>x.price).filter(v=>v!==undefined && v!==null).join(" / ") : "";
  const conf  = (ai?.confidence ?? 0);
  const bias  = biasCN(ai?.bias);
  const patt  = patternCN(ai?.pattern);

  const biasCls = (ai?.bias === "LONG") ? "ok font-bold" : "muted";

  const notes = Array.isArray(ai?.notes) ? ai.notes.slice(0,3) : [];
  const notesHtml = notes.length ? notes.map(x=>`â€¢ ${escapeHtml(String(x))}`).join("<br/>") : "-";

  return `
    <div class="text-[12px] text-white font-bold">AI åˆ¤è®€ï¼ˆä¸­æ–‡ï¼‰</div>
    <div class="text-[11px] mono mt-2 leading-relaxed">
      <div>æ–¹å‘ï¼š<span class="${biasCls}">${bias}</span>ï½œä¿¡å¿ƒï¼š<span class="text-white font-bold">${conf}</span>/100</div>
      <div>å‹æ…‹ï¼š<span class="text-white">${escapeHtml(String(patt))}</span></div>
      <div>é è¨ˆè¡¨æ…‹ï¼š<span class="text-white font-bold">${escapeHtml(String(eta))}</span></div>
      <div>è§¸ç™¼åƒ¹ï¼š<span class="text-white">${escapeHtml(String(trig))}</span></div>
      <div>é€²å ´ï¼š<span class="text-white">${escapeHtml(String(entry))}</span></div>
      <div>æ­¢æï¼š<span class="text-white">${escapeHtml(String(stop))}</span></div>
      <div>æ­¢ç›ˆï¼š<span class="text-white">${escapeHtml(String(tps || "-"))}</span></div>
      <div>å¤±æ•ˆæ¢ä»¶ï¼š<span class="text-white">${escapeHtml(String(ai?.invalidation || "-"))}</span></div>
      <div class="muted mt-2">å‚™è¨»ï¼š<br/>${notesHtml}</div>
    </div>
  `;
}

/* ===================== RENDER ===================== */
function render(){
  const hb = document.getElementById('hb');
  const alive = (nowMs() - lastHeartbeat) < 5000;
  hb.className = `inline-block w-2 h-2 rounded-full ${alive ? 'bg-emerald-500' : 'bg-zinc-600'}`;

  document.getElementById('autoOn').innerText = getGeminiKey() ? "ON" : "OFF";

  const zReady = [...S.values()].filter(x => x.volZ !== null).length;
  const lockInfo = lockedSym ? `LOCK=${lockedSym} (æŒæœ‰${Math.floor((nowMs()-lockedAt)/1000)}s)` : "LOCK=-";

  document.getElementById('status').innerText =
    `universe=${symbolsAll.length} | states=${S.size} | zReady=${zReady} | candidates=${candidates.length} | show=${displayList.length} | ${lockInfo} | hbAgeMs=${nowMs()-lastHeartbeat}`;

  const wrap = document.getElementById('top5');
  wrap.innerHTML = "";

  for (let idx=0; idx<displayList.length; idx++){
    const row = displayList[idx];
    const sym = row.sym;
    const st = stOf(sym);

    const isLocked = (sym === lockedSym);
    const ai = aiBySym.get(sym);

    // left side tags and badges
    const badges = [];
    if (isLocked) badges.push(`<span class="badge text-emerald-300">ğŸ¯ æœ€å¼·è¿½è¹¤</span>`);
    badges.push(`<span class="badge muted">score ${fmt(st.score,2)}</span>`);

    const hasFlow = (st.imb5m !== null && st.delta5mQuote !== null);
    if (!hasFlow) badges.push(`<span class="badge warn">ç­‰å¾… 5m æ”¶ç·š</span>`);

    // right side AI summary
    const aiHtml = ai ? formatAiCN(ai) : `<div class="text-[11px] muted">å°šæœªåˆ†æï¼šæŒ‰å³ä¸Šã€ŒGeminiã€æˆ–ã€Œåˆ†æ Topã€</div>`;

    const card = document.createElement('div');
    card.className = `p-3 rounded-lg border border-zinc-800 bg-black/20 ${isLocked ? 'locked' : ''}`;

    card.innerHTML = `
      <div class="flex flex-col lg:flex-row gap-3">
        <!-- LEFT: metrics -->
        <div class="flex-1">
          <div class="flex items-start justify-between gap-3">
            <div>
              <div class="text-white font-black text-lg">${sym}</div>
              <div class="text-[11px] muted mono mt-1">${badges.join(" ")}</div>
              <div class="text-[11px] muted mono mt-1">å‹æ…‹æ¨™ç±¤ï¼š${(st.patternTags||[]).join(" / ") || "-"}</div>
            </div>
            <div class="flex items-center gap-2">
              <button class="px-3 py-2 rounded text-[12px] font-black bg-zinc-800 hover:bg-zinc-700 text-white" data-sym="${sym}">
                Gemini
              </button>
            </div>
          </div>

          <div class="grid grid-cols-2 md:grid-cols-3 gap-2 mt-3 text-[11px] mono">
            <div class="pill rounded px-2 py-1">æ³¢å‹•ç•°å¸¸Zï¼š<span class="text-white">${fmt(st.volZ,2)}</span></div>
            <div class="pill rounded px-2 py-1">è³‡è²»æ–œç‡Zï¼š<span class="text-white">${fmt(st.fundZ,2)}</span></div>
            <div class="pill rounded px-2 py-1">5åˆ†é˜æ¼²è·Œï¼š<span class="text-white">${pct(st.ret5mPct,2)}</span></div>

            <div class="pill rounded px-2 py-1">æº¢åƒ¹(æ¨™è¨˜-æŒ‡æ•¸)ï¼š<span class="text-white">${pct(st.premNow,3)}</span></div>
            <div class="pill rounded px-2 py-1">ä¸»å‹•è²·å…¥æ¯”ä¾‹(5m)ï¼š<span class="text-white">${fmt(st.imb5m,3)}</span></div>
            <div class="pill rounded px-2 py-1">ä¸»å‹•è²·å…¥æ¯”ä¾‹(4h)ï¼š<span class="text-white">${fmt(st.imb4h,3)}</span></div>

            <div class="pill rounded px-2 py-1">ä¸»å‹•è²·å…¥å·®é¡(5m,é‡‘é¡)ï¼š<span class="text-white">${fmt(st.delta5mQuote,0)}</span></div>
            <div class="pill rounded px-2 py-1">ä¸»å‹•è²·å…¥å·®é¡(4h,é‡‘é¡)ï¼š<span class="text-white">${fmt(st.delta4hQuote,0)}</span></div>
            <div class="pill rounded px-2 py-1">å·®é¡ç•°å¸¸Zï¼š<span class="text-white">${fmt(st.deltaQZ,2)}</span></div>

            <div class="pill rounded px-2 py-1">æˆäº¤é‡ç•°å¸¸Z(5m)ï¼š<span class="text-white">${fmt(st.vol5mZ,2)}</span></div>
            <div class="pill rounded px-2 py-1">OIç•°å¸¸Z(5m)ï¼š<span class="text-white">${fmt(st.oi.oi5mZ,2)}</span></div>
            <div class="pill rounded px-2 py-1">OIè®ŠåŒ–(4h)ï¼š<span class="text-white">${fmt(st.oi.dOi4h,2)}</span></div>

            <div class="pill rounded px-2 py-1">è·é«˜/ä½é»(%)ï¼š<span class="text-white">${fmt(st.dist.toHighPct,2)}/${fmt(st.dist.toLowPct,2)}</span></div>
            <div class="pill rounded px-2 py-1">5mä¸­ä½æ³¢å¹…(%)ï¼š<span class="text-white">${fmt(st.dist.medianRangePct,2)}</span></div>
            <div class="pill rounded px-2 py-1">é—œéµä½ï¼š<span class="text-white">${fmt(st.levels.swingLow,6)} ~ ${fmt(st.levels.swingHigh,6)}</span></div>
          </div>
        </div>

        <!-- RIGHT: AI -->
        <div class="w-full lg:w-[380px] shrink-0">
          <div class="p-3 rounded-lg border border-zinc-800 bg-black/30 h-full">
            ${aiHtml}
          </div>
        </div>
      </div>
    `;

    card.querySelector('button').onclick = async () => { await analyzeOne(sym); };
    wrap.appendChild(card);
  }
}

/* ===================== PIPELINE ===================== */
async function tickPipeline(){
  computeCandidates();
  connectKlineForCandidates();
  await refreshOIForStrongOnes();
  computeTopAndLock();
}

/* ===================== GEMINI ACTIONS ===================== */
async function analyzeOne(sym){
  const lastTs = lastGeminiSymAt.get(sym) || 0;
  if (nowMs() - lastTs < CFG.GEMINI.SYMBOL_COOLDOWN_MS){
    // cooldown -> still render existing
    return;
  }

  // temporary placeholder (so you see "åˆ†æä¸­" on right side)
  aiBySym.set(sym, {
    symbol: sym, bias: "NEUTRAL", confidence: 0, pattern: "chop",
    eta_minutes: {min:0,max:0,logic:"åˆ†æä¸­â€¦"},
    trigger:{price:0,logic:"-"},
    entry:{type:"market",price:0,logic:"-"},
    stop:{price:0,logic:"-"},
    takeProfit:[],
    invalidation:"-",
    notes:["åˆ†æä¸­â€¦"]
  });
  render();

  try{
    const res = await callGeminiFor(sym);
    aiBySym.set(sym, res);
    lastGeminiSymAt.set(sym, nowMs());
    render();
  }catch(e){
    const st = stOf(sym);
    aiBySym.set(sym, {
      symbol: sym,
      bias: "NEUTRAL",
      confidence: 0,
      pattern: "chop",
      eta_minutes: {min:0,max:0,logic:"Gemini å‘¼å«å¤±æ•—"},
      trigger:{price:st.lastP||0,logic:"-"},
      entry:{type:"market",price:st.lastP||0,logic:"Gemini error"},
      stop:{price:st.lastP||0,logic:"-"},
      takeProfit:[],
      invalidation:"-",
      notes:[String(e.message || e)]
    });
    render();
  }
}

async function analyzeTop(){
  const pick = displayList.slice(0, CFG.GEMINI.TOPK).map(x=>x.sym);
  for (const sym of pick){
    await analyzeOne(sym);
  }
}

/* ===================== UI BINDINGS ===================== */
document.getElementById('saveKeyBtn').onclick = saveGeminiKey;
document.getElementById('clearKeyBtn').onclick = clearGeminiKey;
document.getElementById('resetBtn').onclick = () => location.reload();
document.getElementById('analyzeBtn').onclick = analyzeTop;

document.getElementById('testGeminiBtn').onclick = async () => {
  try{
    const key = getGeminiKey();
    if(!key) return alert("å…ˆè²¼ä¸Š Gemini key å†æ¸¬è©¦ï¼ˆå¯æŒ‰ Saveï¼‰");

    const url = `https://generativelanguage.googleapis.com/v1beta/models/${CFG.GEMINI.MODEL}:generateContent`;
    const res = await fetch(url,{
      method:"POST",
      headers:{ "Content-Type":"application/json", "x-goog-api-key": key },
      body: JSON.stringify({
        contents:[{role:"user",parts:[{text:`åªå›å‚³JSONï¼š{"ok":true,"ts":${nowMs()}}`}]}],
        generationConfig:{ temperature:0.1, max_output_tokens: 80, response_mime_type:"application/json" }
      })
    });

    const t = await res.text();
    console.log("Gemini test raw:", t);

    if(!res.ok) return alert(`Gemini FAIL: HTTP ${res.status}ï¼ˆçœ‹ Consoleï¼‰`);
    alert("Gemini OK âœ…ï¼ˆçœ‹ Console å¯ç¢ºèªå›æ‡‰ï¼‰");
  }catch(e){
    alert("Gemini error: " + e.message);
  }
};

// init key
(function initKey(){
  const k = localStorage.getItem('GEMINI_API_KEY') || "";
  if (k) document.getElementById('geminiKey').value = k;
})();

/* ===================== BOOT ===================== */
(async function main(){
  try{
    await loadUniverse();
  }catch(e){
    document.getElementById('status').innerText = `status: exchangeInfo å¤±æ•—: ${e.message}`;
    return;
  }

  connectMark();

  // sample every second
  setInterval(sampleMetrics, 1000);

  // pipeline every 15s
  setInterval(() => { tickPipeline().catch(()=>{}); }, 15_000);

  // render every 1s
  setInterval(render, 1000);

  // auto Gemini: only when key exists & displayList ready
  setInterval(() => {
    const key = getGeminiKey();
    if (!key) return;
    if (displayList.length < 3) return;

    const now = nowMs();
    if (now - lastAutoGeminiAt < CFG.GEMINI.AUTO_INTERVAL_MS) return;

    // only rerun when top set changed OR locked changed
    const topHash = hashStr(displayList.slice(0, CFG.GEMINI.TOPK).map(x=>x.sym).join('|') + '|' + (lockedSym||''));
    if (topHash === lastTopHashGemini) return;

    lastAutoGeminiAt = now;
    lastTopHashGemini = topHash;

    analyzeTop();
  }, CFG.GEMINI.AUTO_CHECK_MS);

})();
</script>
</body>
</html>
