<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRIDENT V7 â€” Long-only Anomaly Scanner + Gemini</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    :root{ color-scheme: dark; }
    body{ font-family:'JetBrains Mono',monospace; background:#050505; color:#d4d4d8; }
    .card{ background:#0f0f11; border:1px solid #1f1f23; }
    .muted{ color:#71717a; }
    .badge{ border:1px solid rgba(255,255,255,.08); background:rgba(255,255,255,.04); }
    .badge-setup{ background:rgba(245,158,11,.12); border-color:rgba(245,158,11,.30); color:#fbbf24; }
    .badge-ignite{ background:rgba(249,115,22,.12); border-color:rgba(249,115,22,.30); color:#fb923c; }
    .badge-confirm{ background:rgba(34,197,94,.12); border-color:rgba(34,197,94,.30); color:#34d399; }
    .badge-leader{ background:rgba(59,130,246,.12); border-color:rgba(59,130,246,.30); color:#60a5fa; }
    .mono{ font-family:'JetBrains Mono',monospace; }
    .grid-3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:.5rem; }
    .grid-2{ display:grid; grid-template-columns: 1fr 1fr; gap:.5rem; }
    .k{ color:#a1a1aa; font-size:11px; }
    .v{ color:#e5e7eb; font-size:11px; }
    .aiBox{ background:#0a0a0c; border:1px solid #1f1f23; }
    .okDot{ width:8px;height:8px;border-radius:999px; display:inline-block; margin-right:.5rem; }
    .dotOn{ background:#22c55e; box-shadow:0 0 10px #22c55e; }
    .dotOff{ background:#52525b; }
    .thinScroll::-webkit-scrollbar{ width:10px; }
    .thinScroll::-webkit-scrollbar-thumb{ background:#202026; border-radius:999px; }
    .thinScroll::-webkit-scrollbar-thumb:hover{ background:#2a2a33; }
    .btn{ border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.05); }
    .btn:hover{ background:rgba(255,255,255,.10); }
    .btnPrimary{ background:rgba(37,99,235,.35); border-color:rgba(37,99,235,.55); }
    .btnPrimary:hover{ background:rgba(37,99,235,.55); }
    .btnGreen{ background:rgba(16,185,129,.25); border-color:rgba(16,185,129,.45); }
    .btnGreen:hover{ background:rgba(16,185,129,.40); }
    .btnRed{ background:rgba(239,68,68,.18); border-color:rgba(239,68,68,.45); }
    .btnRed:hover{ background:rgba(239,68,68,.30); }
    .inp{ background:#0b0b0d; border:1px solid rgba(255,255,255,.12); color:#fff; }
    .inp:focus{ outline:none; border-color:rgba(59,130,246,.7); box-shadow:0 0 0 3px rgba(59,130,246,.15); }
  </style>
</head>

<body class="p-4">
  <!-- Top Bar -->
  <div class="flex flex-col gap-3">
    <div class="flex items-center justify-between gap-3">
      <div class="flex items-center gap-3">
        <span id="hb" class="okDot dotOff"></span>
        <div>
          <div class="text-white font-black italic text-xl leading-none">TRIDENT <span class="text-blue-400">V7</span></div>
          <div class="muted text-[10px] font-bold tracking-widest uppercase">Long-only anomaly scanner â†’ Top5 â†’ Gemini (Top3)</div>
        </div>
      </div>

      <div class="flex items-center gap-2 flex-wrap justify-end">
        <div class="flex items-center gap-2">
          <input id="keyInput" type="password" class="inp text-[11px] px-2 py-1 rounded w-[280px]" placeholder="è²¼ä¸Š Gemini API Keyï¼ˆåªå­˜åœ¨ä½ çš„ç€è¦½å™¨ localStorageï¼‰" />
          <button id="toggleKeyBtn" class="btn text-[11px] px-2 py-1 rounded">ğŸ‘</button>
          <button id="saveKeyBtn" class="btnGreen text-[11px] px-3 py-1 rounded font-bold">Save</button>
          <button id="clearKeyBtn" class="btnRed text-[11px] px-3 py-1 rounded font-bold">Clear</button>
        </div>

        <button id="testGeminiBtn" class="btnGreen text-[11px] px-3 py-1 rounded font-bold">Test Gemini</button>
        <button id="analyzeTopBtn" class="btnPrimary text-[11px] px-3 py-1 rounded font-bold">Analyze Top (Gemini)</button>
        <button id="resetBtn" class="btn text-[11px] px-3 py-1 rounded font-bold">RESET</button>
      </div>
    </div>

    <div class="flex items-center justify-between text-[11px] muted">
      <div class="flex items-center gap-3 flex-wrap">
        <span id="keyStatus">Keyï¼šæœªè¼‰å…¥</span>
        <span id="geminiStatus">Geminiï¼š-</span>
        <span id="scanStatus">æƒæï¼š-</span>
        <span id="quotaStatus">Backoffï¼š-</span>
      </div>
      <div class="flex items-center gap-3">
        <label class="flex items-center gap-2 cursor-pointer select-none">
          <input id="autoToggle" type="checkbox" class="accent-blue-500" checked />
          <span>Autoï¼ˆ2 åˆ†é˜ / Top3 / çºŒåŠ›æ‰æ‰“ï¼‰</span>
        </label>
        <span id="clock">æ›´æ–°ï¼š-</span>
      </div>
    </div>
  </div>

  <!-- Main -->
  <div class="mt-4 grid grid-cols-1 gap-4">
    <div class="card rounded-xl p-4">
      <div class="flex items-center justify-between mb-2">
        <div class="text-white font-black">Top 5 å€™é¸ï¼ˆæœ€å¼·é–å®šç½®é ‚ï¼‰</div>
        <div class="muted text-[11px]" id="weightsHint"></div>
      </div>
      <div id="top5" class="flex flex-col gap-3"></div>
    </div>
  </div>

<script>
/** =========================
 *  0) å®‰å…¨æé†’ï¼ˆä¸è¦æŠŠ key commitï¼‰
 * ========================= */
(function(){
  // ä¸åš alert æ“¾äººï¼Œæ”¹ç”¨ç‹€æ…‹åˆ—æç¤ºå³å¯
})();

/** =========================
 *  1) è¨­å®šå€
 * ========================= */
const CFG = {
  // Binance
  WS_MINI: "wss://fstream.binance.com/ws/!miniTicker@arr",
  WS_MARK: "wss://fstream.binance.com/ws/!markPrice@arr@1s",
  WS_BASE: "wss://fstream.binance.com/stream?streams=",
  HTTP: "https://fapi.binance.com",

  // Universe / Refresh
  UNIVERSE_N: 90,               // å€™é¸æ± ï¼ˆé top25 çš„é«˜æµå‹•åˆç´„ï¼‰
  TOP_N: 5,
  ANALYZE_TOPK: 3,
  AUTO_EVERY_MS: 120000,        // 2 åˆ†é˜
  RENDER_EVERY_MS: 1000,
  OI_REFRESH_MS: 120000,        // OI æ­·å² 2 åˆ†é˜æŠ“ä¸€æ¬¡ï¼ˆåªæŠ“ Top å€™é¸ï¼‰
  MAX_STREAMS_PER_WS: 60,       // aggTrade åˆä½µ streams æ•¸ï¼ˆé¿å… URL å¤ªé•·ï¼‰
  MIN_TRADES_FOR_READY: 80,     // ç†±æ©Ÿåˆ¤å®šï¼ˆ5m å…§è‡³å°‘å¤šå°‘æˆäº¤ç­†ï¼‰
  WARMUP_MIN: 12,               // é¡¯ç¤ºç”¨ï¼šè‡³å°‘ç´¯ç©å¹¾åˆ†é˜ candle æ‰ç®—ã€Œæ¯”è¼ƒå¯ç”¨ã€

  // Gemini
  GEMINI_MODEL: "gemini-2.5-flash",
  GEMINI_MAX_OUT: 420,
  GEMINI_TEMP: 0.25,
  GEMINI_TOPK: 32,

  // é–æ¦œ
  LEADER_SWAP_DELTA: 6,         // æ–°ç‹è¦æ¯”èˆŠç‹è‡³å°‘å¤š 6 åˆ†æ‰æ›ï¼ˆé¿å…è·³æ¦œï¼‰
  LEADER_MIN_HOLD_MS: 45000,    // è‡³å°‘æŒæœ‰ 45 ç§’
  TOPLIST_HYSTERESIS_MS: 25000, // Top5 åˆ—è¡¨é–å®šæ™‚é–“

  // åªåšå¤šï¼šåè¿½é«˜ï¼ˆanti-chaseï¼‰
  MAX_RET5M_PCT: 1.10,          // 5 åˆ†é˜æ¼²å¹…å¤ªå¤§å°±ä¸è¿½
  MAX_DIST_MA20_ATR: 1.6,       // è·é›¢ MA20 è¶…é 1.6 ATR è¦–ç‚ºå¤ªè¿½
  MIN_BUY_RATIO: 0.55,          // 5m ä¸»å‹•è²·ä½”æ¯”è‡³å°‘ 55%
};

// å¸‚å€¼å‰ 25ï¼ˆå¤§æ¦‚åå–®ï¼Œå¤ ç”¨ï¼›ä½ å¯è‡ªè¡Œèª¿æ•´ï¼‰
// ç›®çš„ï¼šä¸æƒæã€Œå¸‚å ´å‰æ®µç­ã€ï¼Œå°ˆæŠ“ç•°å¸¸å°ä¸­å‹ã€‚
const EXCLUDE_MCAP25 = new Set([
  "BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TRXUSDT","TONUSDT",
  "AVAXUSDT","DOTUSDT","MATICUSDT","LINKUSDT","BCHUSDT","LTCUSDT","ATOMUSDT","ETCUSDT","XLMUSDT",
  "ICPUSDT","APTUSDT","FILUSDT","HBARUSDT","NEARUSDT","ARBUSDT","OPUSDT"
]);

// æ¬Šé‡ï¼ˆæœƒé¡¯ç¤ºåœ¨ UI å³ä¸Šè§’ï¼‰
const WEIGHTS = {
  squeeze: 0.22,   // æ”¶æ–‚è“„å‹¢
  delta:  0.26,    // ä¸»å‹•è²·å…¥å·®é¡ï¼ˆ5mï¼‰
  oi:     0.22,    // OI ç•°å¸¸ï¼ˆ5m / 4hï¼‰
  vol:    0.18,    // æˆäº¤é‡ç•°å¸¸ï¼ˆ5mï¼‰
  prem:   0.12,    // æº¢åƒ¹ / funding æ–œç‡
};
document.getElementById("weightsHint").innerText =
  `æ¬Šé‡ï¼šæ”¶æ–‚${Math.round(WEIGHTS.squeeze*100)}%ï½œä¸»å‹•è²·å·®${Math.round(WEIGHTS.delta*100)}%ï½œOI${Math.round(WEIGHTS.oi*100)}%ï½œé‡${Math.round(WEIGHTS.vol*100)}%ï½œæº¢åƒ¹${Math.round(WEIGHTS.prem*100)}%`;

/** =========================
 *  2) å°å·¥å…·
 * ========================= */
const $ = (id)=>document.getElementById(id);
const now = ()=>Date.now();

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function pct(x){ return (x*100); }
function fmtN(x, d=2){
  if (x===null || x===undefined || Number.isNaN(x)) return "-";
  const n = Number(x);
  if (!Number.isFinite(n)) return "-";
  return n.toFixed(d);
}
function fmtInt(x){
  if (x===null || x===undefined || Number.isNaN(x)) return "-";
  const n = Number(x);
  if (!Number.isFinite(n)) return "-";
  return Math.round(n).toLocaleString();
}
function fmtMoney(x){
  if (x===null || x===undefined || Number.isNaN(x)) return "-";
  const n = Number(x);
  if (!Number.isFinite(n)) return "-";
  // ä¸è¦å¤ªé•·
  if (Math.abs(n) >= 1e9) return (n/1e9).toFixed(2)+"B";
  if (Math.abs(n) >= 1e6) return (n/1e6).toFixed(2)+"M";
  if (Math.abs(n) >= 1e3) return (n/1e3).toFixed(2)+"K";
  return n.toFixed(0);
}
function mean(arr){
  if (!arr || arr.length===0) return 0;
  let s=0; for(const v of arr) s+=v;
  return s/arr.length;
}
function std(arr){
  if (!arr || arr.length<2) return 0;
  const m=mean(arr);
  let s=0; for(const v of arr) s+=(v-m)*(v-m);
  return Math.sqrt(s/(arr.length-1));
}
function zScore(x, arr){
  if (!arr || arr.length<10) return 0;
  const m=mean(arr);
  const sd=std(arr);
  if (sd===0) return 0;
  return (x-m)/sd;
}
function safeJsonParseText(text){
  // æ‰¾ç¬¬ä¸€å€‹ { åˆ°æœ€å¾Œä¸€å€‹ }ï¼Œé¿å…æ¨¡å‹å‰å¾Œå¤šå­—
  if (typeof text !== "string") return null;
  let t = text.trim();
  // å» code fence
  if (t.startsWith("```")) {
    t = t.replace(/^```[a-zA-Z]*\n?/,"").replace(/```$/,"").trim();
  }
  const a = t.indexOf("{");
  const b = t.lastIndexOf("}");
  if (a>=0 && b>a) {
    const core = t.slice(a, b+1);
    try { return JSON.parse(core); } catch(e) { return null; }
  }
  try { return JSON.parse(t); } catch(e) { return null; }
}

/** =========================
 *  3) ç‹€æ…‹
 * ========================= */
const S = {
  universe: [],              // å€™é¸æ±  symbols
  sym: new Map(),            // symbol -> state
  wsMini: null,
  wsMark: null,
  wsAgg: [],                 // å¤šæ¢åˆä½µ ws
  lastHB: 0,
  leader: { symbol: null, score: 0, since: 0 },
  top5: [],
  top5LockedUntil: 0,
  geminiKey: "",
  geminiBackoffUntil: 0,
  aiCache: new Map(),        // symbol -> {ts, data, raw}
  aiCooldownMs: 20*60*1000,  // åŒå¹£ 20 åˆ†é˜å…§ä¸é‡è¤‡è‡ªå‹•æ‰“
  autoTimer: null,
  oiTimer: null,
  renderTimer: null,
  minuteTimer: null,
  lastMinute: null,
  lastTopAnalyze: 0,
};

/** =========================
 *  4) æ¯å¹£è³‡æ–™çµæ§‹
 * ========================= */
function makeSymState(symbol){
  return {
    symbol,
    price: null,
    markPrice: null,
    indexPrice: null,
    premiumPct: null,
    fundingPct: null,

    // aggTrade 5m æ»‘çª—ï¼ˆç§’æ¡¶ï¼‰
    secBuckets: new Map(), // sec -> {buy,sell,total,count}
    sumBuy: 0,
    sumSell: 0,
    sumTotal: 0,
    sumCount: 0,

    // 1m candlesï¼ˆç”¨ trades åˆæˆï¼‰
    curMin: null,
    curCandle: null, // {t,o,h,l,c,v,buy,sell}
    candles: [],      // æœ€æ–°åœ¨å°¾å·´ï¼Œæœ€å¤š 240
    closes: [],       // åªå­˜ closeï¼Œæœ€å¤š 240

    // 5m æŒ‡æ¨™æ­·å²ï¼ˆæ¯åˆ†é˜å–ä¸€æ¬¡ç•¶ä½œã€Œ5mçª—ã€ï¼‰
    hist_delta5m: [],
    hist_vol5m: [],
    hist_buyRatio5m: [],
    hist_premium: [],

    // OIï¼ˆHTTPï¼‰5m åºåˆ—ï¼ˆæœ€å¤š 100 é»ï¼‰
    oiSeries: null,     // array of {ts, oi}
    oi5m: null,
    oi4h: null,
    oiPrev4h: null,
    oiZ: 0,

    // è¨ˆç®—è¼¸å‡º
    ready: false,
    warmupMin: 0,
    ret5mPct: 0,
    ma20: null,
    atr20: null,
    squeezeZ: 0,
    deltaZ: 0,
    volZ: 0,
    buyRatio: 0,
    premSlopeZ: 0,
    stage: "WARMUP",  // SETUP / IGNITE / CONFIRM / WARMUP
    score: 0,
    tags: [],
    persist: { stageSince: 0, lastStage: "WARMUP" },
  };
}

/** =========================
 *  5) Binanceï¼šåˆå§‹åŒ– universe
 * ========================= */
async function fetchJson(url){
  const r = await fetch(url);
  const t = await r.text();
  let j=null;
  try{ j = JSON.parse(t); }catch(e){}
  return { ok:r.ok, status:r.status, json:j, raw:t };
}

async function initUniverse(){
  $("scanStatus").innerText = "æƒæï¼šåˆå§‹åŒ–ä¸­â€¦";
  // å…ˆæ‹¿ 24h tickerï¼ˆç”¨ quoteVolume æ’æµå‹•æ€§ï¼‰
  const {ok, json} = await fetchJson(`${CFG.HTTP}/fapi/v1/ticker/24hr`);
  if(!ok || !Array.isArray(json)){
    $("scanStatus").innerText = "æƒæï¼š24hr è®€å–å¤±æ•—";
    return;
  }
  const list = json
    .filter(x => x.symbol && x.symbol.endsWith("USDT"))
    .filter(x => !EXCLUDE_MCAP25.has(x.symbol))
    .sort((a,b)=> Number(b.quoteVolume||0)-Number(a.quoteVolume||0))
    .slice(0, CFG.UNIVERSE_N)
    .map(x=>x.symbol);

  S.universe = list;

  for(const sym of list){
    if(!S.sym.has(sym)) S.sym.set(sym, makeSymState(sym));
  }
  $("scanStatus").innerText = `æƒæï¼šUniverse=${S.universe.length}ï¼ˆå·²æ’é™¤å¸‚å€¼å‰ 25ï¼‰`;
}

/** =========================
 *  6) Binanceï¼šWSï¼ˆminiTicker/markPrice/aggTradeï¼‰
 * ========================= */
function setHB(on){
  const el = $("hb");
  el.className = `okDot ${on ? "dotOn":"dotOff"}`;
}
function startWS(){
  stopWS();

  // miniTicker: æ›´æ–° priceï¼ˆå…¨å¸‚å ´ï¼‰
  S.wsMini = new WebSocket(CFG.WS_MINI);
  S.wsMini.onmessage = (e)=>{
    S.lastHB = now();
    setHB(true);
    let arr;
    try{ arr = JSON.parse(e.data); }catch(err){ return; }
    if(!Array.isArray(arr)) return;
    for(const it of arr){
      const sym = it.s;
      if(!S.sym.has(sym)) continue;
      const st = S.sym.get(sym);
      st.price = Number(it.c);
    }
  };
  S.wsMini.onclose = ()=>setHB(false);
  S.wsMini.onerror = ()=>setHB(false);

  // markPrice: premium/fundingï¼ˆå…¨å¸‚å ´ï¼‰
  S.wsMark = new WebSocket(CFG.WS_MARK);
  S.wsMark.onmessage = (e)=>{
    S.lastHB = now();
    setHB(true);
    let arr;
    try{ arr = JSON.parse(e.data); }catch(err){ return; }
    if(!Array.isArray(arr)) return;
    for(const it of arr){
      const sym = it.s;
      if(!S.sym.has(sym)) continue;
      const st = S.sym.get(sym);
      st.markPrice = Number(it.p);
      st.indexPrice = Number(it.i);
      const prem = (st.indexPrice ? (st.markPrice - st.indexPrice) / st.indexPrice : 0);
      st.premiumPct = prem * 100;
      st.fundingPct = Number(it.r) * 100;
    }
  };
  S.wsMark.onclose = ()=>setHB(false);
  S.wsMark.onerror = ()=>setHB(false);

  // aggTrade: åªè¨‚é–± universeï¼ˆåˆä½µ streamsï¼Œæ‹†å¤šæ¢ WSï¼‰
  const streams = S.universe.map(s=>`${s.toLowerCase()}@aggTrade`);
  const chunks = [];
  for(let i=0;i<streams.length;i+=CFG.MAX_STREAMS_PER_WS){
    chunks.push(streams.slice(i,i+CFG.MAX_STREAMS_PER_WS));
  }
  S.wsAgg = chunks.map(ch=>{
    const url = CFG.WS_BASE + ch.join("/");
    const ws = new WebSocket(url);
    ws.onmessage = (e)=>{
      S.lastHB = now();
      setHB(true);
      let msg;
      try{ msg = JSON.parse(e.data); }catch(err){ return; }
      if(!msg || !msg.data) return;
      const d = msg.data;
      const sym = d.s;
      if(!S.sym.has(sym)) return;
      const st = S.sym.get(sym);

      const price = Number(d.p);
      const qty = Number(d.q);
      const ts = Number(d.T);
      const isBuyerMaker = !!d.m; // true = taker sell, false = taker buy
      onAggTrade(st, price, qty, isBuyerMaker, ts);
    };
    ws.onclose = ()=>{};
    ws.onerror = ()=>{};
    return ws;
  });
}

function stopWS(){
  try{ if(S.wsMini) S.wsMini.close(); }catch(e){}
  try{ if(S.wsMark) S.wsMark.close(); }catch(e){}
  for(const ws of (S.wsAgg||[])){
    try{ ws.close(); }catch(e){}
  }
  S.wsMini=null; S.wsMark=null; S.wsAgg=[];
  setHB(false);
}

function onAggTrade(st, price, qty, isBuyerMaker, ts){
  // notional ç”¨ USDT è¿‘ä¼¼ï¼šqty*price
  const notional = qty * price;
  const sec = Math.floor(ts/1000);
  const winStart = sec - 299;

  // bucket
  let b = st.secBuckets.get(sec);
  if(!b){
    b = { buy:0, sell:0, total:0, count:0 };
    st.secBuckets.set(sec, b);
  }
  const buyAdd = isBuyerMaker ? 0 : notional;
  const sellAdd = isBuyerMaker ? notional : 0;
  b.buy += buyAdd;
  b.sell += sellAdd;
  b.total += notional;
  b.count += 1;

  st.sumBuy += buyAdd;
  st.sumSell += sellAdd;
  st.sumTotal += notional;
  st.sumCount += 1;

  // cleanup old seconds
  for(const [k,v] of st.secBuckets){
    if(k < winStart){
      st.sumBuy -= v.buy;
      st.sumSell -= v.sell;
      st.sumTotal -= v.total;
      st.sumCount -= v.count;
      st.secBuckets.delete(k);
    }
  }

  // build 1m candle from trades
  const m = Math.floor(ts/60000);
  if(st.curMin === null){
    st.curMin = m;
    st.curCandle = { t:m*60000, o:price, h:price, l:price, c:price, v:notional, buy:buyAdd, sell:sellAdd };
  } else if(m === st.curMin){
    const c = st.curCandle;
    c.h = Math.max(c.h, price);
    c.l = Math.min(c.l, price);
    c.c = price;
    c.v += notional;
    c.buy += buyAdd;
    c.sell += sellAdd;
  } else if(m > st.curMin){
    // close previous
    finalizeCandle(st);
    // new
    st.curMin = m;
    st.curCandle = { t:m*60000, o:price, h:price, l:price, c:price, v:notional, buy:buyAdd, sell:sellAdd };
  }
}

function finalizeCandle(st){
  if(!st.curCandle) return;
  st.candles.push(st.curCandle);
  st.closes.push(st.curCandle.c);
  if(st.candles.length > 240) st.candles.shift();
  if(st.closes.length > 240) st.closes.shift();

  st.warmupMin = Math.min(CFG.WARMUP_MIN, st.candles.length);
  // æ¯æ”¶ä¸€æ ¹ candleï¼Œå°±æŠŠã€Œç•¶ä¸‹çš„ 5mçª—ã€æŒ‡æ¨™ push é€²æ­·å²ï¼ˆç”¨ä¾†ç®— zï¼‰
  const buy = st.sumBuy, sell = st.sumSell, tot = st.sumTotal;
  const delta = buy - sell;
  const buyRatio = tot > 0 ? (buy / tot) : 0;

  st.hist_delta5m.push(delta);
  st.hist_vol5m.push(tot);
  st.hist_buyRatio5m.push(buyRatio);
  st.hist_premium.push(st.premiumPct ?? 0);

  if(st.hist_delta5m.length > 240) st.hist_delta5m.shift();
  if(st.hist_vol5m.length > 240) st.hist_vol5m.shift();
  if(st.hist_buyRatio5m.length > 240) st.hist_buyRatio5m.shift();
  if(st.hist_premium.length > 240) st.hist_premium.shift();
}

/** =========================
 *  7) æŒ‡æ¨™è¨ˆç®—ï¼ˆåªåšå¤šï¼‰
 * ========================= */
function calcATR20(candles){
  if(!candles || candles.length < 21) return null;
  const trs = [];
  for(let i=1;i<candles.length;i++){
    const c = candles[i], p = candles[i-1];
    const tr = Math.max(c.h-c.l, Math.abs(c.h-p.c), Math.abs(c.l-p.c));
    trs.push(tr);
  }
  const last20 = trs.slice(-20);
  return mean(last20);
}

function calcMA(arr, n){
  if(!arr || arr.length < n) return null;
  const slice = arr.slice(-n);
  return mean(slice);
}

function calcRetPct(closes, n){
  if(!closes || closes.length < n+1) return 0;
  const a = closes[closes.length-1-n];
  const b = closes[closes.length-1];
  if(!a) return 0;
  return (b-a)/a*100;
}

function calcSqueezeZ(closes){
  // Bollinger bandwidth zï¼šè¶Šè² è¶Šæ”¶æ–‚
  if(!closes || closes.length < 40) return 0;
  const bwArr = [];
  for(let i=20;i<=closes.length;i++){
    const w = closes.slice(i-20, i);
    const m = mean(w);
    const sd = std(w);
    const up = m + 2*sd, dn = m - 2*sd;
    const bw = m ? ((up-dn)/m) : 0;
    bwArr.push(bw);
  }
  const cur = bwArr[bwArr.length-1];
  const base = bwArr.slice(0, -1);
  return zScore(cur, base) * 1.0; // è² å€¼è¡¨ç¤ºæ›´æ“ 
}

function calcSlopeZ(arr){
  // ç”¨æœ€å¾Œ 6 é»ï¼ˆç´„ 6 åˆ†é˜ï¼‰åšæ–œç‡ï¼Œå’Œæ­·å²æ–œç‡æ¯” z
  if(!arr || arr.length < 30) return 0;
  function slope(seq){
    const n=seq.length;
    const xs = Array.from({length:n}, (_,i)=>i);
    const xM = mean(xs), yM = mean(seq);
    let num=0, den=0;
    for(let i=0;i<n;i++){
      num += (xs[i]-xM)*(seq[i]-yM);
      den += (xs[i]-xM)*(xs[i]-xM);
    }
    return den ? num/den : 0;
  }
  const w = 6;
  const slopes = [];
  for(let i=w;i<=arr.length;i++){
    const seg = arr.slice(i-w,i);
    slopes.push(slope(seg));
  }
  const cur = slopes[slopes.length-1];
  const base = slopes.slice(0,-1);
  return zScore(cur, base);
}

function updateScores(){
  // æ¯ç§’/æ¯æ ¹ candle éƒ½å¯ç®—ï¼Œä½†é€™è£¡ç”¨æ¯ç§’ render å‰ç®—ä¸€æ¬¡å°±å¥½
  for(const sym of S.universe){
    const st = S.sym.get(sym);
    if(!st) continue;

    // readyï¼š5m å…§æˆäº¤ç­†æ•¸å¤  + è‡³å°‘æœ‰ä¸€äº› candles
    st.ready = (st.sumCount >= CFG.MIN_TRADES_FOR_READY) && (st.candles.length >= 10);

    // åŸºæœ¬ 5m æŒ‡æ¨™
    const buy = st.sumBuy, sell = st.sumSell, tot = st.sumTotal;
    const delta = buy - sell;
    const buyRatio = tot > 0 ? (buy / tot) : 0;
    st.buyRatio = buyRatio;

    // 5m æ¼²å¹…ï¼ˆç”¨ closes æ¨ä¼°ï¼‰
    st.ret5mPct = calcRetPct(st.closes, 5);

    // MA/ATRï¼ˆanti-chaseï¼‰
    st.ma20 = calcMA(st.closes, 20);
    st.atr20 = calcATR20(st.candles);

    // æ”¶æ–‚æŒ‡æ¨™
    st.squeezeZ = calcSqueezeZ(st.closes);

    // é‡/å·®é¡ zï¼ˆç›¸å°è‡ªå·±éå»ï¼‰
    st.deltaZ = zScore(delta, st.hist_delta5m.slice(0,-1));
    st.volZ   = zScore(tot, st.hist_vol5m.slice(0,-1));

    // premium slope z
    st.premSlopeZ = calcSlopeZ(st.hist_premium);

    // OI zï¼ˆè‹¥æœ‰ï¼‰
    // st.oiZ å·²åœ¨ OI æ›´æ–°æ™‚è¨ˆç®—

    // anti-chaseï¼šè·é›¢ MA20 çš„ ATR å€æ•¸
    let distMaAtr = 0;
    if(st.ma20 && st.atr20 && st.atr20>0 && st.price){
      distMaAtr = Math.abs(st.price - st.ma20) / st.atr20;
    }

    // é•·è¶¨å‹¢ç°¡æ˜“æ¿¾ç¶²ï¼šè¿‘ 20m å›æ’¤ä¸è¦å¤ªå·®
    const ret20m = calcRetPct(st.closes, 20);

    // åªåšå¤šï¼šå¿…è¦æ¢ä»¶
    const longOk =
      buyRatio >= CFG.MIN_BUY_RATIO &&
      delta > 0 &&
      ret20m > -0.8; // ä¸è¦åœ¨æ˜é¡¯ä¸‹è·Œè¶¨å‹¢ç¡¬æ’¿

    // åè¿½é«˜
    const chaseBad =
      (st.ret5mPct > CFG.MAX_RET5M_PCT) ||
      (distMaAtr > CFG.MAX_DIST_MA20_ATR);

    // stage åˆ¤æ–·ï¼ˆğŸŸ¨ğŸŸ§ğŸŸ©ï¼‰
    let stage = "WARMUP";
    const warmEnough = st.candles.length >= CFG.WARMUP_MIN;

    const setup =
      warmEnough &&
      longOk &&
      !chaseBad &&
      st.squeezeZ < -0.7 &&     // æ”¶æ–‚
      st.volZ > -0.3;           // é‡ä¸è¦å®Œå…¨æ­»æ°´ï¼ˆä½†ä¸è¦æ±‚çˆ†é‡ï¼‰

    const ignite =
      setup &&
      st.volZ > 0.7 &&          // é‡æ”¾å¤§ï¼ˆç›¸å°è‡ªå·±ï¼‰
      st.deltaZ > 0.7 &&        // ä¸»å‹•è²·å·®é¡ç•°å¸¸
      (st.oiZ > 0.4 || st.oi4h !== null) && // æœ‰ OI æ”¯æ’ï¼ˆæ²’æŠ“åˆ°ä¹Ÿä¸ç›´æ¥åˆ¤æ­»ï¼‰
      st.ret5mPct < CFG.MAX_RET5M_PCT;

    const confirm =
      ignite &&
      st.volZ > 1.3 &&
      st.deltaZ > 1.2 &&
      st.ret5mPct > 0.15; // å·²é–‹å§‹è¡¨æ…‹ä½†é‚„æ²’å™´å¾ˆé 

    if(confirm) stage = "CONFIRM";
    else if(ignite) stage = "IGNITE";
    else if(setup) stage = "SETUP";
    else stage = warmEnough ? "WARMUP" : "WARMUP";

    // tagsï¼ˆçµ¦ Gemini ç”¨ï¼‰
    const tags = [];
    if(st.squeezeZ < -0.8) tags.push("æ”¶æ–‚è“„å‹¢");
    if(st.deltaZ > 1.0) tags.push("ä¸»å‹•è²·å…¥ç•°å¸¸");
    if(st.volZ > 1.0) tags.push("æˆäº¤é‡ç•°å¸¸");
    if(st.premSlopeZ > 0.8) tags.push("æº¢åƒ¹èµ°å¼·");
    if(st.fundingPct !== null && st.fundingPct > 0.02) tags.push("è³‡é‡‘è²»ç‡åå¤š");
    if(chaseBad) tags.push("è¿½é«˜é¢¨éšª");
    if(ret20m < -0.3) tags.push("çŸ­ç·šåå¼±");

    st.tags = tags;
    st.stage = stage;

    // persistï¼ˆçºŒåŠ›åˆ¤æ–·ï¼‰
    if(st.persist.lastStage !== stage){
      st.persist.lastStage = stage;
      st.persist.stageSince = now();
    }

    // scoreï¼ˆ0~100ï¼‰
    // æ³¨æ„ï¼šsqueezeZ è¶Šè² è¶Šå¥½ â†’ è½‰æˆæ­£åˆ†ï¼š(-squeezeZ)
    const s_squeeze = clamp((-st.squeezeZ)/2.5, 0, 1);
    const s_delta   = clamp((st.deltaZ)/2.5, 0, 1);
    const s_oi      = clamp((st.oiZ)/2.5, 0, 1);
    const s_vol     = clamp((st.volZ)/2.5, 0, 1);
    const s_prem    = clamp((st.premSlopeZ)/2.5, 0, 1);

    let score =
      100 * (
        WEIGHTS.squeeze*s_squeeze +
        WEIGHTS.delta*s_delta +
        WEIGHTS.oi*s_oi +
        WEIGHTS.vol*s_vol +
        WEIGHTS.prem*s_prem
      );

    // æ‡²ç½°ï¼šè¿½é«˜ / ä¸‹è·Œ
    if(!longOk) score *= 0.45;
    if(chaseBad) score *= 0.70;
    if(ret20m < -0.6) score *= 0.70;

    // stage boostï¼ˆè®“æ¦œæ›´åƒä½ è¦çš„ã€Œå™´å‰æç¤ºã€ï¼‰
    if(stage==="SETUP") score += 4;
    if(stage==="IGNITE") score += 10;
    if(stage==="CONFIRM") score += 16;

    st.score = clamp(score, 0, 100);
  }
}

/** =========================
 *  8) OIï¼ˆåªæŠ“ Top å€™é¸ï¼Œé¿å… HTTP å£“åŠ›ï¼‰
 * ========================= */
async function refreshOIFor(symbol){
  // fapi openInterestHist
  const url = `${CFG.HTTP}/futures/data/openInterestHist?symbol=${symbol}&period=5m&limit=100`;
  const {ok, json} = await fetchJson(url);
  if(!ok || !Array.isArray(json) || json.length<10) return;

  const st = S.sym.get(symbol);
  if(!st) return;

  // json element: {sumOpenInterest, timestamp, ...}ï¼ˆå¯èƒ½æ¬„ä½åç•¥ä¸åŒï¼‰
  const series = json.map(x=>{
    const oi = Number(x.sumOpenInterest ?? x.openInterest ?? x.sumOpenInterestValue ?? 0);
    const ts = Number(x.timestamp ?? x.time ?? 0);
    return {ts, oi};
  }).filter(x=>x.ts && Number.isFinite(x.oi));

  if(series.length < 10) return;
  st.oiSeries = series;

  const last = series[series.length-1].oi;
  const prev = series[series.length-2].oi;
  const ago4h = series[Math.max(0, series.length-1-48)].oi; // 48*5m = 240m = 4h
  const ago8h = series[Math.max(0, series.length-1-96)].oi;

  st.oi5m = last - prev;
  st.oi4h = last - ago4h;
  st.oiPrev4h = ago4h - ago8h;

  // OI Zï¼šç”¨ 5m è®ŠåŒ– vs éå» 4h çš„ 5m è®ŠåŒ–
  const deltas = [];
  for(let i=1;i<series.length;i++){
    deltas.push(series[i].oi - series[i-1].oi);
  }
  const cur = deltas[deltas.length-1];
  const base = deltas.slice(0,-1);
  st.oiZ = zScore(cur, base);
}

async function oiLoop(){
  // åªæŠ“ Top 8ï¼ˆé¿å…éé‡ï¼‰
  const top = [...S.top5].slice(0, 8);
  for(const st of top){
    try{ await refreshOIFor(st.symbol); }catch(e){}
  }
}

/** =========================
 *  9) Top5ï¼ˆå«é–æ¦œ/æœ€å¼·ç½®é ‚ï¼‰
 * ========================= */
function computeTop5(){
  // å…ˆç”¨åˆ†æ•¸æŒ‘ï¼ˆåªè¦æœ‰é»äº¤æ˜“é‡/è³‡æ–™ï¼‰
  let arr = [];
  for(const sym of S.universe){
    const st = S.sym.get(sym);
    if(!st) continue;
    if(!st.ready) continue;
    // åªåšå¤šï¼šä¸æŠŠæ˜é¡¯åç©ºçš„æ¨ä¸Šæ¦œï¼ˆä»å¯é¡¯ç¤ºï¼Œä½†åˆ†æ•¸æœƒå¾ˆä½ï¼‰
    arr.push(st);
  }
  arr.sort((a,b)=>b.score - a.score);

  // Top5 åŸºç¤
  let top = arr.slice(0, CFG.TOP_N);

  // æœ€å¼·ç½®é ‚é–å®š
  const best = top[0] || null;
  const t = now();
  if(best){
    if(!S.leader.symbol){
      S.leader = { symbol: best.symbol, score: best.score, since: t };
    } else {
      const leaderSt = S.sym.get(S.leader.symbol);
      const leaderAlive = leaderSt && leaderSt.ready;
      const heldLongEnough = (t - S.leader.since) >= CFG.LEADER_MIN_HOLD_MS;
      const challengerBetter = (best.symbol !== S.leader.symbol) && (best.score >= (S.leader.score + CFG.LEADER_SWAP_DELTA));

      if(!leaderAlive){
        S.leader = { symbol: best.symbol, score: best.score, since: t };
      } else if(heldLongEnough && challengerBetter){
        S.leader = { symbol: best.symbol, score: best.score, since: t };
      } else {
        // æ›´æ–° leader scoreï¼ˆé¿å…ä¸€ç›´ç”¨èˆŠåˆ†ï¼‰
        if(leaderSt) S.leader.score = leaderSt.score;
      }
    }
  }

  // æŠŠ leader æ’åˆ°æœ€å‰ï¼ˆå¦‚æœ leader ä¸åœ¨ topï¼Œå°±æŠŠå®ƒå¡é€²ä¾†å–ä»£æœ€å¾Œä¸€å€‹ï¼‰
  if(S.leader.symbol){
    const leaderIn = top.find(x=>x.symbol===S.leader.symbol);
    if(!leaderIn){
      const leaderSt = S.sym.get(S.leader.symbol);
      if(leaderSt && leaderSt.ready){
        top[top.length-1] = leaderSt;
      }
    }
    // ç½®é ‚
    top.sort((a,b)=>{
      if(a.symbol===S.leader.symbol) return -1;
      if(b.symbol===S.leader.symbol) return 1;
      return b.score - a.score;
    });
  }

  // Top5 åˆ—è¡¨é–ï¼ˆé¿å…ä¸€ç›´è·³ï¼‰
  if(t < S.top5LockedUntil && S.top5.length){
    // è‹¥ leader é‚„æ´»è‘—å°±æ²¿ç”¨èˆŠ top5ï¼Œä½†æ›´æ–°å¼•ç”¨ï¼ˆåˆ†æ•¸/æ•¸å€¼æœƒè·Ÿè‘—è®Šï¼‰
    const locked = [];
    for(const old of S.top5){
      const cur = S.sym.get(old.symbol);
      if(cur && cur.ready) locked.push(cur);
    }
    // ä¸è¶³å°±è£œ
    for(const st of top){
      if(locked.length>=CFG.TOP_N) break;
      if(!locked.find(x=>x.symbol===st.symbol)) locked.push(st);
    }
    S.top5 = locked.slice(0, CFG.TOP_N);
  } else {
    S.top5 = top;
    S.top5LockedUntil = t + CFG.TOPLIST_HYSTERESIS_MS;
  }
}

/** =========================
 *  10) Geminiï¼ˆä¿®æ­£ï¼šTest ç”¨è‡ªå·±çš„ schemaï¼›äº¤æ˜“åˆ†æç”¨äº¤æ˜“ schemaï¼‰
 * ========================= */
function setGeminiStatus(msg){ $("geminiStatus").innerText = "Geminiï¼š" + msg; }

function getGeminiKey(){
  return (S.geminiKey || "").trim();
}

// Trading schemaï¼ˆä½ è¦çš„ï¼šåˆ†æ•¸ã€é€²å ´ã€åœæã€ç‹€æ…‹ã€é ä¼°è¡¨æ…‹åˆ†é˜å€é–“ï¼‰
function geminiTradeSchema(){
  return {
    type: "object",
    properties: {
      symbol: { type: "string" },
      direction: { type: "string", enum: ["LONG","WAIT"] },
      confidence: { type: "integer", minimum: 0, maximum: 100 },
      etaMinutes: {
        type: "object",
        properties: {
          min: { type: "integer", minimum: 0, maximum: 60 },
          max: { type: "integer", minimum: 0, maximum: 60 }
        },
        required: ["min","max"]
      },
      stage: { type: "string", enum: ["SETUP","IGNITE","CONFIRM"] },
      pattern: { type: "string" },
      entry: {
        type: "object",
        properties: {
          type: { type: "string", enum: ["market","breakout","pullback","wait"] },
          price: { type: "number" },
          logic: { type: "string" }
        },
        required: ["type","price","logic"]
      },
      stop: {
        type: "object",
        properties: {
          price: { type: "number" },
          logic: { type: "string" }
        },
        required: ["price","logic"]
      },
      takeProfits: {
        type: "array",
        items: {
          type: "object",
          properties: {
            price: { type: "number" },
            portionPct: { type: "integer", minimum: 1, maximum: 100 },
            logic: { type: "string" }
          },
          required: ["price","portionPct","logic"]
        },
        minItems: 1,
        maxItems: 3
      },
      invalidation: { type: "string" },
      reasons: { type: "array", items: { type:"string" }, minItems: 2, maxItems: 6 }
    },
    required: ["symbol","direction","confidence","etaMinutes","stage","pattern","entry","stop","takeProfits","invalidation","reasons"]
  };
}

// Test schemaï¼ˆé¿å…ä½ ä¹‹å‰é‚£å€‹ã€Œ200 ä½†æ²’ JSONã€ï¼‰
function geminiTestSchema(){
  return {
    type:"object",
    properties:{
      ok:{ type:"boolean" },
      msg:{ type:"string" }
    },
    required:["ok","msg"]
  };
}

async function geminiCall({prompt, schema, maxOut=CFG.GEMINI_MAX_OUT}){
  const key = getGeminiKey();
  if(!key) return { ok:false, err:"NO_KEY" };

  if(now() < S.geminiBackoffUntil){
    const left = Math.ceil((S.geminiBackoffUntil - now())/1000);
    return { ok:false, err:`BACKOFF_${left}s` };
  }

  const url = `https://generativelanguage.googleapis.com/v1beta/models/${CFG.GEMINI_MODEL}:generateContent?key=${encodeURIComponent(key)}`;

  const body = {
    contents: [{ role:"user", parts:[{ text: prompt }]}],
    generationConfig: {
      temperature: CFG.GEMINI_TEMP,
      topK: CFG.GEMINI_TOPK,
      maxOutputTokens: maxOut,
      responseMimeType: "application/json",
      responseSchema: schema
    }
  };

  let resp, txt, data;
  try{
    resp = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    txt = await resp.text();
    try{ data = JSON.parse(txt); }catch(e){ data = null; }
  }catch(e){
    return { ok:false, err:"NETWORK", raw:String(e) };
  }

  // 429 backoff
  if(resp.status === 429){
    // å…ˆé€€ 90 ç§’ï¼Œå†é€æ¬¡å»¶é•·ï¼ˆç°¡åŒ–ï¼‰
    const back = 90*1000;
    S.geminiBackoffUntil = now() + back;
    $("quotaStatus").innerText = `Backoffï¼š429 â†’ ${Math.ceil(back/1000)}s`;
    return { ok:false, err:"HTTP_429", raw:txt };
  }

  if(!resp.ok){
    return { ok:false, err:`HTTP_${resp.status}`, raw:txt };
  }

  // æ­£å¸¸ï¼šå– candidates[0].content.parts[0].text
  let modelText = "";
  try{
    modelText = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
  }catch(e){ modelText = ""; }

  // å¦‚æœ parts æ²’ textï¼Œç›´æ¥æŠŠæ•´åŒ… txt ç•¶ rawï¼ˆæ–¹ä¾¿é™¤éŒ¯ï¼‰
  const parsed = safeJsonParseText(modelText || txt);
  if(!parsed){
    console.log("Gemini RAW (HTTP200 but parse fail):", txt);
    console.log("Gemini extracted modelText:", modelText);
    return { ok:false, err:"NO_VALID_JSON", raw: (modelText || txt) };
  }
  return { ok:true, data: parsed, raw: (modelText || txt) };
}

/** =========================
 *  11) Gemini Promptï¼ˆç²¾ç°¡æ‘˜è¦ï¼Œä¸ä¸Ÿæ•´åŒ… K ç·šï¼‰
 * ========================= */
function buildCandidateSummary(st){
  const distMaAtr = (st.ma20 && st.atr20 && st.atr20>0 && st.price)
    ? (Math.abs(st.price - st.ma20)/st.atr20)
    : null;

  return {
    symbol: st.symbol,
    price: st.price,
    stage: st.stage,
    score: Math.round(st.score),
    squeezeZ: Number(st.squeezeZ.toFixed(2)),
    delta5mUSDT: Math.round((st.sumBuy - st.sumSell)),
    deltaZ: Number(st.deltaZ.toFixed(2)),
    buyRatio5m: Number(st.buyRatio.toFixed(3)),
    vol5mUSDT: Math.round(st.sumTotal),
    volZ: Number(st.volZ.toFixed(2)),
    ret5mPct: Number(st.ret5mPct.toFixed(2)),
    premiumPct: Number((st.premiumPct ?? 0).toFixed(3)),
    fundingPct: Number((st.fundingPct ?? 0).toFixed(4)),
    premSlopeZ: Number(st.premSlopeZ.toFixed(2)),
    oi5m: st.oi5m===null? null : Number(st.oi5m.toFixed(2)),
    oi4h: st.oi4h===null? null : Number(st.oi4h.toFixed(2)),
    oiZ: Number((st.oiZ ?? 0).toFixed(2)),
    distMA20_ATR: distMaAtr===null? null : Number(distMaAtr.toFixed(2)),
    tags: st.tags.slice(0,6)
  };
}

function buildGeminiPromptForOne(st){
  const s = buildCandidateSummary(st);
  return [
`ä½ æ˜¯åˆç´„äº¤æ˜“è¼”åŠ©ï¼Œåªåšå¤šï¼ˆLONG-onlyï¼‰ã€‚`,
`æˆ‘æœƒçµ¦ä½ ã€Œå‰ç«¯å·²è¨ˆç®—å¥½çš„ç²¾ç°¡æ‘˜è¦ã€ï¼Œä¸è¦è¦æ±‚æ›´å¤šKç·šè³‡æ–™ã€‚`,
`ä»»å‹™ï¼šåˆ¤æ–·æ˜¯å¦å€¼å¾—åšå¤šï¼Œä¸¦çµ¦å‡ºå¯åŸ·è¡Œè¨ˆç•«ã€‚`,
`è¼¸å‡ºå¿…é ˆæ˜¯ã€Œå–®ä¸€ JSONã€ï¼Œä¸”å®Œå…¨ç¬¦åˆ schemaï¼Œä¸è¦å¤šä»»ä½•å­—ã€‚`,
``,
`ã€å¸‚å ´æ‘˜è¦ã€‘`,
JSON.stringify(s, null, 2),
``,
`ã€è¦å‰‡ã€‘`,
`- å¦‚æœä¸å»ºè­°åšå¤šï¼šdirection=WAITï¼Œconfidence çµ¦ä½ï¼Œentry.type=waitï¼›ä»è¦å¡« entry/stop/takeProfitsï¼ˆå¯ç”¨ç•¶å‰åƒ¹é™„è¿‘èˆ‡ä¿å®ˆï¼‰`,
`- etaMinutesï¼šé ä¼°å¹¾åˆ†é˜å…§å¯èƒ½ã€Œè¡¨æ…‹ã€ï¼ˆä¾‹å¦‚ 5~10ã€10~20ï¼‰`,
`- stage å¿…é ˆæ˜¯ SETUP / IGNITE / CONFIRMï¼ˆå°æ‡‰æˆ‘çµ¦çš„ stageï¼‰`,
`- entry/stop/takeProfitsï¼šç”¨ç›®å‰åƒ¹ + çµæ§‹ï¼ˆä¾‹å¦‚ ATRã€ç®±é«”ï¼‰çµ¦å‡ºå…·é«”åƒ¹ä½`,
`- takeProfits åˆ† 2~3 æ®µï¼ŒportionPct åŠ ç¸½=100`,
`- reasonsï¼š3~6 é»ï¼Œä¸­æ–‡ã€çŸ­å¥`,
``
  ].join("\n");
}

function buildGeminiPromptForTop(list){
  const payload = list.map(buildCandidateSummary);
  return [
`ä½ æ˜¯åˆç´„äº¤æ˜“è¼”åŠ©ï¼Œåªåšå¤šï¼ˆLONG-onlyï¼‰ã€‚`,
`æˆ‘æœƒçµ¦ä½  Top å€™é¸çš„ç²¾ç°¡æ‘˜è¦ï¼ˆæ¯å€‹å¹£ä¸€ç­†ï¼‰ï¼Œä¸è¦è¦æ±‚æ›´å¤šKç·šè³‡æ–™ã€‚`,
`ä»»å‹™ï¼šæŒ‘å‡ºã€Œæœ€å€¼å¾—åšå¤šã€çš„ 1~2 å€‹ï¼ˆå¦‚æœéƒ½ä¸é©åˆå°±éƒ½ WAITï¼‰ï¼Œä¸¦é€ä¸€è¼¸å‡º JSON ç‰©ä»¶é™£åˆ—ã€‚`,
`æ³¨æ„ï¼šè¼¸å‡ºå¿…é ˆæ˜¯ã€ŒJSON é™£åˆ—ã€ï¼Œæ¯å€‹å…ƒç´ ç¬¦åˆ schemaã€‚ä¸è¦å¤šä»»ä½•å­—ã€‚`,
``,
`ã€Top å€™é¸æ‘˜è¦ã€‘`,
JSON.stringify(payload, null, 2),
``
  ].join("\n");
}

// Top æ‰¹æ¬¡åˆ†æç”¨ schemaï¼šarray of trade schema
function geminiTradeArraySchema(){
  return {
    type:"array",
    items: geminiTradeSchema(),
    minItems: 1,
    maxItems: 3
  };
}

/** =========================
 *  12) AI é¡¯ç¤ºï¼ˆä¸­æ–‡å¯è®€ï¼‰
 * ========================= */
function stageBadge(stage){
  if(stage==="SETUP") return `<span class="badge badge-setup text-[10px] px-2 py-0.5 rounded-full">ğŸŸ¨ è“„å‹¢</span>`;
  if(stage==="IGNITE") return `<span class="badge badge-ignite text-[10px] px-2 py-0.5 rounded-full">ğŸŸ§ é»ç«</span>`;
  if(stage==="CONFIRM") return `<span class="badge badge-confirm text-[10px] px-2 py-0.5 rounded-full">ğŸŸ© è§¸ç™¼</span>`;
  return `<span class="badge text-[10px] px-2 py-0.5 rounded-full muted">ç†±æ©Ÿä¸­</span>`;
}

function aiToChineseView(ai){
  // ai: trade schema
  const dir = ai.direction==="LONG" ? "åšå¤š" : "è§€æœ›";
  const eta = `${ai.etaMinutes?.min ?? 0}~${ai.etaMinutes?.max ?? 0} åˆ†é˜`;
  const conf = `${ai.confidence ?? 0}/100`;

  const entryTypeMap = { market:"å¸‚åƒ¹", breakout:"çªç ´", pullback:"å›è¸©", wait:"ç­‰å¾…" };
  const entryType = entryTypeMap[ai.entry?.type] ?? "â€”";

  const tps = (ai.takeProfits||[]).map(tp=>`TP ${fmtN(tp.price, 6)}ï¼ˆ${tp.portionPct}%ï¼‰`).join(" / ");

  const reasons = (ai.reasons||[]).map(x=>`â€¢ ${x}`).join("\n");

  return `
æ–¹å‘ï¼š${dir}ï½œä¿¡å¿ƒï¼š${conf}
é ä¼°è¡¨æ…‹ï¼š${eta}
ç‹€æ…‹ï¼š${ai.stage}ï½œå‹æ…‹ï¼š${ai.pattern || "-"}
é€²å ´ï¼š${entryType} @ ${fmtN(ai.entry?.price, 6)}
åœæï¼š@ ${fmtN(ai.stop?.price, 6)}
æ­¢ç›ˆï¼š${tps || "-"}
å¤±æ•ˆæ¢ä»¶ï¼š${ai.invalidation || "-"}
ç†ç”±ï¼š
${reasons || "â€¢ -"}
`.trim();
}

/** =========================
 *  13) Renderï¼ˆå¡ç‰‡å·¦ä¸­æ–‡/å³AIï¼‰
 * ========================= */
function render(){
  // heartbeat
  if(now() - S.lastHB > 3500) setHB(false);

  $("clock").innerText = `æ›´æ–°ï¼š${new Date().toLocaleTimeString()}`;
  const backLeft = Math.max(0, S.geminiBackoffUntil - now());
  $("quotaStatus").innerText = backLeft>0 ? `Backoffï¼š${Math.ceil(backLeft/1000)}s` : `Backoffï¼š-`;

  const root = $("top5");
  root.innerHTML = "";

  for(const st of S.top5){
    const isLeader = (S.leader.symbol === st.symbol);

    const longBias = (st.buyRatio >= CFG.MIN_BUY_RATIO && (st.sumBuy-st.sumSell)>0) ? "LONG-ish" : "NEUTRAL";
    const leaderBadge = isLeader ? `<span class="badge badge-leader text-[10px] px-2 py-0.5 rounded-full">ğŸ‘‘ æœ€å¼·é–å®š</span>` : "";

    const key = st.symbol;
    const ai = S.aiCache.get(key)?.data || null;

    const aiText = ai ? aiToChineseView(ai) : `å°šæœªåˆ†æï¼šæŒ‰å³ä¸Šã€Geminiã€‘æˆ–ã€Analyze Topã€‘\nï¼ˆAutoï¼šçºŒåŠ›æ‰æœƒæ‰“ï¼Œä¸”æœ‰ cooldownï¼‰`;

    const warmTxt = st.candles.length < CFG.WARMUP_MIN
      ? `ç†±æ©Ÿä¸­ï¼š${st.candles.length}/${CFG.WARMUP_MIN} åˆ†é˜`
      : `ç†±æ©Ÿå®Œæˆ`;

    root.insertAdjacentHTML("beforeend", `
      <div class="card rounded-xl p-4">
        <div class="flex items-start justify-between gap-3">
          <div class="flex items-center gap-2 flex-wrap">
            <div class="text-white font-black text-lg">${st.symbol}</div>
            ${leaderBadge}
            ${stageBadge(st.stage)}
            <span class="badge text-[10px] px-2 py-0.5 rounded-full">${longBias}</span>
            <span class="badge text-[10px] px-2 py-0.5 rounded-full">score ${fmtN(st.score, 2)}</span>
            <span class="muted text-[10px]">${warmTxt}</span>
          </div>
          <div class="flex items-center gap-2">
            <button class="btn text-[11px] px-3 py-1 rounded font-bold" onclick="analyzeOne('${st.symbol}')">Gemini</button>
          </div>
        </div>

        <div class="mt-3 grid grid-cols-1 lg:grid-cols-2 gap-3">
          <!-- LEFT: æŒ‡æ¨™ä¸­æ–‡ -->
          <div class="grid grid-cols-1 gap-2">
            <div class="grid-3">
              <div class="aiBox rounded px-3 py-2"><div class="k">åƒ¹æ ¼</div><div class="v">${st.price?("$"+fmtN(st.price, 6)):"-"}</div></div>
              <div class="aiBox rounded px-3 py-2"><div class="k">5åˆ†æ¼²è·Œ</div><div class="v">${fmtN(st.ret5mPct,2)}%</div></div>
              <div class="aiBox rounded px-3 py-2"><div class="k">æº¢åƒ¹(æ¨™è¨˜-æŒ‡æ•¸)</div><div class="v">${fmtN(st.premiumPct,3)}%</div></div>
            </div>

            <div class="grid-3">
              <div class="aiBox rounded px-3 py-2"><div class="k">ä¸»å‹•è²·å…¥ä½”æ¯”(5m)</div><div class="v">${fmtN(st.buyRatio,3)}</div></div>
              <div class="aiBox rounded px-3 py-2"><div class="k">ä¸»å‹•è²·å…¥å·®é¡(5m,USDT)</div><div class="v">${fmtMoney(st.sumBuy-st.sumSell)}</div></div>
              <div class="aiBox rounded px-3 py-2"><div class="k">å·®é¡ç•°å¸¸Z(5m)</div><div class="v">${fmtN(st.deltaZ,2)}</div></div>
            </div>

            <div class="grid-3">
              <div class="aiBox rounded px-3 py-2"><div class="k">æˆäº¤é‡(5m,USDT)</div><div class="v">${fmtMoney(st.sumTotal)}</div></div>
              <div class="aiBox rounded px-3 py-2"><div class="k">æˆäº¤é‡ç•°å¸¸Z(5m)</div><div class="v">${fmtN(st.volZ,2)}</div></div>
              <div class="aiBox rounded px-3 py-2"><div class="k">æ”¶æ–‚ç•°å¸¸Z</div><div class="v">${fmtN(st.squeezeZ,2)}</div></div>
            </div>

            <div class="grid-3">
              <div class="aiBox rounded px-3 py-2"><div class="k">OIè®ŠåŒ–(5m)</div><div class="v">${st.oi5m===null?"-":fmtN(st.oi5m,2)}</div></div>
              <div class="aiBox rounded px-3 py-2"><div class="k">OIè®ŠåŒ–(4h)</div><div class="v">${st.oi4h===null?"-":fmtN(st.oi4h,2)}</div></div>
              <div class="aiBox rounded px-3 py-2"><div class="k">OIç•°å¸¸Z</div><div class="v">${fmtN(st.oiZ,2)}</div></div>
            </div>

            <div class="grid-2">
              <div class="aiBox rounded px-3 py-2"><div class="k">è³‡é‡‘è²»ç‡(å³æ™‚)</div><div class="v">${st.fundingPct===null?"-":fmtN(st.fundingPct,4)}%</div></div>
              <div class="aiBox rounded px-3 py-2"><div class="k">æº¢åƒ¹æ–œç‡Z</div><div class="v">${fmtN(st.premSlopeZ,2)}</div></div>
            </div>

            <div class="aiBox rounded px-3 py-2">
              <div class="k">å‹æ…‹æ¨™ç±¤</div>
              <div class="v">${(st.tags && st.tags.length) ? st.tags.join(" / ") : "-"}</div>
            </div>
          </div>

          <!-- RIGHT: AI -->
          <div class="aiBox rounded p-3">
            <div class="flex items-center justify-between mb-2">
              <div class="text-white font-black">AI åˆ¤æ–·ï¼ˆä¸­æ–‡ï¼‰</div>
              <div class="muted text-[10px]">model: ${CFG.GEMINI_MODEL}ï½œmax_out=${CFG.GEMINI_MAX_OUT}</div>
            </div>
            <pre class="text-[12px] leading-relaxed whitespace-pre-wrap">${aiText}</pre>
            ${S.aiCache.get(key)?.raw && !ai ? `<details class="mt-2"><summary class="muted text-[11px] cursor-pointer">rawï¼ˆé™¤éŒ¯ï¼‰</summary><pre class="text-[11px] whitespace-pre-wrap muted mt-2">${escapeHtml(S.aiCache.get(key).raw).slice(0,1200)}</pre></details>`:""}
          </div>
        </div>
      </div>
    `);
  }
}

function escapeHtml(s){
  return String(s||"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");
}

/** =========================
 *  14) Auto Analyzeï¼ˆçºŒåŠ›æ‰æ‰“ï¼‰
 * ========================= */
function shouldAutoAnalyze(st){
  if(!st) return false;
  if(st.stage!=="IGNITE" && st.stage!=="CONFIRM") return false;

  // çºŒåŠ›ï¼šåŒ stage è‡³å°‘ 35 ç§’
  const dur = now() - (st.persist.stageSince || now());
  if(dur < 35000) return false;

  // cooldownï¼šé¿å…åŒå¹£ä¸€ç›´æ‰“
  const cached = S.aiCache.get(st.symbol);
  if(cached && (now()-cached.ts) < S.aiCooldownMs) return false;

  // backoff ä¸­ä¸æ‰“
  if(now() < S.geminiBackoffUntil) return false;

  return true;
}

async function autoAnalyzeLoop(){
  if(!$("autoToggle").checked) return;
  if(now() - S.lastTopAnalyze < CFG.AUTO_EVERY_MS-2000) return;
  S.lastTopAnalyze = now();

  if(S.top5.length < 5){
    setGeminiStatus("Top5 æœªæ»¿ 5 æ”¯ï¼Œç•¥é");
    return;
  }

  const candidates = S.top5
    .slice()
    .sort((a,b)=>b.score-a.score)
    .slice(0, CFG.ANALYZE_TOPK)
    .filter(shouldAutoAnalyze);

  if(candidates.length === 0){
    setGeminiStatus("Autoï¼šå°šæœªé”ã€ŒçºŒåŠ›ã€æˆ– cooldown");
    return;
  }

  // æ‰¹æ¬¡ï¼šä¸€æ¬¡æ‰“ Top candidatesï¼ˆæœ€å¤š 3ï¼‰
  setGeminiStatus(`Autoï¼šåˆ†æ ${candidates.map(x=>x.symbol).join(",")}`);
  const prompt = buildGeminiPromptForTop(candidates);
  const res = await geminiCall({ prompt, schema: geminiTradeArraySchema(), maxOut: CFG.GEMINI_MAX_OUT });

  if(!res.ok){
    setGeminiStatus(`Auto å¤±æ•—ï¼š${res.err}`);
    return;
  }

  // å¯«å…¥ cacheï¼ˆé€ä¸€å°æ‡‰ï¼‰
  const arr = Array.isArray(res.data) ? res.data : [];
  for(const ai of arr){
    if(!ai?.symbol) continue;
    S.aiCache.set(ai.symbol, { ts: now(), data: ai, raw: res.raw });
  }
  setGeminiStatus(`Autoï¼šå®Œæˆï¼ˆ${arr.map(x=>x.symbol).join(",")}ï¼‰`);
}

/** =========================
 *  15) æ‰‹å‹•ï¼šåˆ†æå–®ä¸€å¹£
 * ========================= */
window.analyzeOne = async function(symbol){
  const st = S.sym.get(symbol);
  if(!st){
    alert("æ‰¾ä¸åˆ°è©²å¹£è³‡æ–™");
    return;
  }
  if(!getGeminiKey()){
    alert("è«‹å…ˆè¼¸å…¥ Gemini API Keyï¼ˆä¸è¦ commit åˆ° GitHubï¼‰");
    return;
  }
  if(now() < S.geminiBackoffUntil){
    alert("Gemini ç›®å‰ backoff ä¸­ï¼Œç¨å¾Œå†è©¦");
    return;
  }

  setGeminiStatus(`æ‰‹å‹•åˆ†æï¼š${symbol}`);
  const prompt = buildGeminiPromptForOne(st);
  const res = await geminiCall({ prompt, schema: geminiTradeSchema(), maxOut: CFG.GEMINI_MAX_OUT });
  if(!res.ok){
    // æŠŠ raw å­˜èµ·ä¾†ï¼Œæ–¹ä¾¿ä½ çœ‹
    S.aiCache.set(symbol, { ts: now(), data: null, raw: res.raw || res.err });
    setGeminiStatus(`æ‰‹å‹•å¤±æ•—ï¼š${res.err}`);
    alert(`Gemini FAILï¼š${res.err}\nï¼ˆå·²æŠŠ raw æ”¾é€²è©²å¹£å¡ç‰‡å³å´ raw é™¤éŒ¯ï¼‰`);
    return;
  }
  S.aiCache.set(symbol, { ts: now(), data: res.data, raw: res.raw });
  setGeminiStatus(`æ‰‹å‹•å®Œæˆï¼š${symbol}`);
};

/** =========================
 *  16) Test Geminiï¼ˆä¿®æ­£ï¼šç”¨ test schemaï¼‰
 * ========================= */
async function testGemini(){
  if(!getGeminiKey()){
    alert("è«‹å…ˆè¼¸å…¥ Gemini API Key");
    return;
  }
  setGeminiStatus("Testï¼šé€å‡ºâ€¦");
  const prompt = [
    `è«‹è¼¸å‡ºå–®ä¸€ JSONï¼Œç¬¦åˆ schemaï¼š`,
    `- ok: boolean`,
    `- msg: stringï¼ˆå›å‚³ "hello"ï¼‰`,
  ].join("\n");

  const res = await geminiCall({ prompt, schema: geminiTestSchema(), maxOut: 64 });
  if(!res.ok){
    setGeminiStatus(`Test å¤±æ•—ï¼š${res.err}`);
    alert(`Test Gemini FAILï¼š${res.err}\nï¼ˆçœ‹ Console æˆ– backoffï¼‰`);
    return;
  }
  setGeminiStatus(`Test OKï¼š${res.data?.msg || "ok"}`);
  alert(`Test OKï¼š${JSON.stringify(res.data)}`);
}

/** =========================
 *  17) Key UIï¼ˆä¿®æ­£ï¼šè¼¸å…¥/ä¿å­˜ç‹€æ…‹è¦æœ‰åæ‡‰ï¼‰
 * ========================= */
function loadKey(){
  const k = localStorage.getItem("TRIDENT_GEMINI_KEY") || "";
  S.geminiKey = k;
  $("keyInput").value = k;
  $("keyStatus").innerText = k ? `Keyï¼šå·²è¼‰å…¥ï¼ˆé•·åº¦ ${k.length}ï¼‰` : "Keyï¼šæœªè¼‰å…¥";
}
function saveKey(){
  const k = ($("keyInput").value || "").trim();
  S.geminiKey = k;
  localStorage.setItem("TRIDENT_GEMINI_KEY", k);
  $("keyStatus").innerText = k ? `Keyï¼šå·²ä¿å­˜ï¼ˆé•·åº¦ ${k.length}ï¼‰` : "Keyï¼šæœªè¼‰å…¥";
}
function clearKey(){
  S.geminiKey = "";
  localStorage.removeItem("TRIDENT_GEMINI_KEY");
  $("keyInput").value = "";
  $("keyStatus").innerText = "Keyï¼šæœªè¼‰å…¥";
}
function hookKeyUI(){
  $("saveKeyBtn").onclick = ()=>saveKey();
  $("clearKeyBtn").onclick = ()=>clearKey();
  $("keyInput").addEventListener("input", ()=>{
    const k = ($("keyInput").value||"").trim();
    $("keyStatus").innerText = k ? `Keyï¼šæœªä¿å­˜ï¼ˆé•·åº¦ ${k.length}ï¼‰` : "Keyï¼šæœªè¼‰å…¥";
  });
  $("keyInput").addEventListener("keypress", (e)=>{
    if(e.key==="Enter"){ saveKey(); }
  });
  $("toggleKeyBtn").onclick = ()=>{
    const inp = $("keyInput");
    inp.type = (inp.type==="password") ? "text" : "password";
  };
}

/** =========================
 *  18) æ§åˆ¶æŒ‰éˆ•
 * ========================= */
$("testGeminiBtn").onclick = ()=>testGemini();
$("analyzeTopBtn").onclick = ()=>autoAnalyzeLoop(); // æ‰‹å‹•è§¸ç™¼ä¸€æ¬¡ auto
$("resetBtn").onclick = ()=>{
  stopWS();
  S.sym.clear();
  S.universe=[];
  S.top5=[];
  S.leader={symbol:null,score:0,since:0};
  S.aiCache.clear();
  S.geminiBackoffUntil=0;
  $("scanStatus").innerText="æƒæï¼š-";
  setGeminiStatus("-");
  initAll();
};

/** =========================
 *  19) ä¸»è¿´åœˆ
 * ========================= */
function tick(){
  updateScores();
  computeTop5();
}

function initTimers(){
  if(S.renderTimer) clearInterval(S.renderTimer);
  if(S.autoTimer) clearInterval(S.autoTimer);
  if(S.oiTimer) clearInterval(S.oiTimer);

  S.renderTimer = setInterval(()=>{ tick(); render(); }, CFG.RENDER_EVERY_MS);

  S.autoTimer = setInterval(()=>{ autoAnalyzeLoop(); }, 2000); // æ¯2ç§’çœ‹ä¸€æ¬¡æ˜¯å¦åˆ°2åˆ†é˜ä¸”ç¬¦åˆçºŒåŠ›
  S.oiTimer = setInterval(()=>{ oiLoop(); }, CFG.OI_REFRESH_MS);
}

async function initAll(){
  loadKey();
  hookKeyUI();
  await initUniverse();
  startWS();
  initTimers();
}

initAll();
</script>
</body>
</html>
