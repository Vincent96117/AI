<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRIDENT V7 - FastWarmup（Top20 → AI選Top5 / LONG ONLY）</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    body { background:#050505; color:#d4d4d8; font-family:'JetBrains Mono', monospace; overflow-x:hidden; }
    .panel { background:#0f0f11; border:1px solid #1f1f23; }
    .muted { color:#71717a; }
    .badge { border:1px solid #27272a; background:#0b0b0d; }
    .ok { color:#22c55e; }
    .warn { color:#f59e0b; }
    .bad { color:#ef4444; }
    .card { background:#0f0f11; border:1px solid #1f1f23; border-radius:14px; overflow:hidden; }
    .card-top1 { border:2px solid #22c55e !important; box-shadow:0 0 0 1px rgba(34,197,94,0.2), 0 0 24px rgba(34,197,94,0.15); }
    .kv { background:#0b0b0d; border:1px solid #1f1f23; border-radius:10px; padding:8px 10px; }
    .btn { border:1px solid #27272a; background:#0b0b0d; border-radius:10px; padding:8px 10px; font-weight:700; }
    .btn:hover { filter:brightness(1.1); }
    .btn-blue { border-color:#2563eb; color:#93c5fd; background:rgba(37,99,235,0.12); }
    .btn-green { border-color:#16a34a; color:#86efac; background:rgba(22,163,74,0.12); }
    .btn-amber { border-color:#d97706; color:#fdba74; background:rgba(217,119,6,0.12); }
    .btn-red { border-color:#ef4444; color:#fecaca; background:rgba(239,68,68,0.12); }
    .hr { border-top:1px solid #1f1f23; }
    .ai-box { background:#070708; border:1px solid #1f1f23; border-radius:14px; padding:12px; min-height:190px; }
    .stage-setup { color:#fbbf24; }
    .stage-ignite { color:#fb7185; }
    .stage-confirm { color:#22c55e; }
    .stage-chase { color:#ef4444; }
    .stage-cool { color:#71717a; }
    .tiny { font-size:11px; }
    .tiny2 { font-size:10px; }
    input[type="text"], input[type="password"] {
      background:#09090b; border:1px solid #27272a; border-radius:10px; padding:10px 10px; color:#e5e7eb;
      outline:none; font-size:12px;
    }
    input::placeholder { color:#52525b; }
    .heartbeat { width:8px; height:8px; border-radius:999px; display:inline-block; margin-right:8px; background:#3f3f46; box-shadow:none; }
    .hb-on { background:#22c55e; box-shadow:0 0 10px rgba(34,197,94,0.75); }
  </style>
</head>

<body class="p-4">
  <!-- Top Bar -->
  <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
    <div class="flex items-center gap-3">
      <span id="hb" class="heartbeat"></span>
      <div>
        <div class="text-white font-black italic text-xl leading-none">TRIDENT <span class="text-emerald-400">V7</span></div>
        <div class="tiny muted font-bold tracking-widest uppercase">
          FAST WARMUP: cross-section anomalies → self anomalies (LONG ONLY)
        </div>
      </div>
    </div>

    <div class="flex flex-wrap items-center gap-2">
      <input id="aiKey" type="password" class="w-[280px]" placeholder="輸入 Groq API Key（只存在瀏覽器 localStorage）" />
      <button class="btn btn-green" onclick="saveKey()">Save</button>
      <button class="btn" onclick="clearKey()">Clear</button>

      <select id="modelSel" class="btn">
        <option value="llama-3.3-70b-versatile">llama-3.3-70b-versatile</option>
        <option value="llama-3.1-8b-instant">llama-3.1-8b-instant</option>
      </select>

      <button class="btn btn-green" onclick="testAI()">Test AI</button>
      <button class="btn btn-blue" onclick="runAIOnce(true)">Analyze Now</button>
      <button class="btn btn-amber" onclick="toggleAutoAI()"><span id="autoLbl">Auto AI: ON</span></button>
      <button class="btn btn-red" onclick="hardReset()">RESET</button>
    </div>
  </div>

  <!-- Status line -->
  <div class="mt-3 panel rounded-xl p-3 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
    <div class="flex flex-wrap items-center gap-3 tiny">
      <span class="badge px-2 py-1 rounded-lg">Universe: <b id="universeN">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">Candidates(Top20): <b id="candN">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">Top5: <b id="top5N">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">Pinned #1: <b id="pinnedSym">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">更新: <b id="lastTick">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">Binance: <b id="binStatus" class="muted">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">AI: <b id="aiStatus" class="muted">-</b></span>
      <span class="badge px-2 py-1 rounded-lg">Warmup: <b id="warmState" class="warn">FAST</b></span>
    </div>

    <div class="tiny muted">
      前 5~10 分鐘：用「市場橫斷面異常」快速出 Top20；每幣累積滿 8 個 5m bucket 後自動切回「跟自己比」。
    </div>
  </div>

  <!-- Panels -->
  <div class="mt-4 grid grid-cols-1 gap-4">
    <div class="panel rounded-xl p-3">
      <div class="flex items-center justify-between">
        <div class="text-white font-bold">Top 5（AI 從 Top20 選出）</div>
        <button class="btn tiny" onclick="toggleDebug()">查看 AI 吃到的 Top20 摘要（Debug）</button>
      </div>
      <div id="cards" class="mt-3 grid grid-cols-1 gap-4"></div>
    </div>

    <div id="debugWrap" class="panel rounded-xl p-3 hidden">
      <div class="text-white font-bold mb-2">AI Input（Top20 摘要 JSON）</div>
      <pre id="debugJSON" class="ai-box text-[11px] overflow-auto"></pre>
    </div>
  </div>

<script>
/* ===========================
   CONFIG
=========================== */
const CONFIG = {
  LONG_ONLY: true,

  UNIVERSE_LIMIT: 80,
  UNIVERSE_REFRESH_MS: 5 * 60 * 1000,

  CANDIDATE_LIMIT: 20,
  CANDIDATE_REFRESH_MS: 3000,   // 加速：更快看到 Top20 動起來

  TOP5_LIMIT: 5,
  AI_INTERVAL_MS: 2 * 60 * 1000,

  ROLL_5M_MS: 5 * 60 * 1000,
  BUCKET_5M_MS: 5 * 60 * 1000,
  HIST_5M_BUCKETS: 48,
  KLINES_LIMIT: 60,
  ATR_PERIOD: 14,
  SWING_WINDOW: 20,

  ANTI_CHASE: {
    ret5mPctMax: 1.2,
    distSmaAtrMax: 1.2,
    range20PctMax: 3.2
  },

  // 正常模式（跟自己比）
  THRESH: {
    volZMin: 1.4,
    deltaNotionalMin: 20000,
    imbalanceMin: 0.08,
    preScoreMin: 55
  },

  // ✅ FAST WARMUP（5分鐘上線）
  // 尚未累積滿 histBucketsForSelfZ 前：用 cross-section z + 放寬門檻
  FAST_WARMUP: {
    enabled: true,
    histBucketsForSelfZ: 8,     // 8 個 5m bucket = 40 分鐘後自動切回「跟自己比」
    THRESH: {
      volZMin: 0.9,
      deltaNotionalMin: 8000,
      imbalanceMin: 0.02,       // buy ratio >= 0.52
      preScoreMin: 48
    }
  },

  TOPCAP_EXCLUDE: [
    "BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TRXUSDT","TONUSDT",
    "AVAXUSDT","DOTUSDT","LINKUSDT","MATICUSDT","POLUSDT","SHIBUSDT","1000SHIBUSDT",
    "LTCUSDT","BCHUSDT","ATOMUSDT","UNIUSDT","XLMUSDT","ICPUSDT","FILUSDT","APTUSDT",
    "NEARUSDT","ARBUSDT","OPUSDT"
  ],

  EXCLUDE_EXTRA: [
    "USDCUSDT","TUSDUSDT","FDUSDUSDT","USDPUSDT","DAIUSDT",
    "BTCUSDT","ETHUSDT","SOLUSDT","XRPUSDT","BNBUSDT","BNXUSDT"
  ]
};

const APP_START = Date.now();

/* ===========================
   STATE
=========================== */
let AUTO_AI = true;
let lastAiTs = 0;
let aiBackoffUntil = 0;

let universe = [];
let symState = {};
let wsAgg = {};
let wsMini = null;

let premiumMap = {};
let candidatesTop20 = [];
let aiTop5 = [];
let aiBySymbol = {};
let pinnedTop1 = { symbol:null, score:-1, confidence:-1, ts:0 };

/* ===========================
   UI helpers
=========================== */
const $ = (id) => document.getElementById(id);
function nowStr() {
  const d = new Date();
  return d.toLocaleTimeString("zh-TW", { hour12:false });
}
function fmt(n, digits=2) {
  if (n === null || n === undefined || Number.isNaN(n)) return "-";
  return Number(n).toFixed(digits);
}
function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
function setStatus(el, text, cls) {
  const node = $(el);
  node.textContent = text;
  node.className = cls || "muted";
}
function toggleDebug() { $("debugWrap").classList.toggle("hidden"); }
function saveKey() {
  const k = $("aiKey").value.trim();
  if (!k) return alert("請輸入 Groq API Key");
  localStorage.setItem("GROQ_KEY", k);
  alert("已保存到 localStorage（僅此瀏覽器）");
}
function clearKey() {
  localStorage.removeItem("GROQ_KEY");
  $("aiKey").value = "";
  alert("已清除 key");
}
function loadKey() {
  const k = localStorage.getItem("GROQ_KEY") || "";
  $("aiKey").value = k;
}
function toggleAutoAI() {
  AUTO_AI = !AUTO_AI;
  $("autoLbl").textContent = `Auto AI: ${AUTO_AI ? "ON" : "OFF"}`;
}
function hardReset() {
  try { if (wsMini) wsMini.close(); } catch {}
  Object.keys(wsAgg).forEach(s => { try { wsAgg[s].close(); } catch {} });
  wsAgg = {};
  symState = {};
  universe = [];
  candidatesTop20 = [];
  aiTop5 = [];
  aiBySymbol = {};
  pinnedTop1 = { symbol:null, score:-1, confidence:-1, ts:0 };
  lastAiTs = 0;
  aiBackoffUntil = 0;

  $("cards").innerHTML = "";
  $("debugJSON").textContent = "";
  setStatus("binStatus","重置中…","warn");
  setStatus("aiStatus","-","muted");
  $("universeN").textContent = "-";
  $("candN").textContent = "-";
  $("top5N").textContent = "-";
  $("pinnedSym").textContent = "-";
  $("warmState").textContent = "FAST";
  $("warmState").className = "warn";

  boot();
}

/* ===========================
   Network helpers
=========================== */
async function fetchJSON(url) {
  const res = await fetch(url);
  const txt = await res.text();
  let data;
  try { data = JSON.parse(txt); } catch { throw new Error(`JSON parse fail: ${txt.slice(0,200)}`); }
  if (!res.ok) throw new Error(`HTTP ${res.status}: ${txt.slice(0,200)}`);
  return data;
}

// ✅ 改成更寬鬆：只要有 2~3 個樣本也可以算。"標準差=0" 就回 0
function zscore(x, arr) {
  if (!arr || arr.length < 3) return null;
  const m = arr.reduce((a,b)=>a+b,0) / arr.length;
  const v = arr.reduce((a,b)=>a+(b-m)*(b-m),0) / arr.length;
  const s = Math.sqrt(v);
  if (s === 0) return 0;
  return (x - m) / s;
}

function meanStd(arr) {
  if (!arr || arr.length < 3) return { mean: 0, std: 0 };
  const mean = arr.reduce((a,b)=>a+b,0) / arr.length;
  const v = arr.reduce((a,b)=>a+(b-mean)*(b-mean),0) / arr.length;
  const std = Math.sqrt(v);
  return { mean, std };
}

function isSelfHistoryReady(s) {
  const need = CONFIG.FAST_WARMUP.histBucketsForSelfZ;
  return (s?.histBuckets ?? 0) >= need;
}

function activeThresh(s) {
  if (!CONFIG.FAST_WARMUP.enabled) return CONFIG.THRESH;
  return isSelfHistoryReady(s) ? CONFIG.THRESH : CONFIG.FAST_WARMUP.THRESH;
}

function updateWarmLabel() {
  // 只要 universe 內有一大半幣尚未 ready，就顯示 FAST
  const list = universe.map(x=>symState[x]).filter(Boolean);
  if (!list.length) return;
  const readyN = list.filter(isSelfHistoryReady).length;
  const fast = readyN < Math.max(10, Math.floor(list.length*0.5));
  $("warmState").textContent = fast ? "FAST" : "SELF";
  $("warmState").className = fast ? "warn" : "ok";
}

/* ===========================
   Binance: premium + universe
=========================== */
async function refreshPremiumAll() {
  const data = await fetchJSON("https://fapi.binance.com/fapi/v1/premiumIndex");
  const map = {};
  for (const r of data) {
    const mark = parseFloat(r.markPrice);
    const idx = parseFloat(r.indexPrice);
    const premiumPct = (idx && mark) ? ((mark - idx) / idx * 100) : null;
    map[r.symbol] = {
      fundingPct: parseFloat(r.lastFundingRate) * 100,
      premiumPct,
      markPrice: mark,
      indexPrice: idx
    };
  }
  premiumMap = map;
}

async function refreshUniverse() {
  const tickers = await fetchJSON("https://fapi.binance.com/fapi/v1/ticker/24hr");
  const ex = new Set([...CONFIG.TOPCAP_EXCLUDE, ...CONFIG.EXCLUDE_EXTRA]);

  const filtered = tickers
    .filter(t => t.symbol.endsWith("USDT") && !ex.has(t.symbol))
    .map(t => ({ symbol: t.symbol, quoteVolume: parseFloat(t.quoteVolume || "0") }))
    .sort((a,b) => b.quoteVolume - a.quoteVolume)
    .slice(0, CONFIG.UNIVERSE_LIMIT)
    .map(x => x.symbol);

  universe = filtered;
  $("universeN").textContent = universe.length;

  const uSet = new Set(universe);

  Object.keys(wsAgg).forEach(sym => {
    if (!uSet.has(sym)) {
      try { wsAgg[sym].close(); } catch {}
      delete wsAgg[sym];
      delete symState[sym];
    }
  });

  for (const sym of universe) {
    if (!wsAgg[sym]) initAggTrade(sym);
    if (!symState[sym]) initSymbolState(sym);
  }
}

/* ===========================
   Per-symbol state + streams
=========================== */
function initSymbolState(sym) {
  symState[sym] = {
    symbol: sym,
    price: null,
    lastTradeTs: 0,

    trades: [], // {ts, price, notional, deltaNotional, isBuy}

    buckets: new Map(),
    bucketIds: [],

    vol5mNotional: null,
    delta5mNotional: null,
    imbalance5m: null,

    volZ5m: null,
    deltaZ5m: null,

    // ✅ FAST fallback: cross-section z (不需要歷史)
    volZcs: null,
    deltaZcs: null,

    histBuckets: 0, // ✅ 記錄「歷史 bucket 數」

    ret5mPct: null,

    fundingPct: null,
    premiumPct: null,

    oiCurrent: null,
    oiSamples: [],
    oiDelta5m: null,
    oiDelta4h: null,

    klinesReady: false,
    atr14: null,
    swingLow20: null,
    swingHigh20: null,
    range20Pct: null,
    sma20: null,
    distSma20Atr: null,

    stage: "熱機中",
    tags: [],
    preScore: 0,

    firstSeenTs: Date.now(),
  };
}

function initAggTrade(sym) {
  const url = `wss://fstream.binance.com/ws/${sym.toLowerCase()}@aggTrade`;
  const ws = new WebSocket(url);
  wsAgg[sym] = ws;

  ws.onopen = () => {
    $("hb").classList.add("hb-on");
    setStatus("binStatus","WS OK","ok");
  };
  ws.onerror = () => setStatus("binStatus","WS error","warn");
  ws.onclose = () => {
    if (universe.includes(sym)) {
      setTimeout(() => {
        if (!wsAgg[sym] || wsAgg[sym].readyState === 3) initAggTrade(sym);
      }, 800 + Math.random()*800);
    }
  };

  ws.onmessage = (ev) => {
    const s = symState[sym];
    if (!s) return;

    const d = JSON.parse(ev.data);

    const ts = d.T;
    const price = parseFloat(d.p);
    const qty = parseFloat(d.q);
    const notional = price * qty;

    const isBuyAgg = !d.m;
    const deltaNotional = isBuyAgg ? notional : -notional;

    s.price = price;
    s.lastTradeTs = ts;

    s.trades.push({ ts, price, notional, deltaNotional, isBuy: isBuyAgg });

    const cutoff = Date.now() - CONFIG.ROLL_5M_MS;
    while (s.trades.length && s.trades[0].ts < cutoff) s.trades.shift();

    if (s.trades.length >= 2) {
      const old = s.trades[0].price;
      if (old > 0) s.ret5mPct = (price / old - 1) * 100;
    }

    const bucketId = Math.floor(ts / CONFIG.BUCKET_5M_MS);
    let b = s.buckets.get(bucketId);
    if (!b) {
      b = { notional: 0, deltaNotional: 0 };
      s.buckets.set(bucketId, b);
      s.bucketIds.push(bucketId);
      while (s.bucketIds.length > CONFIG.HIST_5M_BUCKETS + 3) {
        const id = s.bucketIds.shift();
        s.buckets.delete(id);
      }
    }
    b.notional += notional;
    b.deltaNotional += deltaNotional;

    const curB = s.buckets.get(bucketId);
    if (curB) {
      s.vol5mNotional = curB.notional;
      s.delta5mNotional = curB.deltaNotional;

      const total = curB.notional || 0;
      const delta = curB.deltaNotional || 0;
      const buy = (total + delta) / 2;
      const sell = (total - delta) / 2;
      const denom = buy + sell;
      s.imbalance5m = denom > 0 ? (buy / denom) : null;
    }

    // self-history zscore (仍保留)
    const histIds = s.bucketIds.filter(id => id !== bucketId);
    s.histBuckets = histIds.length; // ✅ 記錄歷史 bucket 數

    const histVol = histIds.map(id => (s.buckets.get(id)?.notional || 0)).filter(x => x > 0);
    const histDelta = histIds.map(id => (s.buckets.get(id)?.deltaNotional || 0));

    if (s.vol5mNotional !== null) s.volZ5m = zscore(s.vol5mNotional, histVol);
    if (s.delta5mNotional !== null) s.deltaZ5m = zscore(s.delta5mNotional, histDelta);

    const p = premiumMap[sym];
    if (p) {
      s.fundingPct = p.fundingPct;
      s.premiumPct = p.premiumPct;
    }

    deriveSymbol(sym);
  };
}

/* ===========================
   FAST warmup: cross-section z (不需要歷史)
=========================== */
function computeCrossSectionZ() {
  const list = universe.map(sym => symState[sym]).filter(s => s && s.vol5mNotional !== null && s.delta5mNotional !== null);

  if (list.length < 10) return;

  const vols = list.map(s => s.vol5mNotional).filter(v => v > 0);
  const deltas = list.map(s => s.delta5mNotional);

  const vs = meanStd(vols);
  const ds = meanStd(deltas);

  for (const s of list) {
    s.volZcs = (vs.std > 0) ? (s.vol5mNotional - vs.mean) / vs.std : 0;
    s.deltaZcs = (ds.std > 0) ? (s.delta5mNotional - ds.mean) / ds.std : 0;
  }
}

/* ===========================
   OI + Klines
=========================== */
async function ensureKlinesAndOI(sym) {
  const s = symState[sym];
  if (!s) return;

  try {
    const k = await fetchJSON(`https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=1m&limit=${CONFIG.KLINES_LIMIT}`);
    computeKlineFeatures(sym, k);
  } catch {}

  try {
    const oi = await fetchJSON(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${sym}`);
    const v = parseFloat(oi.openInterest);
    if (!Number.isNaN(v)) {
      s.oiCurrent = v;
      s.oiSamples.push({ ts: Date.now(), oi: v });
      const cutoff = Date.now() - 4*60*60*1000 - 60*1000;
      while (s.oiSamples.length && s.oiSamples[0].ts < cutoff) s.oiSamples.shift();
      computeOIDeltas(sym);
    }
  } catch {}
}

function computeKlineFeatures(sym, k) {
  const s = symState[sym];
  if (!s || !Array.isArray(k) || k.length < 25) return;

  const candles = k.map(x => ({
    open: parseFloat(x[1]),
    high: parseFloat(x[2]),
    low:  parseFloat(x[3]),
    close:parseFloat(x[4]),
  })).filter(c => [c.open,c.high,c.low,c.close].every(v => !Number.isNaN(v)));

  if (candles.length < 25) return;

  const last20 = candles.slice(-20);
  s.sma20 = last20.reduce((a,c)=>a+c.close,0) / last20.length;

  const w = candles.slice(-CONFIG.SWING_WINDOW);
  s.swingLow20 = Math.min(...w.map(c => c.low));
  s.swingHigh20 = Math.max(...w.map(c => c.high));
  const lastClose = candles[candles.length-1].close;
  s.range20Pct = lastClose > 0 ? ((s.swingHigh20 - s.swingLow20) / lastClose * 100) : null;

  const n = CONFIG.ATR_PERIOD;
  const trs = [];
  for (let i=1; i<candles.length; i++) {
    const cur = candles[i];
    const prev = candles[i-1];
    const tr = Math.max(
      cur.high - cur.low,
      Math.abs(cur.high - prev.close),
      Math.abs(cur.low - prev.close)
    );
    trs.push(tr);
  }
  if (trs.length >= n) {
    const lastTR = trs.slice(-n);
    s.atr14 = lastTR.reduce((a,v)=>a+v,0) / lastTR.length;
  }

  if (s.atr14 && s.atr14 > 0 && s.sma20 && lastClose) {
    s.distSma20Atr = Math.abs(lastClose - s.sma20) / s.atr14;
  }

  s.klinesReady = true;
}

function computeOIDeltas(sym) {
  const s = symState[sym];
  if (!s || s.oiSamples.length < 3) return;
  const now = Date.now();

  const getOiAgo = (ms) => {
    const t = now - ms;
    let best = null;
    for (let i=s.oiSamples.length-1; i>=0; i--) {
      if (s.oiSamples[i].ts <= t) { best = s.oiSamples[i]; break; }
    }
    return best ? best.oi : null;
  };

  const oi5m = getOiAgo(5*60*1000);
  const oi4h = getOiAgo(4*60*60*1000);

  if (oi5m !== null && s.oiCurrent !== null) s.oiDelta5m = s.oiCurrent - oi5m;
  if (oi4h !== null && s.oiCurrent !== null) s.oiDelta4h = s.oiCurrent - oi4h;
}

/* ===========================
   Derive: stage / tags / preScore
=========================== */
function deriveSymbol(sym) {
  const s = symState[sym];
  if (!s) return;

  const T = activeThresh(s);

  const warmSec = Math.floor((Date.now() - s.firstSeenTs)/1000);

  const antiChase =
    (s.ret5mPct !== null && s.ret5mPct > CONFIG.ANTI_CHASE.ret5mPctMax) ||
    (s.distSma20Atr !== null && s.distSma20Atr > CONFIG.ANTI_CHASE.distSmaAtrMax) ||
    (s.range20Pct !== null && s.range20Pct > CONFIG.ANTI_CHASE.range20PctMax);

  const tags = [];
  const vzEff = (s.volZ5m !== null) ? s.volZ5m : (s.volZcs ?? null);
  const dzEff = (s.deltaZ5m !== null) ? s.deltaZ5m : (s.deltaZcs ?? null);

  if (vzEff !== null && vzEff >= 2.0) tags.push("量能爆量");
  else if (vzEff !== null && vzEff >= 1.2) tags.push("量能異常");

  if (s.delta5mNotional !== null && s.delta5mNotional > 0) tags.push("主動買差額>0");
  if (s.imbalance5m !== null && s.imbalance5m >= 0.55) tags.push("買盤佔優");
  if (s.oiDelta5m !== null && s.oiDelta5m > 0) tags.push("OI(5m)上升");
  if (s.oiDelta4h !== null && s.oiDelta4h > 0) tags.push("OI(4h)上升");
  if (s.fundingPct !== null && s.fundingPct < 0) tags.push("資金費率偏空(利多做多)");
  if (s.range20Pct !== null && s.range20Pct < 0.9) tags.push("窄幅收斂");
  if (s.swingHigh20 && s.price && (s.swingHigh20 - s.price)/s.price*100 < 0.25) tags.push("接近突破位");
  if (antiChase) tags.push("已急拉/追價風險");
  if (!isSelfHistoryReady(s)) tags.push("FAST_warmup(橫斷面)");
  s.tags = tags;

  const flowOK =
    (s.delta5mNotional !== null && s.delta5mNotional > T.deltaNotionalMin) &&
    (s.imbalance5m !== null && s.imbalance5m >= (0.5 + T.imbalanceMin));

  const volOK = (vzEff !== null && vzEff >= T.volZMin);
  const notDump = (s.ret5mPct === null) ? true : (s.ret5mPct > -1.0);

  const setup = volOK && flowOK && notDump && !antiChase;
  const ignite = setup && (s.price !== null && s.sma20 !== null && s.price > s.sma20);
  const confirm = ignite && (s.swingHigh20 !== null && s.price !== null && s.price >= s.swingHigh20);

  if (antiChase) s.stage = "追價風險";
  else if (confirm) s.stage = "觸發";
  else if (ignite) s.stage = "點火";
  else if (setup) s.stage = "蓄勢";
  else s.stage = warmSec < 60 ? "熱機中" : "冷卻";

  // preScore
  let score = 50;

  const vz = (vzEff === null) ? 0 : clamp(vzEff, -3, 3);
  const dz = (dzEff === null) ? 0 : clamp(dzEff, -3, 3);

  score += 10 * vz;
  score += 8 * dz;

  if (s.delta5mNotional !== null) score += clamp(s.delta5mNotional / 60000, -8, 12);

  if (s.oiDelta5m !== null && s.oiDelta4h !== null) {
    if (s.oiDelta5m > 0 && s.oiDelta4h > 0) score += 6;
    if (s.oiDelta5m < 0 && s.oiDelta4h < 0) score -= 4;
  }

  if (s.fundingPct !== null && s.fundingPct < 0) score += 3;
  if (s.premiumPct !== null && Math.abs(s.premiumPct) > 0.25) score -= 2;

  if (antiChase) score -= 18;
  if (s.ret5mPct !== null && s.ret5mPct < -0.6) score -= 6;

  s.preScore = clamp(score, 0, 100);
}

/* ===========================
   Candidate selection (Top20) - LONG ONLY
=========================== */
function buildTop20Candidates() {
  computeCrossSectionZ(); // ✅ FAST：先把橫斷面 z 算好
  updateWarmLabel();

  const ex = new Set([...CONFIG.TOPCAP_EXCLUDE, ...CONFIG.EXCLUDE_EXTRA]);

  const arr = universe
    .filter(sym => !ex.has(sym))
    .map(sym => symState[sym])
    .filter(s => s && s.price !== null)
    .filter(s => {
      const T = activeThresh(s);

      // LONG ONLY: delta>0 + imbalance > 0.5
      const longBias = (s.delta5mNotional !== null && s.delta5mNotional > 0) &&
                       (s.imbalance5m !== null && s.imbalance5m >= (0.5 + T.imbalanceMin));
      if (!longBias) return false;

      if (s.preScore < T.preScoreMin) return false;

      // 不要冷卻
      if (s.stage === "冷卻") return false;

      return true;
    })
    .sort((a,b) => b.preScore - a.preScore)
    .slice(0, CONFIG.CANDIDATE_LIMIT);

  candidatesTop20 = arr.map(x => x.symbol);
  $("candN").textContent = candidatesTop20.length;

  // 候選進 Top20 就補抓 Klines+OI
  for (const sym of candidatesTop20) ensureKlinesAndOI(sym);

  const summaries = candidatesTop20.map(sym => buildSummary(sym)).filter(Boolean);
  $("debugJSON").textContent = JSON.stringify({ top20: summaries }, null, 2);
}

function buildSummary(sym) {
  const s = symState[sym];
  if (!s) return null;

  const vzEff = (s.volZ5m !== null) ? s.volZ5m : s.volZcs;
  const dzEff = (s.deltaZ5m !== null) ? s.deltaZ5m : s.deltaZcs;

  return {
    symbol: s.symbol,
    price: s.price,

    ret5m_pct: s.ret5mPct,
    vol5m_notional: s.vol5mNotional,
    volZ_5m: vzEff,

    active_buy_delta_5m_notional: s.delta5mNotional,
    active_buy_imbalance_5m: (s.imbalance5m !== null) ? (s.imbalance5m - 0.5) * 2 : null,

    funding_pct: s.fundingPct,
    premium_pct: s.premiumPct,

    oi_delta_5m: s.oiDelta5m,
    oi_delta_4h: s.oiDelta4h,

    atr14: s.atr14,
    swing_low_20: s.swingLow20,
    swing_high_20: s.swingHigh20,
    range_20_pct: s.range20Pct,

    sma20: s.sma20,
    dist_sma20_atr: s.distSma20Atr,

    stage: s.stage,
    preScore: s.preScore,
    tags: s.tags,

    warmup_mode: !isSelfHistoryReady(s),
    hist_buckets: s.histBuckets
  };
}

/* ===========================
   Groq AI
=========================== */
async function groqChatCompletion({ apiKey, model, messages, maxOut = 420 }) {
  const url = "https://api.groq.com/openai/v1/chat/completions";
  const payload = {
    model,
    messages,
    temperature: 0.2,
    top_p: 0.9,
    max_completion_tokens: maxOut,
    response_format: { type: "json_object" }
  };

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type":"application/json", "Authorization": `Bearer ${apiKey}` },
    body: JSON.stringify(payload)
  });

  const raw = await res.text();
  console.log("[Groq] HTTP", res.status, raw);

  if (!res.ok) throw new Error(`Groq HTTP ${res.status}: ${raw}`);

  let data;
  try { data = JSON.parse(raw); } catch { throw new Error("Groq 回應不是 JSON"); }

  const content = data?.choices?.[0]?.message?.content ?? "";
  const cleaned = content.replace(/^```json\s*/i,"").replace(/^```\s*/i,"").replace(/```$/i,"").trim();

  let obj;
  try { obj = JSON.parse(cleaned); }
  catch { throw new Error("模型 content 不是有效 JSON: " + cleaned.slice(0,200)); }

  return obj;
}

function buildAiPrompt(top20Summaries) {
  const system = `
你是加密合約「只做多」交易助手。
目標：從候選列表挑出最可能在 5~30 分鐘內「向上表態」且「不追價」的標的，並輸出可執行交易計畫。
強制：只輸出單一 JSON 物件（不可有任何多餘文字）
必須輸出 top5（長度=5）
每檔必填：symbol, score(0-100), confidence(0-100), eta_minutes("5-15"/"10-30"/"30-60"),
stage("蓄勢"/"點火"/"觸發"/"追價風險"), entry, stop, takeProfit[], invalidation, reasons[], risks[]
你只能使用提供的摘要，不可假裝看圖。
若資料不足，也要用 swing_low_20 / swing_high_20 / atr14 推出合理 entry/stop/tp。
  `.trim();

  const user = {
    mode: "LONG_ONLY",
    ask: "請從 Top20 候選中選出 Top5（最可能 5~30 分鐘內向上表態且不追價），並給交易計畫。",
    candidates: top20Summaries
  };

  return [
    { role:"system", content: system },
    { role:"user", content: JSON.stringify(user) }
  ];
}

function normalizeAiPick(sym, summary, pick) {
  const price = summary.price || 0;
  const atr = summary.atr14 || (price * 0.002);
  const low = summary.swing_low_20 || (price - 2*atr);
  const high = summary.swing_high_20 || (price + 2*atr);

  const safe = (x, fallback) => (x === null || x === undefined || Number.isNaN(x)) ? fallback : x;

  const out = {
    symbol: sym,
    score: clamp(safe(pick.score, summary.preScore || 50), 0, 100),
    confidence: clamp(safe(pick.confidence, 60), 0, 100),
    eta_minutes: pick.eta_minutes || "10-30",
    stage: pick.stage || summary.stage || "蓄勢",
    direction: "做多",

    entry: pick.entry && typeof pick.entry === "object" ? pick.entry : null,
    stop: pick.stop && typeof pick.stop === "object" ? pick.stop : null,
    takeProfit: Array.isArray(pick.takeProfit) ? pick.takeProfit : [],
    invalidation: pick.invalidation || "",
    reasons: Array.isArray(pick.reasons) ? pick.reasons : [],
    risks: Array.isArray(pick.risks) ? pick.risks : [],
    notes: pick.notes || ""
  };

  if (!out.entry) {
    const z1 = price * 0.998;
    const z2 = price * 0.994;
    out.entry = {
      type: (summary.stage === "觸發") ? "market" : "limit",
      zone: [Number(z1.toFixed(8)), Number(z2.toFixed(8))].sort((a,b)=>a-b),
      trigger: (summary.stage === "觸發") ? "觸發階段可市價分批進" : "等待回踩/不追價，落入區間分批",
      logic: "用量能+主動買差額當前-續力，避免追價"
    };
  }

  if (!out.stop) {
    const stopPrice = low - 0.4 * atr;
    out.stop = { price: Number(stopPrice.toFixed(8)), logic: "以 swing low_20 下方 + 0.4ATR 作失效點" };
  }

  if (!out.takeProfit.length) {
    const tp1 = Math.min(high, price + 1.2*atr);
    const tp2 = price + 2.2*atr;
    const tp3 = price + 3.2*atr;
    out.takeProfit = [
      { price: Number(tp1.toFixed(8)), pct: 35, logic: "先回收風險" },
      { price: Number(tp2.toFixed(8)), pct: 35, logic: "趨勢延伸" },
      { price: Number(tp3.toFixed(8)), pct: 30, logic: "噴出尾段" }
    ];
  }

  if (!out.invalidation) out.invalidation = "跌破 stop 或 5m 主動買差額轉負且量能退潮";
  if (!out.reasons.length) out.reasons = ["候選池異常分數較高（量能/主動買/OI/反追價綜合）"];
  if (!out.risks.length) out.risks = ["若 5m 漲幅快速擴大屬追價風險，需等回踩再進"];

  return out;
}

async function runAIOnce(force=false) {
  const now = Date.now();
  if (!force) {
    if (!AUTO_AI) return;
    if (now < aiBackoffUntil) return;
    if (now - lastAiTs < CONFIG.AI_INTERVAL_MS) return;
  }

  const top20 = candidatesTop20.slice(0, CONFIG.CANDIDATE_LIMIT);
  if (top20.length < CONFIG.CANDIDATE_LIMIT) {
    setStatus("aiStatus", `等待 Top20 成形（目前 ${top20.length}）`, "warn");
    return;
  }

  const goodCount = top20.map(s => symState[s]).filter(x => x && ["蓄勢","點火","觸發","熱機中"].includes(x.stage)).length;
  if (goodCount < 3) {
    setStatus("aiStatus", `續力不足（可盯標的 < 3），暫不打AI`, "warn");
    return;
  }

  const key = $("aiKey").value.trim();
  if (!key) { setStatus("aiStatus","缺 Groq Key","bad"); return; }

  const model = $("modelSel").value;
  setStatus("aiStatus", "AI 分析中…", "warn");

  const summaries = top20.map(sym => buildSummary(sym)).filter(Boolean);
  $("debugJSON").textContent = JSON.stringify({ top20: summaries }, null, 2);

  try {
    const messages = buildAiPrompt(summaries);
    const obj = await groqChatCompletion({ apiKey:key, model, messages, maxOut: 420 });

    const top5Raw = Array.isArray(obj.top5) ? obj.top5 : [];
    if (!top5Raw.length) throw new Error("AI JSON 缺 top5");

    const by = {};
    const picks = [];
    const top20Set = new Set(top20);

    for (const p of top5Raw) {
      const sym = (p.symbol || "").toUpperCase();
      if (!top20Set.has(sym)) continue;
      const sum = summaries.find(x => x.symbol === sym) || summaries[0];
      const norm = normalizeAiPick(sym, sum, p);
      by[sym] = norm;
      picks.push(norm);
      if (picks.length >= CONFIG.TOP5_LIMIT) break;
    }

    if (picks.length < CONFIG.TOP5_LIMIT) {
      const remain = summaries
        .filter(x => !by[x.symbol])
        .sort((a,b) => (b.preScore||0) - (a.preScore||0));
      for (const r of remain) {
        const norm = normalizeAiPick(r.symbol, r, {});
        by[r.symbol] = norm;
        picks.push(norm);
        if (picks.length >= CONFIG.TOP5_LIMIT) break;
      }
    }

    picks.sort((a,b) => (b.score - a.score) || (b.confidence - a.confidence));

    aiTop5 = picks;
    aiBySymbol = by;

    const top1 = picks[0];
    if (!pinnedTop1.symbol) {
      pinnedTop1 = { symbol: top1.symbol, score: top1.score, confidence: top1.confidence, ts: Date.now() };
    } else {
      const dt = Date.now() - pinnedTop1.ts;
      const same = pinnedTop1.symbol === top1.symbol;
      const stronger = (top1.score >= pinnedTop1.score + 4) || (top1.confidence >= pinnedTop1.confidence + 8);
      if (!same && (stronger || dt > 90*1000)) {
        pinnedTop1 = { symbol: top1.symbol, score: top1.score, confidence: top1.confidence, ts: Date.now() };
      }
    }

    lastAiTs = Date.now();
    setStatus("aiStatus", `AI OK (${model}) @ ${nowStr()}`, "ok");
    renderTop5Cards();

  } catch (e) {
    const msg = String(e?.message || e);
    console.error(e);

    if (msg.includes("429")) {
      aiBackoffUntil = Date.now() + 45*1000;
      setStatus("aiStatus", "AI 429 限流，backoff 45s", "bad");
    } else {
      setStatus("aiStatus", "AI FAIL: " + msg.slice(0,80), "bad");
    }
  }
}

async function testAI() {
  const key = $("aiKey").value.trim();
  if (!key) return alert("請先輸入 Groq API Key");
  const model = $("modelSel").value;

  try {
    setStatus("aiStatus", "Test AI…", "warn");
    const obj = await groqChatCompletion({
      apiKey: key,
      model,
      maxOut: 200,
      messages: [
        { role:"system", content:"只輸出 JSON 物件，不要任何多餘文字。" },
        { role:"user", content: JSON.stringify({ ping:"pong", now: Date.now() }) }
      ]
    });
    console.log("Test AI OK:", obj);
    setStatus("aiStatus", `Test OK (${model})`, "ok");
    alert("Test AI OK（看 Console）");
  } catch (e) {
    console.error(e);
    setStatus("aiStatus", "Test FAIL", "bad");
    alert("Test AI FAIL: " + (e?.message || e));
  }
}

/* ===========================
   Render: Top5 cards
=========================== */
function stageClass(stage) {
  if (stage === "蓄勢") return "stage-setup";
  if (stage === "點火") return "stage-ignite";
  if (stage === "觸發") return "stage-confirm";
  if (stage === "追價風險") return "stage-chase";
  return "stage-cool";
}

function renderTop5Cards() {
  $("top5N").textContent = aiTop5.length;
  $("pinnedSym").textContent = pinnedTop1.symbol || "-";

  const wrap = $("cards");
  wrap.innerHTML = "";

  const pinned = pinnedTop1.symbol;

  let list = [...aiTop5];
  if (pinned) {
    const idx = list.findIndex(x => x.symbol === pinned);
    if (idx > 0) {
      const t = list.splice(idx,1)[0];
      list.unshift(t);
    }
  }

  for (const p of list) {
    const sum = buildSummary(p.symbol);
    const isTop1 = (p.symbol === pinned);

    const tags = (sum?.tags || []).slice(0,6).map(t => `<span class="badge px-2 py-1 rounded-lg tiny2">${t}</span>`).join(" ");
    const stage = sum?.stage || p.stage || "-";

    const card = document.createElement("div");
    card.className = `card p-4 ${isTop1 ? "card-top1" : ""}`;

    const tpText = (p.takeProfit || []).slice(0,3).map(tp => `TP ${fmt(tp.price,6)}（${fmt(tp.pct,0)}%）`).join(" / ");
    const reasons = (p.reasons||[]).slice(0,4).map(x=>`• ${x}`).join("\n") || "• -";
    const risks = (p.risks||[]).slice(0,4).map(x=>`• ${x}`).join("\n") || "• -";
    const entryZone = p.entry?.zone ? `${fmt(p.entry.zone[0],6)} ~ ${fmt(p.entry.zone[1],6)}` : "-";

    card.innerHTML = `
      <div class="grid grid-cols-1 xl:grid-cols-2 gap-4">
        <div>
          <div class="flex items-start justify-between gap-3">
            <div>
              <div class="text-white font-black text-xl">${p.symbol}</div>
              <div class="tiny muted mt-1">
                價格: <b class="text-zinc-200">${fmt(sum?.price, 6)}</b>
                <span class="mx-2 muted">|</span>
                5m漲跌: <b class="${(sum?.ret5m_pct||0)>=0 ? "ok":"bad"}">${fmt(sum?.ret5m_pct,2)}%</b>
                <span class="mx-2 muted">|</span>
                前端分: <b>${fmt(sum?.preScore,0)}</b>
              </div>
              <div class="tiny mt-2 ${stageClass(stage)} font-bold">階段：${stage}</div>
            </div>
          </div>

          <div class="mt-3 flex flex-wrap gap-2">${tags || `<span class="muted tiny">tags: -</span>`}</div>

          <div class="mt-3 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
            <div class="kv tiny">量能Z(5m): <b>${fmt(sum?.volZ_5m,2)}</b></div>
            <div class="kv tiny">主動買差額(5m): <b>${fmt(sum?.active_buy_delta_5m_notional,0)}</b></div>
            <div class="kv tiny">主動買入比(5m): <b>${fmt(((sum?.active_buy_imbalance_5m ?? null)===null)?null:(0.5 + (sum.active_buy_imbalance_5m/2)),3)}</b></div>

            <div class="kv tiny">OIΔ(5m): <b>${fmt(sum?.oi_delta_5m,2)}</b></div>
            <div class="kv tiny">OIΔ(4h): <b>${fmt(sum?.oi_delta_4h,2)}</b></div>
            <div class="kv tiny">資金費率(%): <b>${fmt(sum?.funding_pct,3)}</b> / premium(%): <b>${fmt(sum?.premium_pct,3)}</b></div>

            <div class="kv tiny">ATR14: <b>${fmt(sum?.atr14,6)}</b></div>
            <div class="kv tiny">SwingLow20: <b>${fmt(sum?.swing_low_20,6)}</b></div>
            <div class="kv tiny">SwingHigh20: <b>${fmt(sum?.swing_high_20,6)}</b></div>

            <div class="kv tiny">Range20(%): <b>${fmt(sum?.range_20_pct,2)}</b></div>
            <div class="kv tiny">distSMA20/ATR: <b>${fmt(sum?.dist_sma20_atr,2)}</b></div>
            <div class="kv tiny">Warmup: <b>${sum?.warmup_mode ? "FAST" : "SELF"}</b> | hist: <b>${sum?.hist_buckets ?? 0}</b></div>
          </div>
        </div>

        <div class="ai-box">
          <div class="flex items-center justify-between">
            <div class="text-white font-bold">AI 建議（中文）</div>
            <div class="tiny muted">模型：${$("modelSel").value}</div>
          </div>

          <div class="mt-2 tiny">
            方向：<b class="ok">做多</b>
            <span class="mx-2 muted">|</span>
            分數：<b>${fmt(p.score,0)}</b>
            <span class="mx-2 muted">|</span>
            信心：<b>${fmt(p.confidence,0)}/100</b>
          </div>

          <div class="mt-1 tiny">
            ETA：<b>${p.eta_minutes || "-"}</b>
            <span class="mx-2 muted">|</span>
            階段：<b class="${stageClass(p.stage)}">${p.stage || "-"}</b>
          </div>

          <div class="hr my-2"></div>

          <div class="tiny"><b>進場</b>：${p.entry?.type || "-"} | 區間：<b>${entryZone}</b></div>
          <div class="tiny muted">觸發：${p.entry?.trigger || "-"}</div>

          <div class="mt-1 tiny"><b>停損</b>：<b class="bad">${fmt(p.stop?.price,6)}</b></div>
          <div class="tiny muted">失效：${p.invalidation || "-"}</div>

          <div class="mt-1 tiny"><b>止盈</b>：${tpText || "-"}</div>

          <div class="hr my-2"></div>
          <div class="tiny"><b>理由</b>：</div>
          <pre class="tiny2 whitespace-pre-wrap muted">${reasons}</pre>
          <div class="tiny"><b>風險</b>：</div>
          <pre class="tiny2 whitespace-pre-wrap muted">${risks}</pre>

          <div class="tiny muted mt-2">更新：${nowStr()}</div>
        </div>
      </div>
    `;
    wrap.appendChild(card);
  }
}

/* ===========================
   miniTicker
=========================== */
function startMiniTicker() {
  const ws = new WebSocket("wss://fstream.binance.com/ws/!miniTicker@arr");
  wsMini = ws;

  ws.onopen = () => {
    $("hb").classList.add("hb-on");
    setStatus("binStatus","WS OK","ok");
  };
  ws.onerror = () => setStatus("binStatus","WS error","warn");
  ws.onclose = () => {
    setStatus("binStatus","WS closed","warn");
    setTimeout(() => startMiniTicker(), 1200);
  };
  ws.onmessage = () => { $("lastTick").textContent = nowStr(); };
}

/* ===========================
   Main
=========================== */
async function boot() {
  loadKey();
  $("autoLbl").textContent = `Auto AI: ${AUTO_AI ? "ON" : "OFF"}`;

  setStatus("binStatus","初始化…","warn");
  setStatus("aiStatus","-","muted");

  startMiniTicker();

  await refreshPremiumAll().catch(()=>{});
  await refreshUniverse().catch(e => console.error(e));

  setInterval(() => refreshPremiumAll().catch(()=>{}), 60*1000);
  setInterval(() => refreshUniverse().catch(()=>{}), CONFIG.UNIVERSE_REFRESH_MS);

  setInterval(() => {
    buildTop20Candidates();
    if (aiTop5.length) renderTop5Cards();
  }, CONFIG.CANDIDATE_REFRESH_MS);

  setInterval(() => {
    for (const sym of candidatesTop20) ensureKlinesAndOI(sym);
  }, 60*1000);

  setInterval(() => runAIOnce(false), 1500);
  setTimeout(() => runAIOnce(true), 8000);
}

boot();
</script>
</body>
</html>
