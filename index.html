<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRIDENT V7 - Anomaly Scanner (Front-end Only)</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background:#050505; color:#d4d4d8; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .card { background:#0f0f11; border:1px solid #1f1f23; }
    .pill { border:1px solid #2a2a31; background:#0b0b0d; }
    .ok { color:#22c55e; }
    .bad { color:#ef4444; }
    .muted { color:#71717a; }
    .mono { font-variant-numeric: tabular-nums; }
  </style>
</head>
<body class="p-4">

  <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between mb-4">
    <div class="flex items-center gap-3">
      <span id="hb" class="inline-block w-2 h-2 rounded-full bg-zinc-600"></span>
      <div>
        <div class="text-white font-black italic text-xl leading-none">TRIDENT <span class="text-red-500">V7</span></div>
        <div class="text-[11px] muted">Anomaly-first scanner → Top5 → Gemini JSON (Top3 only)</div>
        <div id="status" class="text-[11px] muted mono mt-1">status: -</div>
      </div>
    </div>

    <div class="flex flex-col md:flex-row gap-2 md:items-end">
      <div class="flex gap-2 items-center">
        <input id="geminiKey" type="password" placeholder="Paste Gemini API Key (stored in localStorage)"
               class="w-80 max-w-full px-3 py-2 rounded text-[12px] bg-zinc-900 border border-zinc-700 text-white outline-none" />
        <button id="saveKeyBtn" class="px-3 py-2 rounded text-[12px] font-bold bg-zinc-800 text-zinc-200 hover:bg-zinc-700">Save</button>
        <button id="clearKeyBtn" class="px-3 py-2 rounded text-[12px] font-bold bg-zinc-900 text-zinc-400 border border-zinc-700 hover:bg-zinc-800">Clear</button>
      </div>

      <div class="flex gap-2 items-center">
        <button id="testGeminiBtn" class="px-3 py-2 rounded text-[12px] font-bold bg-emerald-700 hover:bg-emerald-600 text-white">
          Test Gemini
        </button>
        <button id="analyzeBtn" class="px-3 py-2 rounded text-[12px] font-black bg-blue-600 hover:bg-blue-500 text-white">
          Analyze Top (Gemini)
        </button>
        <button id="resetBtn" class="px-3 py-2 rounded text-[12px] font-bold bg-zinc-900 text-zinc-400 border border-zinc-700 hover:bg-zinc-800">
          RESET
        </button>
      </div>
    </div>
  </div>

  <div class="grid grid-cols-1 xl:grid-cols-2 gap-4">
    <div class="card rounded-lg p-4">
      <div class="flex items-center justify-between mb-3">
        <div class="text-white font-black">Top 5 Candidates</div>
        <div class="text-[11px] muted">更新：<span id="lastUpdate">-</span></div>
      </div>
      <div id="top5" class="flex flex-col gap-3"></div>
    </div>

    <div class="card rounded-lg p-4">
      <div class="flex items-center justify-between mb-3">
        <div class="text-white font-black">Gemini Output (JSON)</div>
        <div class="text-[11px] muted">模型：<span id="modelName">-</span> | max_out=<span id="maxOut">-</span></div>
      </div>
      <div id="geminiOut" class="flex flex-col gap-3"></div>
    </div>
  </div>

<script>
/**
 * WS:
 * - wss://fstream.binance.com/ws/!markPrice@arr  (3000ms)
 * - wss://fstream.binance.com/stream?streams=<sym>@kline_5m/...
 * REST (throttled):
 * - https://fapi.binance.com/futures/data/openInterestHist?symbol=...&period=5m|4h
 * Gemini REST:
 * - https://generativelanguage.googleapis.com/v1beta/models/<model>:generateContent  (x-goog-api-key)
 */

// ===================== Config =====================
const CFG = {
  EXCLUDE: new Set(['BTCUSDT','ETHUSDT','SOLUSDT','XRPUSDT','BNBUSDT','BNXUSDT']),

  TICK_MS: 3000,
  WIN_5M_POINTS: 100,      // 5m with 3s ticks
  HIST_4H_POINTS: 240,     // 4h with 1-min samples

  // Candidate selection (anomaly-first)
  VOL_Z_TH: 1.8,           // 先放寬，較快出 Top5
  FUND_Z_TH: 1.2,
  CANDIDATE_MAX: 40,

  // OI throttling
  OI_CHECK_MAX: 12,
  OI_REFRESH_MS: 60_000,

  // Anti-pump / continuation-ish guard
  MAX_RET_5M_PCT: 0.9,
  MAX_ABS_PREMIUM_PCT: 0.25,
  MAX_RANGE_Z: 2.5,

  // Scoring weights (only for picking Top5)
  W_VOLZ: 1.5,
  W_FUNDZ: 0.8,
  W_VOL5MZ: 0.7,
  W_IMB5M: 1.0,
  W_OI5MZ: 0.6,
  W_ALIGN: 0.6,

  // Gemini cost-control
  GEMINI_MODELF: {
    MODEL: "gemini-2.5-flash",
    TOPK: 3,                 // ✅ 只分析 Top5 中最高分的前 2~3 支（改這裡）
    MAX_OUTPUT_TOKENS: 400,   // ✅ 限制輸出長度
    TEMP: 0.2,
    AUTO_INTERVAL_MS: 120000, // ✅ 每2分鐘最多跑一次
    AUTO_CHECK_MS: 30000,
  },

  // Robust Z warmup
  ROBUST_MIN_HIST: 6,       // ✅ 6分鐘後就能動（原本20）
};

// ===================== Utils =====================
class Ring {
  constructor(n){ this.n=n; this.a=[]; this.i=0; }
  push(x){
    if (this.a.length < this.n) this.a.push(x);
    else { this.a[this.i] = x; this.i = (this.i+1) % this.n; }
  }
  values(){
    if (this.a.length < this.n || this.i===0) return this.a.slice();
    return this.a.slice(this.i).concat(this.a.slice(0,this.i));
  }
  get size(){ return this.a.length; }
  last(){
    if (this.a.length===0) return null;
    if (this.a.length < this.n) return this.a[this.a.length-1];
    const idx = (this.i - 1 + this.n) % this.n;
    return this.a[idx];
  }
}

function median(arr){
  if (!arr.length) return 0;
  const a = arr.slice().sort((x,y)=>x-y);
  const m = Math.floor(a.length/2);
  return a.length%2 ? a[m] : (a[m-1]+a[m])/2;
}
function mad(arr, med){
  if (!arr.length) return 0;
  const dev = arr.map(x=>Math.abs(x - med));
  return median(dev);
}
function robustZ(x, hist){
  // z = (x - median) / (1.4826*MAD)
  if (!hist || hist.length < CFG.ROBUST_MIN_HIST) return null;
  const med = median(hist);
  const m = mad(hist, med) || 1e-12;
  return (x - med) / (1.4826*m);
}
function linSlope(y){
  const n = y.length;
  if (n < 10) return 0;
  let sx=0, sy=0, sxx=0, sxy=0;
  for (let i=0;i<n;i++){
    sx += i; sy += y[i]; sxx += i*i; sxy += i*y[i];
  }
  const den = n*sxx - sx*sx;
  if (Math.abs(den) < 1e-12) return 0;
  return (n*sxy - sx*sy) / den;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function fmt(x, d=3){
  if (x===null || x===undefined || Number.isNaN(x)) return '-';
  const v = Number(x);
  if (!Number.isFinite(v)) return '-';
  return v.toFixed(d);
}
function pct(x, d=2){ return fmt(x, d) + '%'; }
function sign(x, eps=1e-6){
  if (x > eps) return 1;
  if (x < -eps) return -1;
  return 0;
}
function escapeHtml(s){
  return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

// ===================== State =====================
const S = new Map(); // symbol -> state
let wsMark = null;
let wsKline = null;
let symbolsAll = [];
let candidates = [];
let top5 = [];
let lastHeartbeat = 0;
let lastCandidateHash = "";
let lastTop5At = 0;

function stOf(sym){
  if (S.has(sym)) return S.get(sym);
  const st = {
    sym,
    // mark stream
    lastP: null,
    lastI: null,
    lastR: null,
    lastT: null,
    retRing: new Ring(CFG.WIN_5M_POINTS),      // log returns (3s)
    premRing: new Ring(CFG.WIN_5M_POINTS),     // premium series (3s)
    rvHist: new Ring(CFG.HIST_4H_POINTS),      // 1-min samples
    premSlopeHist: new Ring(CFG.HIST_4H_POINTS),
    lastSampleAt: 0,
    volZ: null,
    fundZ: null,
    rv5m: null,
    premNow: null,
    premSlope: null,
    ret5mPct: null,

    // kline 5m (only for candidates)
    k5Bars: [],              // closed bars
    vol5Hist: new Ring(48),
    imb5Hist: new Ring(48),
    rangeHist: new Ring(48),
    vol5mZ: null,
    imb5m: null,
    imb4h: null,
    rangeZ: null,

    // OI
    oi: { ts: 0, dOi5m: null, oi5mZ: null, dOi4h: null },

    // scoring
    dirHint: 0,
    score: null,

    // local pattern tags
    patternTags: [],
    levels: { swingHigh: null, swingLow: null, mid: null },
  };
  S.set(sym, st);
  return st;
}

// ===================== Universe =====================
async function loadUniverse(){
  const ex = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo').then(r=>r.json());
  const list = (ex.symbols || [])
    .filter(x => x.status === 'TRADING' && x.contractType === 'PERPETUAL' && x.quoteAsset === 'USDT')
    .map(x => x.symbol)
    .filter(s => !CFG.EXCLUDE.has(s));
  symbolsAll = list;
}

// ===================== Mark stream =====================
function connectMark(){
  if (wsMark) try{ wsMark.close(); }catch(_){}
  wsMark = new WebSocket('wss://fstream.binance.com/ws/!markPrice@arr'); // 3000ms
  wsMark.onopen = () => { lastHeartbeat = Date.now(); };
  wsMark.onmessage = (ev) => {
    lastHeartbeat = Date.now();
    const arr = JSON.parse(ev.data);
    for (const u of arr){
      const sym = u.s;
      if (!sym || CFG.EXCLUDE.has(sym)) continue;
      const st = stOf(sym);

      const p = Number(u.p);
      const i = Number(u.i);
      const r = Number(u.r);

      if (Number.isFinite(p) && st.lastP){
        const ret = Math.log(p / st.lastP);
        st.retRing.push(ret);
      }
      st.lastP = Number.isFinite(p) ? p : st.lastP;
      st.lastI = Number.isFinite(i) ? i : st.lastI;
      st.lastR = Number.isFinite(r) ? r : st.lastR;
      st.lastT = u.T ?? st.lastT;

      if (st.lastP && st.lastI){
        const prem = (st.lastP - st.lastI) / st.lastI;
        st.premRing.push(prem);
      }
    }
  };
  wsMark.onclose = () => setTimeout(connectMark, 2000);
  wsMark.onerror = () => { try{ wsMark.close(); }catch(_){} };
}

// ===================== Sampling =====================
function sampleMetrics(){
  const now = Date.now();
  for (const sym of symbolsAll){
    const st = stOf(sym);
    if (st.retRing.size < 20 || st.premRing.size < 20) continue;

    const rets = st.retRing.values();
    let sum = 0, sumsq = 0;
    for (const r of rets){ sum += r; sumsq += r*r; }

    st.ret5mPct = (Math.exp(sum) - 1) * 100;
    st.rv5m = Math.sqrt(sumsq) * 100;

    const premNow = st.premRing.last();
    st.premNow = premNow * 100;

    const premSeries = st.premRing.values();
    st.premSlope = linSlope(premSeries) * 1e4;

    if (!st.lastSampleAt || (now - st.lastSampleAt >= 60_000)){
      st.rvHist.push(st.rv5m);
      st.premSlopeHist.push(st.premSlope);
      st.lastSampleAt = now;
    }

    st.volZ = robustZ(st.rv5m, st.rvHist.values());
    st.fundZ = robustZ(st.premSlope, st.premSlopeHist.values());
  }
}

// ===================== Candidates =====================
function computeCandidates(){
  const arr = [];
  for (const sym of symbolsAll){
    const st = stOf(sym);
    if (st.volZ === null) continue;

    const volPass  = Math.abs(st.volZ) >= CFG.VOL_Z_TH;
    const retPass  = (st.ret5mPct !== null) && (Math.abs(st.ret5mPct) <= CFG.MAX_RET_5M_PCT);
    const premPass = (st.premNow !== null) && (Math.abs(st.premNow) <= CFG.MAX_ABS_PREMIUM_PCT);

    const fundPass = (st.fundZ !== null) ? (Math.abs(st.fundZ) >= CFG.FUND_Z_TH) : false;

    if (!volPass || !retPass || !premPass) continue;

    const preScore = Math.abs(st.volZ) + 0.6*(Math.abs(st.fundZ || 0)) + (fundPass ? 0.4 : 0);
    arr.push({ sym, preScore });
  }
  arr.sort((a,b)=>b.preScore - a.preScore);
  candidates = arr.slice(0, CFG.CANDIDATE_MAX).map(x=>x.sym);
}

// ===================== Kline subscription =====================
function connectKlineForCandidates(){
  const hash = candidates.join('|');
  if (hash === lastCandidateHash) return;
  lastCandidateHash = hash;

  if (wsKline) try{ wsKline.close(); }catch(_){}
  if (!candidates.length) return;

  const streams = candidates.map(s => `${s.toLowerCase()}@kline_5m`);
  const url = `wss://fstream.binance.com/stream?streams=${streams.join('/')}`;
  wsKline = new WebSocket(url);

  wsKline.onmessage = (ev) => {
    const msg = JSON.parse(ev.data);
    const data = msg.data;
    if (!data || data.e !== 'kline') return;
    const sym = data.s;
    const k = data.k;
    if (!k || !k.x) return; // only closed 5m candle

    const st = stOf(sym);
    const o = Number(k.o), h = Number(k.h), l = Number(k.l), c = Number(k.c);
    const v = Number(k.v);
    const V = Number(k.V); // taker buy base volume

    const imb = (v > 0) ? ((2*V - v) / v) : 0;  // [-1,1]
    const range = (c > 0) ? ((h - l) / c) : 0;

    st.vol5Hist.push(v);
    st.imb5Hist.push(imb);
    st.rangeHist.push(range);

    st.k5Bars.push({ t:k.T, o,h,l,c,v,V, imb, range });
    if (st.k5Bars.length > 80) st.k5Bars.shift();

    st.imb5m = imb;

    // VW imbalance over 4h (last 48 bars)
    const vols = st.vol5Hist.values();
    const imbs = st.imb5Hist.values();
    let wSum=0, vSum=0;
    for (let i=0;i<Math.min(vols.length, imbs.length); i++){
      const vv = vols[i];
      wSum += imbs[i] * vv;
      vSum += vv;
    }
    st.imb4h = vSum > 0 ? (wSum / vSum) : 0;

    st.vol5mZ = robustZ(v, st.vol5Hist.values());
    st.rangeZ = robustZ(range, st.rangeHist.values());

    // Update local patterns / levels
    computeLocalPattern(st);
  };

  wsKline.onclose = () => setTimeout(connectKlineForCandidates, 1500);
  wsKline.onerror = () => { try{ wsKline.close(); }catch(_){} };
}

// ===================== OI (throttled) =====================
async function fetchOI(sym){
  const st = stOf(sym);
  const now = Date.now();
  if (now - st.oi.ts < CFG.OI_REFRESH_MS) return;

  const url5 = `https://fapi.binance.com/futures/data/openInterestHist?symbol=${sym}&period=5m&limit=50`;
  const url4 = `https://fapi.binance.com/futures/data/openInterestHist?symbol=${sym}&period=4h&limit=2`;
  const [d5, d4] = await Promise.all([
    fetch(url5).then(r=>r.json()).catch(()=>null),
    fetch(url4).then(r=>r.json()).catch(()=>null),
  ]);

  function sortByTs(a){ return (a||[]).slice().sort((x,y)=>(x.timestamp||0)-(y.timestamp||0)); }

  const a5 = sortByTs(d5);
  if (a5.length >= 10){
    const series = a5.map(x => Number(x.sumOpenInterestValue ?? x.sumOpenInterest));
    const diffs = [];
    for (let i=1;i<series.length;i++) diffs.push(series[i] - series[i-1]);
    const lastDiff = diffs[diffs.length-1];
    const hist = diffs.slice(0, -1);
    st.oi.dOi5m = lastDiff;
    st.oi.oi5mZ = robustZ(lastDiff, hist);
  }

  const a4 = sortByTs(d4);
  if (a4.length === 2){
    const s0 = Number(a4[0].sumOpenInterestValue ?? a4[0].sumOpenInterest);
    const s1 = Number(a4[1].sumOpenInterestValue ?? a4[1].sumOpenInterest);
    st.oi.dOi4h = (s1 - s0);
  }

  st.oi.ts = now;
}

async function refreshOIForStrongOnes(){
  const scored = candidates.map(sym=>{
    const st = stOf(sym);
    const s = Math.abs(st.volZ||0) + 0.7*Math.abs(st.fundZ||0) + 0.5*Math.abs(st.vol5mZ||0) + 0.7*Math.abs(st.imb5m||0);
    return {sym, s};
  }).sort((a,b)=>b.s-a.s).slice(0, CFG.OI_CHECK_MAX);

  for (const x of scored){
    await fetchOI(x.sym);
  }
}

// ===================== Top5 scoring =====================
function computeTop5(){
  const arr = [];
  for (const sym of candidates){
    const st = stOf(sym);
    if (st.volZ===null) continue;

    const rangeOk = (st.rangeZ===null) ? true : (Math.abs(st.rangeZ) <= CFG.MAX_RANGE_Z);

    const d = sign(st.imb5m || 0, 0.03);
    st.dirHint = d;

    const align = (d !== 0 && sign(st.premSlope||0, 0.0001) === d) ? 1 : 0;

    let score =
      CFG.W_VOLZ  * Math.abs(st.volZ || 0) +
      CFG.W_FUNDZ * Math.abs(st.fundZ || 0) +
      CFG.W_VOL5MZ* Math.abs(st.vol5mZ || 0) +
      CFG.W_IMB5M * Math.abs(st.imb5m || 0) +
      CFG.W_OI5MZ * Math.abs(st.oi.oi5mZ || 0) +
      CFG.W_ALIGN * align;

    if (!rangeOk) score -= 0.8;
    if (st.ret5mPct!==null && Math.abs(st.ret5mPct) > CFG.MAX_RET_5M_PCT) score -= 1.2;

    st.score = score;
    arr.push({ sym, score });
  }
  arr.sort((a,b)=>b.score-a.score);
  top5 = arr.slice(0,5).map(x=>x.sym);

  lastTop5At = Date.now();
  document.getElementById('lastUpdate').innerText = new Date(lastTop5At).toLocaleTimeString();
}

// ===================== Local pattern detection (front-end) =====================
function computeLocalPattern(st){
  const bars = st.k5Bars;
  if (bars.length < 3) { st.patternTags = []; return; }
  const last = bars[bars.length-1];
  const prev = bars[bars.length-2];
  const prev2 = bars[bars.length-3];

  const tags = [];

  const body = Math.abs(last.c - last.o);
  const range = Math.max(1e-12, last.h - last.l);
  const bodyPct = body / range;

  const upperWick = last.h - Math.max(last.o, last.c);
  const lowerWick = Math.min(last.o, last.c) - last.l;

  // basic candle tags
  if (bodyPct < 0.2) tags.push("doji-ish");
  if (lowerWick > 2*body && upperWick < body) tags.push("hammer-ish");
  if (upperWick > 2*body && lowerWick < body) tags.push("shootingstar-ish");

  // inside bar
  if (last.h < prev.h && last.l > prev.l) tags.push("inside-bar");

  // engulfing
  const lastBull = last.c > last.o;
  const prevBull = prev.c > prev.o;
  const lastBodyHi = Math.max(last.o, last.c);
  const lastBodyLo = Math.min(last.o, last.c);
  const prevBodyHi = Math.max(prev.o, prev.c);
  const prevBodyLo = Math.min(prev.o, prev.c);

  if (lastBull && !prevBull && lastBodyHi >= prevBodyHi && lastBodyLo <= prevBodyLo) tags.push("bull-engulf");
  if (!lastBull && prevBull && lastBodyHi >= prevBodyHi && lastBodyLo <= prevBodyLo) tags.push("bear-engulf");

  // range contraction (squeeze-ish)
  const rArr = st.rangeHist.values();
  if (rArr.length >= 20){
    const medR = median(rArr);
    if (last.range < 0.75*medR) tags.push("range-compress");
    if (last.range > 1.6*medR) tags.push("range-expand");
  }

  // vol spike
  const vArr = st.vol5Hist.values();
  if (vArr.length >= 20){
    const medV = median(vArr);
    if (last.v > 1.8*medV) tags.push("vol-spike");
    if (last.v < 0.6*medV) tags.push("vol-dry");
  }

  // imbalance persistence
  if (Math.sign(prev2.imb) === Math.sign(prev.imb) && Math.sign(prev.imb) === Math.sign(last.imb) && Math.abs(last.imb) > 0.08){
    tags.push("imb-3bars");
  }

  // simple 5m micro-trend (last 6 closes)
  const closes = bars.slice(-6).map(b=>b.c);
  const slope = linSlope(closes);
  if (slope > 0) tags.push("microtrend-up");
  if (slope < 0) tags.push("microtrend-down");

  // swing levels (last 20 bars)
  const seg = bars.slice(-20);
  const swingHigh = Math.max(...seg.map(b=>b.h));
  const swingLow  = Math.min(...seg.map(b=>b.l));
  st.levels.swingHigh = swingHigh;
  st.levels.swingLow = swingLow;
  st.levels.mid = (swingHigh + swingLow)/2;

  st.patternTags = tags;
}

// ===================== Gemini =====================
const GEMINI_MODEL = CFG.GEMINIF.MODEL;
document.getElementById('modelName').innerText = GEMINI_MODEL;
document.getElementById('maxOut').innerText = CFG.GEMINIF.MAX_OUTPUT_TOKENS;

function getGeminiKey(){
  const k = document.getElementById('geminiKey').value.trim();
  return k || (localStorage.getItem('GEMINI_API_KEY') || "");
}
function saveGeminiKey(){
  const k = document.getElementById('geminiKey').value.trim();
  if (!k) return alert("Key empty");
  localStorage.setItem('GEMINI_API_KEY', k);
  alert("Saved to localStorage (this browser only).");
}
function clearGeminiKey(){
  localStorage.removeItem('GEMINI_API_KEY');
  document.getElementById('geminiKey').value = "";
  alert("Cleared.");
}

function buildGeminiPrompt(sym){
  const st = stOf(sym);
  const dir = st.dirHint === 1 ? "LONG" : (st.dirHint === -1 ? "SHORT" : "NEUTRAL");

  // compact structure summary (NO 1m/5m 30bars dump)
  const lastBars = st.k5Bars.slice(-6).map(b => ({
    o: +b.o, h:+b.h, l:+b.l, c:+b.c,
    v: +b.v,
    imb: +b.imb
  }));

  const summary = {
    symbol: sym,
    direction_hint: dir,
    // anomalies
    vol_z: st.volZ,
    fund_z: st.fundZ,
    vol5m_z: st.vol5mZ,
    oi_z_5m: st.oi.oi5mZ,
    // short-horizon guards
    ret_5m_pct: st.ret5mPct,
    premium_pct: st.premNow,
    range_z: st.rangeZ,
    // flow
    imb_5m: st.imb5m,
    imb_4h: st.imb4h,
    oi_d_5m: st.oi.dOi5m,
    oi_d_4h: st.oi.dOi4h,
    // local patterns
    pattern_tags: st.patternTags,
    levels: st.levels,
    last_price: st.lastP,
    last_6x_5m: lastBars
  };

  return `
你是「合約短線（5-10分鐘）訊號審核員」，只能根據我提供的摘要數據判斷，不可臆測外部資訊。
目標：判斷 ${sym} 在未來 5-10 分鐘「最可能方向/型態」，並給出進出場（entry/stop/tp）與勝率(0-100)。
限制：
- 若資料不足/信號品質低，請輸出 bias=NEUTRAL 並降低 confidence。
- 若已經“噴太高/波動過度擴張”，請避免追價，偏向 NEUTRAL 或等待回踩。

【摘要數據(JSON)】
${JSON.stringify(summary)}

【你必須輸出「嚴格 JSON」，不要任何多餘文字】
schema:
{
 "symbol": "string",
 "bias": "LONG|SHORT|NEUTRAL",
 "confidence": number,          // 0-100
 "pattern": "breakout-pending|continuation-pullback|reversal|squeeze|chop",
 "entry": {"type":"stop|limit|market","price":number,"logic":"string"},
 "stop": {"price":number,"logic":"string"},
 "takeProfit": [{"price":number,"logic":"string"}],
 "invalidation": "string",
 "notes": ["string"]
}
  `.trim();
}

async function callGeminiFor(sym){
  const key = getGeminiKey();
  if (!key) throw new Error("Missing Gemini API key. Paste it then Save.");

  const prompt = buildGeminiPrompt(sym);
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;

  const body = {
    contents: [{ role: "user", parts: [{ text: prompt }] }],
    generationConfig: {
      temperature: CFG.GEMINIF.TEMP,
      max_output_tokens: CFG.GEMINIF.MAX_OUTPUT_TOKENS,
      response_mime_type: "application/json"
    }
  };

  const res = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-goog-api-key": key
    },
    body: JSON.stringify(body)
  });

  if (!res.ok){
    const t = await res.text();
    throw new Error(`Gemini HTTP ${res.status}: ${t.slice(0,220)}`);
  }

  const json = await res.json();
  const text = json?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
  let out;
  try { out = JSON.parse(text); }
  catch(_){
    const st = stOf(sym);
    out = { symbol: sym, bias:"NEUTRAL", confidence:0, pattern:"chop",
      entry:{type:"market",price:st.lastP||0,logic:"Gemini did not return valid JSON."},
      stop:{price:st.lastP||0,logic:"-"},
      takeProfit:[], invalidation:"-", notes:[String(text).slice(0,300)] };
  }
  return out;
}

// ===================== UI render =====================
function render(){
  const hb = document.getElementById('hb');
  const alive = (Date.now() - lastHeartbeat) < 5000;
  hb.className = `inline-block w-2 h-2 rounded-full ${alive ? 'bg-emerald-500' : 'bg-zinc-600'}`;

  const zReady = [...S.values()].filter(x => x.volZ !== null).length;
  document.getElementById('status').innerText =
    `universe=${symbolsAll.length} | zReady=${zReady} | candidates=${candidates.length} | top5=${top5.length} | hbAgeMs=${Date.now()-lastHeartbeat}`;

  const wrap = document.getElementById('top5');
  wrap.innerHTML = "";
  for (const sym of top5){
    const st = stOf(sym);
    const dir = st.dirHint === 1 ? 'LONG-ish' : (st.dirHint === -1 ? 'SHORT-ish' : 'NEUTRAL');
    const dirCls = st.dirHint === 1 ? 'ok' : (st.dirHint === -1 ? 'bad' : 'muted');

    const row = document.createElement('div');
    row.className = "p-3 rounded-lg border border-zinc-800 bg-black/20";
    row.innerHTML = `
      <div class="flex items-start justify-between gap-3">
        <div>
          <div class="text-white font-black text-lg">${sym}</div>
          <div class="text-[11px] muted mono mt-1">
            score=${fmt(st.score,2)} |
            <span class="${dirCls} font-bold">${dir}</span>
          </div>
          <div class="text-[11px] muted mono mt-1">tags=${(st.patternTags||[]).join(', ') || '-'}</div>
        </div>
        <button class="px-3 py-2 rounded text-[12px] font-black bg-zinc-800 hover:bg-zinc-700 text-white"
                data-sym="${sym}">Gemini</button>
      </div>

      <div class="grid grid-cols-2 md:grid-cols-3 gap-2 mt-3 text-[11px] mono">
        <div class="pill rounded px-2 py-1">volZ: <span class="text-white">${fmt(st.volZ,2)}</span></div>
        <div class="pill rounded px-2 py-1">fundZ: <span class="text-white">${fmt(st.fundZ,2)}</span></div>
        <div class="pill rounded px-2 py-1">ret5m: <span class="text-white">${pct(st.ret5mPct,2)}</span></div>
        <div class="pill rounded px-2 py-1">premium: <span class="text-white">${pct(st.premNow,3)}</span></div>
        <div class="pill rounded px-2 py-1">imb5m: <span class="text-white">${fmt(st.imb5m,3)}</span></div>
        <div class="pill rounded px-2 py-1">imb4h: <span class="text-white">${fmt(st.imb4h,3)}</span></div>
        <div class="pill rounded px-2 py-1">vol5mZ: <span class="text-white">${fmt(st.vol5mZ,2)}</span></div>
        <div class="pill rounded px-2 py-1">oiZ5m: <span class="text-white">${fmt(st.oi.oi5mZ,2)}</span></div>
        <div class="pill rounded px-2 py-1">dOI4h: <span class="text-white">${fmt(st.oi.dOi4h,2)}</span></div>
      </div>
    `;
    row.querySelector('button').onclick = async () => { await analyzeOne(sym); };
    wrap.appendChild(row);
  }
}

function renderGemini(obj){
  const box = document.getElementById('geminiOut');
  const card = document.createElement('div');
  card.className = "p-3 rounded-lg border border-zinc-800 bg-black/30";
  card.innerHTML = `
    <div class="flex items-start justify-between">
      <div>
        <div class="text-white font-black">${obj.symbol || '-'}</div>
        <div class="text-[11px] muted mono mt-1">${obj.bias || 'NEUTRAL'} | conf=${obj.confidence ?? 0}</div>
      </div>
      <div class="text-[11px] mono muted">${obj.pattern || '-'}</div>
    </div>
    <pre class="text-[11px] mono mt-3 whitespace-pre-wrap break-words">${escapeHtml(JSON.stringify(obj, null, 2))}</pre>
  `;
  box.prepend(card);
}

// ===================== Orchestration =====================
async function tickPipeline(){
  computeCandidates();
  connectKlineForCandidates();
  await refreshOIForStrongOnes();
  computeTop5();
}

async function analyzeOne(sym){
  const outBox = document.getElementById('geminiOut');
  const info = document.createElement('div');
  info.className = "text-[11px] muted mono";
  info.innerText = `Gemini analyzing ${sym} ...`;
  outBox.prepend(info);
  try{
    const res = await callGeminiFor(sym);
    info.remove();
    renderGemini(res);
  }catch(e){
    info.innerText = `Gemini error for ${sym}: ${e.message}`;
  }
}

async function analyzeTop(){
  // ✅ 只分析 Top5 中最高分的前 TOPK
  const pick = top5.slice(0, CFG.GEMINIF.TOPK);
  if (!pick.length) return;

  const box = document.getElementById('geminiOut');
  const title = document.createElement('div');
  title.className = "text-[11px] muted mono";
  title.innerText = `Gemini analyzing Top${pick.length}: ${pick.join(', ')} ...`;
  box.prepend(title);

  for (const sym of pick){
    try{
      const res = await callGeminiFor(sym);
      renderGemini(res);
    }catch(e){
      const st = stOf(sym);
      renderGemini({symbol:sym,bias:"NEUTRAL",confidence:0,pattern:"chop",
        entry:{type:"market",price:st.lastP||0,logic:"Gemini error"},
        stop:{price:st.lastP||0,logic:"-"},
        takeProfit:[],invalidation:"-",notes:[e.message]});
    }
  }
  title.remove();
}

// ===================== UI bindings =====================
document.getElementById('saveKeyBtn').onclick = saveGeminiKey;
document.getElementById('clearKeyBtn').onclick = clearGeminiKey;
document.getElementById('resetBtn').onclick = () => location.reload();
document.getElementById('analyzeBtn').onclick = analyzeTop;

// Test Gemini button
document.getElementById('testGeminiBtn').onclick = async () => {
  try{
    const key = getGeminiKey();
    if(!key) return alert("先貼上 Gemini key 再測試（可按 Save 存 localStorage）");

    const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;
    const res = await fetch(url,{
      method:"POST",
      headers:{ "Content-Type":"application/json", "x-goog-api-key": key },
      body: JSON.stringify({
        contents:[{role:"user",parts:[{text:`只回傳JSON：{"ok":true,"ts":${Date.now()}}`}]}],
        generationConfig:{ temperature:0.1, max_output_tokens: 80, response_mime_type:"application/json" }
      })
    });

    const text = await res.text();
    console.log("Gemini test raw:", text);

    if(!res.ok){
      alert(`Gemini FAIL: HTTP ${res.status}\n(看 Console 內的回應內容)`);
      return;
    }
    alert("Gemini OK ✅（看 Console 可確認回應 JSON）");
  }catch(e){
    alert("Gemini error: " + e.message);
  }
};

// load key
(function initKey(){
  const k = localStorage.getItem('GEMINI_API_KEY') || "";
  if (k) document.getElementById('geminiKey').value = k;
})();

// ===================== Boot =====================
(async function main(){
  await loadUniverse();
  connectMark();

  setInterval(sampleMetrics, 1000);

  // pipeline every 15s (fast enough for 5-10m horizon)
  setInterval(() => { tickPipeline().catch(()=>{}); }, 15_000);

  // render loop
  setInterval(render, 1000);

  // ✅ auto Gemini: every 2 minutes max, only when key exists and top5 is ready
  let lastAutoGeminiAt = 0;
  setInterval(() => {
    const key = getGeminiKey();
    if (!key) return;
    if (top5.length !== 5) return;
    const now = Date.now();
    if (now - lastAutoGeminiAt < CFG.GEMINIF.AUTO_INTERVAL_MS) return;
    lastAutoGeminiAt = now;
    analyzeTop();
  }, CFG.GEMINIF.AUTO_CHECK_MS);
})();
</script>
</body>
</html>

