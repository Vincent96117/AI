<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRIDENT V7 â€” Anomaly-first â†’ Top5 â†’ Gemini (LONG only)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    :root { color-scheme: dark; }
    body { background:#050505; color:#d4d4d8; font-family:'JetBrains Mono', monospace; overflow-x:hidden; }
    .card { background:#0f0f11; border:1px solid #1f1f23; border-radius:14px; }
    .badge { border:1px solid #2a2a2f; background:#0b0b0d; border-radius:999px; padding:2px 8px; font-size:11px; color:#9ca3af;}
    .badge-green{ border-color:#14532d; color:#86efac; background:rgba(20,83,45,.25);}
    .badge-yellow{ border-color:#78350f; color:#fde68a; background:rgba(120,53,15,.25);}
    .badge-orange{ border-color:#7c2d12; color:#fdba74; background:rgba(124,45,18,.25);}
    .badge-red{ border-color:#7f1d1d; color:#fca5a5; background:rgba(127,29,29,.25);}
    .kpi { background:#0b0b0d; border:1px solid #1f1f23; border-radius:10px; padding:8px 10px; font-size:12px; }
    .kpi .k { color:#a1a1aa; font-size:10px; }
    .kpi .v { color:#e5e7eb; font-weight:700; margin-top:2px; }
    .aiBox { background:#070709; border:1px solid #1f1f23; border-radius:12px; padding:10px; min-height:170px; }
    .mono { font-family:'JetBrains Mono', monospace; }
    .btn { border:1px solid #2a2a2f; background:#0b0b0d; padding:7px 10px; border-radius:10px; font-size:12px; font-weight:700; }
    .btn:hover { background:#101013; }
    .btn-blue{ border-color:#1d4ed8; background:rgba(29,78,216,.15); color:#93c5fd;}
    .btn-blue:hover{ background:rgba(29,78,216,.25); }
    .btn-green{ border-color:#16a34a; background:rgba(22,163,74,.15); color:#86efac;}
    .btn-green:hover{ background:rgba(22,163,74,.25); }
    .btn-amber{ border-color:#f59e0b; background:rgba(245,158,11,.12); color:#fcd34d;}
    .btn-amber:hover{ background:rgba(245,158,11,.20); }
    .btn-red{ border-color:#ef4444; background:rgba(239,68,68,.12); color:#fca5a5;}
    .btn-red:hover{ background:rgba(239,68,68,.20); }
    .input { background:#0b0b0d; border:1px solid #2a2a2f; border-radius:10px; padding:7px 10px; font-size:12px; color:#e5e7eb; outline:none; }
    .input:focus { border-color:#3b82f6; box-shadow:0 0 0 2px rgba(59,130,246,.15); }
    #heartbeat { width:10px; height:10px; border-radius:999px; display:inline-block; }
    .hb-ok { background:#22c55e; box-shadow:0 0 12px rgba(34,197,94,.55); }
    .hb-bad{ background:#6b7280; box-shadow:none; }
    .gridKpi { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:10px; }
    @media (max-width: 1100px){ .gridKpi { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    @media (max-width: 720px){ .gridKpi { grid-template-columns: repeat(1, minmax(0, 1fr)); } }
  </style>
</head>
<body class="p-4">
  <!-- Header -->
  <div class="flex flex-col gap-3 mb-4">
    <div class="flex flex-wrap items-center justify-between gap-3">
      <div class="flex items-center gap-3">
        <span id="heartbeat" class="hb-bad"></span>
        <div>
          <div class="text-xl font-black text-white italic leading-none">TRIDENT <span class="text-emerald-400">V7</span></div>
          <div class="text-[10px] text-zinc-500 font-bold uppercase tracking-widest mt-1">Anomaly-first â†’ Top5 â†’ Gemini (LONG only)</div>
        </div>
      </div>

      <div class="flex flex-wrap items-center gap-2">
        <select id="modelSelect" class="input">
          <option value="gemini-2.5-flash">gemini-2.5-flash</option>
          <option value="gemini-2.5-pro">gemini-2.5-pro</option>
        </select>
        <input id="maxOut" class="input w-20" type="number" min="64" max="2048" step="1" value="420" />
        <span class="text-[11px] text-zinc-500">max_out</span>

        <input id="apiKey" class="input w-[320px]" type="password" placeholder="è²¼ä¸Š Gemini API Keyï¼ˆåªå­˜åœ¨ä½ ç€è¦½å™¨ localStorageï¼‰" />
        <button id="saveKeyBtn" class="btn">Save</button>
        <button id="clearKeyBtn" class="btn">Clear</button>

        <button id="testGeminiBtn" class="btn btn-green">Test Gemini</button>
        <button id="analyzeTopBtn" class="btn btn-blue">Analyze Top (Gemini)</button>

        <label class="flex items-center gap-2 text-[12px]">
          <input id="autoToggle" type="checkbox" class="accent-emerald-500" checked />
          Auto ON
        </label>

        <button id="resetBtn" class="btn btn-red">RESET</button>
      </div>
    </div>

    <div class="flex flex-wrap items-center justify-between gap-2 text-[12px] text-zinc-400">
      <div class="flex flex-wrap items-center gap-2">
        <span class="badge">ç‹€æ…‹ï¼š<span id="statusText">å•Ÿå‹•ä¸­â€¦</span></span>
        <span class="badge">æ›´æ–°ï¼š<span id="lastUpdate">-</span></span>
        <span class="badge">æœ€å¼·é–å®šï¼š<span id="champText">-</span></span>
        <span class="badge">æ’é™¤ï¼šå¸‚å€¼å‰25 + BTC/ETH/SOL/XRP/BNB ç­‰</span>
      </div>
      <div class="flex flex-wrap items-center gap-2">
        <span class="badge">Geminiï¼š<span id="geminiStatus">æœªæ¸¬è©¦</span></span>
        <span class="badge">RPM é™åˆ¶ï¼š<span id="rpmInfo">4/min</span></span>
        <span class="badge">ä»Šæ—¥ç”¨é‡ï¼š<span id="dailyInfo">0</span></span>
      </div>
    </div>
  </div>

  <!-- Top5 -->
  <div class="mb-3">
    <div class="text-sm font-black text-white mb-2">Top 5 å€™é¸ï¼ˆæœ€å¼·é–å®šç½®é ‚ï¼‰</div>
    <div id="top5" class="flex flex-col gap-3"></div>
  </div>

  <div class="text-[11px] text-zinc-500 mt-4 leading-relaxed">
    æé†’ï¼šGitHub Pages æ˜¯å…¬é–‹ç¶²ç«™ï¼Œå‰ç«¯ç›´é€£ Gemini ä»£è¡¨ã€ŒKey æœƒå‡ºç¾åœ¨ä½ çš„ç€è¦½å™¨ç¶²è·¯è«‹æ±‚ä¸­ã€ï¼Œä¸é©åˆæ”¾çœŸæ­£é•·æœŸä½¿ç”¨çš„é‡‘é‘°ã€‚è‹¥è¦å®‰å…¨é•·ç”¨ï¼Œå»ºè­°åŠ ä¸€å±¤ proxyï¼ˆCloudflare Worker / è‡ªæ¶ APIï¼‰ã€‚
  </div>

<script>
/* =========================
   Utils
========================= */
const $ = (id) => document.getElementById(id);
const fmt = (n, d=2) => (Number.isFinite(n) ? n.toFixed(d) : '-');
const nowTs = () => Date.now();
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
function tsToTime(t){
  if(!t) return '-';
  const d = new Date(t);
  return d.toLocaleTimeString('zh-TW', { hour12:false });
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function escapeHtml(s){
  return String(s ?? '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

/* =========================
   Persistent Settings
========================= */
const LS_KEY = 'TRIDENT_GEMINI_KEY_V7';
const LS_DAILY = 'TRIDENT_GEMINI_DAILY_V7';
const LS_DAILY_DATE = 'TRIDENT_GEMINI_DAILY_DATE_V7';
const LS_CHAMP = 'TRIDENT_CHAMP_V7';

function loadKey(){
  const k = localStorage.getItem(LS_KEY) || '';
  $('apiKey').value = k;
}
function saveKey(){
  const k = $('apiKey').value.trim();
  localStorage.setItem(LS_KEY, k);
  setGeminiStatus(k ? 'å·²ä¿å­˜ï¼ˆæœªæ¸¬è©¦ï¼‰' : 'æœªè¨­å®š');
}
function clearKey(){
  localStorage.removeItem(LS_KEY);
  $('apiKey').value = '';
  setGeminiStatus('å·²æ¸…é™¤');
}
function getKey(){
  return (localStorage.getItem(LS_KEY) || '').trim();
}

function getDailyCount(){
  const today = new Date().toISOString().slice(0,10);
  const d0 = localStorage.getItem(LS_DAILY_DATE);
  if(d0 !== today){
    localStorage.setItem(LS_DAILY_DATE, today);
    localStorage.setItem(LS_DAILY, '0');
  }
  return parseInt(localStorage.getItem(LS_DAILY) || '0', 10);
}
function incDaily(){
  const v = getDailyCount() + 1;
  localStorage.setItem(LS_DAILY, String(v));
  $('dailyInfo').innerText = String(v);
}

/* =========================
   UI Status
========================= */
function setHeartbeat(ok){
  $('heartbeat').className = ok ? 'hb-ok' : 'hb-bad';
}
function setStatus(t){ $('statusText').innerText = t; }
function setLastUpdate(t){ $('lastUpdate').innerText = tsToTime(t); }
function setGeminiStatus(t){ $('geminiStatus').innerText = t; }

/* =========================
   Rate Limiter (Gemini)
   - default 4 rpm to avoid hitting 5 rpm limit shown in your console.
========================= */
const limiter = {
  cap: 4,
  tokens: 4,
  lastRefill: nowTs(),
  cooldownUntil: 0,
  dailyCap: 18, // ä¿å®ˆï¼Œé¿å…ä½  RPD çˆ†
  refill(){
    const now = nowTs();
    const elapsed = now - this.lastRefill;
    if(elapsed >= 60000){
      const steps = Math.floor(elapsed / 60000);
      this.tokens = clamp(this.tokens + steps*this.cap, 0, this.cap);
      this.lastRefill += steps*60000;
    }
  },
  canRun(){
    this.refill();
    if(nowTs() < this.cooldownUntil) return { ok:false, why:'å†·å»ä¸­ï¼ˆ429/backoffï¼‰' };
    if(getDailyCount() >= this.dailyCap) return { ok:false, why:'ä»Šæ—¥ç”¨é‡å·²é”ä¿å®ˆä¸Šé™ï¼ˆå¯è‡ªè¡Œèª¿é«˜ dailyCapï¼‰' };
    if(this.tokens <= 0) return { ok:false, why:'RPM ç¯€æµï¼šç¨å¾Œå†è©¦' };
    return { ok:true };
  },
  take(){
    this.refill();
    this.tokens = Math.max(0, this.tokens - 1);
    $('rpmInfo').innerText = `${this.tokens}/${this.cap} å¯ç”¨`;
  },
  backoff(){
    // æŒ‡æ•¸é€€é¿ï¼š30s â†’ 60s â†’ 120s â†’ 240sï¼ˆä¸Šé™ 4minï¼‰
    const base = 30000;
    const cur = Math.max(0, this.cooldownUntil - nowTs());
    const next = clamp(cur ? cur*2 : base, base, 240000);
    this.cooldownUntil = nowTs() + next;
    return next;
  }
};

/* =========================
   Data + Streams (Binance)
========================= */
const BINANCE_HTTP = 'https://fapi.binance.com';
const WS_BASE = 'wss://fstream.binance.com';

const EXCLUDE_FIXED = new Set(['BTCUSDT','ETHUSDT','SOLUSDT','XRPUSDT','BNBUSDT','BCHUSDT','DOGEUSDT']); // å¯è‡ªè¡Œå¢æ¸›
let excludeTopCap = new Set(); // CoinGecko top25 symbols (upper)
let universe = [];             // current scan universe (symbols)
let states = {};               // per symbol state
let top5 = [];                 // current top5 list (objects)
let champ = { symbol:'', score: -1, since: 0, stage: 'NONE' };
let lastAutoGeminiAt = 0;

function initState(symbol){
  if(states[symbol]) return;
  states[symbol] = {
    symbol,
    price: NaN,
    markPrice: NaN,
    premiumPct: NaN,
    fundingRate: NaN,

    // derived / rolling
    candle1m: [],        // seed + live
    lastCandleMinute: 0,
    curCandle: null,

    // 5m bucket from aggTrade
    bucket5mStart: 0,
    takerBuyNotional5m: 0,
    takerSellNotional5m: 0,
    totalNotional5m: 0,
    ret5m: NaN,

    // anomalies (z)
    volZ: NaN,
    vol5mZ: NaN,
    imb5mZ: NaN,
    oi5mZ: NaN,
    oi4hDelta: NaN,

    // OI & taker ratio from REST (cached)
    oi5m: null,  // {cur, prev, delta}
    oi4h: null,  // {cur, prev, delta}
    taker5m: null, // {buyVol, sellVol, ratio}
    taker4h: null,

    // pattern tags
    tags: [],

    // scoring / stage
    score: 0,
    stage: 'NONE', // SETUP / IGNITE / CONFIRM
    rank: 0,

    // AI
    ai: { status:'å°šæœªåˆ†æ', json:null, text:'', t:0, err:'' },
    lastAiReqAt: 0,

    // fetch guards
    seeded: false,
    lastStatsFetch: 0
  };
}

/* -------------------------
   REST helpers
------------------------- */
async function fetchJson(url, timeoutMs=9000){
  const controller = new AbortController();
  const to = setTimeout(() => controller.abort(), timeoutMs);
  const res = await fetch(url, { signal: controller.signal });
  clearTimeout(to);
  const txt = await res.text();
  if(!res.ok) throw new Error(`HTTP ${res.status}: ${txt.slice(0,200)}`);
  try { return JSON.parse(txt); }
  catch(e){ throw new Error(`JSON_PARSE_FAIL: ${txt.slice(0,200)}`); }
}

/* -------------------------
   CoinGecko top25 marketcap exclusion
------------------------- */
async function loadTopCap25(){
  try{
    // CoinGecko: top 25 by market cap
    // æ³¨æ„ï¼šå…è²»æœå‹™æœ‰ rate limitï¼Œæˆ‘å€‘åš 12h å¿«å–
    const cacheKey = 'TRIDENT_COINGECKO_TOP25_CACHE';
    const cacheAtKey = 'TRIDENT_COINGECKO_TOP25_AT';
    const at = parseInt(localStorage.getItem(cacheAtKey)||'0',10);
    if(at && (nowTs()-at) < 12*3600*1000){
      const arr = JSON.parse(localStorage.getItem(cacheKey)||'[]');
      excludeTopCap = new Set(arr);
      return;
    }
    const url = 'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=25&page=1&sparkline=false';
    const data = await fetchJson(url, 12000);
    const sym = (data||[]).map(x => String(x.symbol||'').toUpperCase()).filter(Boolean);
    excludeTopCap = new Set(sym.map(s => s+'USDT'));
    localStorage.setItem(cacheKey, JSON.stringify(Array.from(excludeTopCap)));
    localStorage.setItem(cacheAtKey, String(nowTs()));
  }catch(e){
    // å¤±æ•—å°±å…ˆä¸æ’é™¤ï¼ˆä½†ä½ è¦æ±‚è¦æ’é™¤ï¼Œæ‰€ä»¥æˆ‘å€‘ä»ä¿ç•™å›ºå®š EXCLUDE_FIXEDï¼‰
    console.warn('CoinGecko top25 load fail:', e);
  }
}

/* -------------------------
   Build universe: top N by quoteVolume, excluding sets
------------------------- */
async function refreshUniverse(){
  const tickers = await fetchJson(`${BINANCE_HTTP}/fapi/v1/ticker/24hr`, 12000);
  const filtered = (tickers||[])
    .filter(x => x && x.symbol && x.symbol.endsWith('USDT'))
    .filter(x => !EXCLUDE_FIXED.has(x.symbol))
    .filter(x => !excludeTopCap.has(x.symbol)) // ä½ è¦æ±‚ï¼šä¸è¦å¸‚å€¼å‰25
    .filter(x => parseFloat(x.quoteVolume||'0') > 30_000_000) // æµå‹•æ€§åº•ç·šï¼Œå¯èª¿
    .sort((a,b) => parseFloat(b.quoteVolume||'0') - parseFloat(a.quoteVolume||'0'));

  // Universe å– 80 æª”å…ˆåšå³æ™‚ç›£æ§ï¼ˆå‰ç«¯æ¥µé™ï¼Œä¸è¦å¤ªå¤§ï¼‰
  universe = filtered.slice(0, 80).map(x => x.symbol);
  universe.forEach(initState);
}

/* -------------------------
   Seed candles for key symbols only (lazy)
------------------------- */
async function seedCandles(symbol){
  const st = states[symbol];
  if(!st || st.seeded) return;
  try{
    const k = await fetchJson(`${BINANCE_HTTP}/fapi/v1/klines?symbol=${symbol}&interval=1m&limit=80`, 12000);
    st.candle1m = (k||[]).map(v => ({
      t: Number(v[0]),
      o: parseFloat(v[1]),
      h: parseFloat(v[2]),
      l: parseFloat(v[3]),
      c: parseFloat(v[4]),
      q: parseFloat(v[7]) // quoteVolume
    }));
    st.seeded = true;
  }catch(e){
    console.warn('seedCandles fail', symbol, e);
  }
}

/* -------------------------
   OI + Taker Ratio fetch (only for top candidates)
   Binance docs:
   - Open Interest Statistics: /futures/data/openInterestHist :contentReference[oaicite:1]{index=1}
   - Taker Buy/Sell Volume (USDS): /futures/data/takerlongshortRatio :contentReference[oaicite:2]{index=2}
------------------------- */
async function refreshDerivativesStats(symbol){
  const st = states[symbol];
  if(!st) return;
  const now = nowTs();
  // 15 ç§’å…§ä¸é‡è¤‡æŠ“ï¼ˆ5m/4h æœ¬ä¾†å°±ä¸æœƒç§’è®Šï¼‰
  if(st.lastStatsFetch && (now - st.lastStatsFetch) < 15000) return;
  st.lastStatsFetch = now;

  try{
    const [oi5mArr, oi4hArr, taker5mArr, taker4hArr] = await Promise.all([
      fetchJson(`${BINANCE_HTTP}/futures/data/openInterestHist?symbol=${symbol}&period=5m&limit=2`, 12000),
      fetchJson(`${BINANCE_HTTP}/futures/data/openInterestHist?symbol=${symbol}&period=4h&limit=2`, 12000),
      fetchJson(`${BINANCE_HTTP}/futures/data/takerlongshortRatio?symbol=${symbol}&period=5m&limit=2`, 12000),
      fetchJson(`${BINANCE_HTTP}/futures/data/takerlongshortRatio?symbol=${symbol}&period=4h&limit=2`, 12000),
    ]);

    const oi5m = (oi5mArr||[]).slice(-2);
    if(oi5m.length===2){
      const prev = parseFloat(oi5m[0].sumOpenInterestValue || oi5m[0].sumOpenInterest || 'NaN');
      const cur  = parseFloat(oi5m[1].sumOpenInterestValue || oi5m[1].sumOpenInterest || 'NaN');
      st.oi5m = { prev, cur, delta: (cur-prev) };
    }
    const oi4h = (oi4hArr||[]).slice(-2);
    if(oi4h.length===2){
      const prev = parseFloat(oi4h[0].sumOpenInterestValue || oi4h[0].sumOpenInterest || 'NaN');
      const cur  = parseFloat(oi4h[1].sumOpenInterestValue || oi4h[1].sumOpenInterest || 'NaN');
      st.oi4h = { prev, cur, delta: (cur-prev) };
    }

    const tk5 = (taker5mArr||[]).slice(-1)[0];
    if(tk5){
      const buy = parseFloat(tk5.buyVol||'NaN');
      const sell= parseFloat(tk5.sellVol||'NaN');
      st.taker5m = { buyVol: buy, sellVol: sell, ratio: (sell>0? buy/sell : NaN) };
    }
    const tk4 = (taker4hArr||[]).slice(-1)[0];
    if(tk4){
      const buy = parseFloat(tk4.buyVol||'NaN');
      const sell= parseFloat(tk4.sellVol||'NaN');
      st.taker4h = { buyVol: buy, sellVol: sell, ratio: (sell>0? buy/sell : NaN) };
    }
  }catch(e){
    // ä¸è¦æ•´é çˆ†ï¼Œè©²æ¬„ä½é¡¯ç¤º --
    console.warn('refreshDerivativesStats fail', symbol, e);
  }
}

/* -------------------------
   WebSockets
------------------------- */
let wsAgg = null;
let wsMark = null;

function openAggTrades(){
  if(wsAgg) try{ wsAgg.close(); }catch(e){}
  // åˆä½µ streamsï¼ˆé¿å…æ¯å¹£ä¸€æ¢ wsï¼‰
  const streams = universe.map(s => s.toLowerCase() + '@aggTrade').join('/');
  const url = `${WS_BASE}/stream?streams=${streams}`;
  wsAgg = new WebSocket(url);

  wsAgg.onopen = () => setStatus('AggTrade ä¸²æµå·²é€£ç·š');
  wsAgg.onclose = () => setStatus('AggTrade æ–·ç·šï¼Œé‡é€£ä¸­â€¦');
  wsAgg.onerror = () => {};

  wsAgg.onmessage = (ev) => {
    setHeartbeat(true);
    const msg = JSON.parse(ev.data);
    const d = msg.data;
    if(!d || !d.s) return;
    const symbol = d.s;
    const st = states[symbol]; if(!st) return;

    const p = parseFloat(d.p);
    st.price = p;

    // 5m bucket (notional)
    const t = Number(d.T); // trade time
    const bucket = Math.floor(t / (5*60*1000)) * (5*60*1000);
    if(!st.bucket5mStart || st.bucket5mStart !== bucket){
      // rotate
      st.bucket5mStart = bucket;
      st.takerBuyNotional5m = 0;
      st.takerSellNotional5m = 0;
      st.totalNotional5m = 0;
    }
    const notional = parseFloat(d.q) * p;
    st.totalNotional5m += notional;
    // buyerIsMaker: m==true means SELL taker (aggressive sell)
    if(d.m) st.takerSellNotional5m += notional;
    else st.takerBuyNotional5m += notional;

    // build 1m candle from aggTrade
    const m = Math.floor(t / 60000) * 60000;
    if(!st.lastCandleMinute) st.lastCandleMinute = m;
    if(m !== st.lastCandleMinute){
      // finalize previous candle
      if(st.curCandle){
        st.candle1m.push(st.curCandle);
        if(st.candle1m.length > 120) st.candle1m.shift();
      }
      st.lastCandleMinute = m;
      st.curCandle = { t:m, o:p, h:p, l:p, c:p, q:notional };
    }else{
      if(!st.curCandle) st.curCandle = { t:m, o:p, h:p, l:p, c:p, q:notional };
      st.curCandle.h = Math.max(st.curCandle.h, p);
      st.curCandle.l = Math.min(st.curCandle.l, p);
      st.curCandle.c = p;
      st.curCandle.q += notional;
    }
  };
}

function openMarkPrices(){
  if(wsMark) try{ wsMark.close(); }catch(e){}
  wsMark = new WebSocket(`${WS_BASE}/ws/!markPrice@arr@1s`);
  wsMark.onopen = () => {};
  wsMark.onmessage = (ev) => {
    setHeartbeat(true);
    const arr = JSON.parse(ev.data);
    const now = nowTs();
    setLastUpdate(now);

    for(const x of arr){
      const s = x.s;
      if(!states[s]) continue;
      const st = states[s];
      st.markPrice = parseFloat(x.p);
      st.fundingRate = parseFloat(x.r) * 100;
      // premium approx: (mark - index)/index ; Gemini/ç­–ç•¥ç”¨ premium æ¯” funding æ›´å³æ™‚
      const idx = parseFloat(x.i);
      if(idx>0) st.premiumPct = ( (st.markPrice - idx) / idx ) * 100;
    }
  };
}

/* =========================
   Feature Engineering (LONG-only)
========================= */
function calcZ(x, mean, sd){
  if(!Number.isFinite(x) || !Number.isFinite(mean) || !Number.isFinite(sd) || sd<=0) return NaN;
  return (x-mean)/sd;
}

function computeFeatures(st){
  // ensure seeded candles if too few
  const candles = st.candle1m.slice(-80);
  if(candles.length < 20) return;

  const last = candles[candles.length-1];
  const prev5 = candles.slice(-6, -1);
  const closeNow = last.c;
  const close5 = prev5.length ? prev5[0].o : candles[Math.max(0,candles.length-6)].o;
  st.ret5m = (closeNow/close5 - 1) * 100;

  // volume zscore: last 5m sum vs previous 60m baseline
  const vols = candles.map(c => c.q);
  const last5mVol = vols.slice(-5).reduce((a,b)=>a+b,0);
  const baseline = vols.slice(0, -5);
  const mean = baseline.reduce((a,b)=>a+b,0) / Math.max(1, baseline.length);
  const sd = Math.sqrt(baseline.reduce((a,b)=>a+(b-mean)*(b-mean),0) / Math.max(1, baseline.length));
  st.vol5mZ = calcZ(last5mVol, mean*5, sd*Math.sqrt(5)); // rough scale

  // imbalance 5m from aggTrade bucket
  const net5m = st.takerBuyNotional5m - st.takerSellNotional5m;
  const tot5m = st.totalNotional5m;
  const imbRatio = (tot5m>0) ? (net5m/tot5m) : NaN; // -1..+1
  // treat as z by mapping through tanh then scale
  st.imb5mZ = Number.isFinite(imbRatio) ? (imbRatio*6) : NaN; // heuristic

  // OI based (if available)
  if(st.oi5m && Number.isFinite(st.oi5m.delta)){
    // normalize by abs prev
    const base = Math.max(1, Math.abs(st.oi5m.prev));
    const rel = (st.oi5m.delta / base) * 100;
    st.oi5mZ = rel * 2; // heuristic
  } else st.oi5mZ = NaN;

  if(st.oi4h && Number.isFinite(st.oi4h.delta)){
    st.oi4hDelta = st.oi4h.delta;
  } else st.oi4hDelta = NaN;

  // simple pattern tags (cheap)
  const tags = [];
  // squeeze: recent range contracted
  const ranges = candles.slice(-20).map(c => (c.h-c.l)/Math.max(1e-12,c.c));
  const rNow = ranges.slice(-5).reduce((a,b)=>a+b,0)/5;
  const rPrev = ranges.slice(0,-5);
  const rMean = rPrev.reduce((a,b)=>a+b,0) / Math.max(1,rPrev.length);
  if(Number.isFinite(rNow) && Number.isFinite(rMean) && rNow < rMean*0.65) tags.push('æ³¢å‹•æ”¶æ–‚');

  // breakout proximity
  const high20 = Math.max(...candles.slice(-20).map(c=>c.h));
  const low20  = Math.min(...candles.slice(-20).map(c=>c.l));
  const distHigh = (high20>0) ? ( (high20-closeNow)/high20 )*100 : NaN;
  const distLow  = (closeNow>0) ? ( (closeNow-low20)/closeNow )*100 : NaN;
  if(Number.isFinite(distHigh) && distHigh < 0.25) tags.push('è²¼è¿‘å€é–“ä¸Šç·£');
  if(Number.isFinite(distLow) && distLow < 0.25) tags.push('è²¼è¿‘å€é–“ä¸‹ç·£');

  // anti-chase tag
  if(Number.isFinite(st.ret5m) && st.ret5m > 0.9) tags.push('å·²çŸ­ç·šä¸Šæ²–(æ…è¿½)');
  if(Number.isFinite(st.ret5m) && st.ret5m < -0.9) tags.push('çŸ­ç·šèµ°å¼±(æ…æ¥)');

  // premium bias
  if(Number.isFinite(st.premiumPct) && st.premiumPct > 0.05) tags.push('æº¢åƒ¹åå¤š');
  if(Number.isFinite(st.premiumPct) && st.premiumPct < -0.05) tags.push('æº¢åƒ¹åç©º');

  st.tags = tags;
}

function scoreLongOnly(st){
  // åªåšå¤šï¼šæŠŠã€Œä¸»å‹•è²·å…¥ã€OIã€é‡èƒ½ã€æ³¢å‹•æ”¶æ–‚/çªç ´ã€åŠ æ¬Š
  const vol = Number.isFinite(st.vol5mZ) ? clamp(st.vol5mZ, -3, 5) : 0;
  const imb = Number.isFinite(st.imb5mZ) ? clamp(st.imb5mZ, -3, 5) : 0;
  const oi5 = Number.isFinite(st.oi5mZ) ? clamp(st.oi5mZ, -4, 6) : 0;
  const prem= Number.isFinite(st.premiumPct) ? clamp(st.premiumPct*10, -3, 3) : 0; // 0.1% => 1
  const tagBonus = st.tags.includes('æ³¢å‹•æ”¶æ–‚') ? 1.5 : 0;

  // anti-chase penalty
  let chasePenalty = 0;
  if(Number.isFinite(st.ret5m) && st.ret5m > 1.0) chasePenalty -= 2.0;
  if(Number.isFinite(st.ret5m) && st.ret5m > 2.0) chasePenalty -= 3.0;

  // avoid falling knife penalty (ä½ èªªä¸€å †è·Œæˆå–œæ†¨ï¼šé€™è£¡ç›´æ¥æ‰£åˆ†)
  let dumpPenalty = 0;
  if(Number.isFinite(st.ret5m) && st.ret5m < -0.8) dumpPenalty -= 2.5;

  // Weighted sum
  const raw =
    3.0*vol +
    3.2*imb +
    2.2*oi5 +
    1.2*prem +
    tagBonus +
    chasePenalty +
    dumpPenalty;

  // map to 0..100
  const score = clamp( 50 + raw*8, 0, 100 );
  return score;
}

function stageFrom(st){
  // ä¸‰æ®µç‡ˆï¼šğŸŸ¨è“„å‹¢ SETUPã€ğŸŸ§é»ç« IGNITEã€ğŸŸ©è§¸ç™¼ CONFIRM
  const s = st.score;
  const okVol = (Number.isFinite(st.vol5mZ) && st.vol5mZ > 1.2);
  const okImb = (Number.isFinite(st.imb5mZ) && st.imb5mZ > 0.8);
  const okOI  = (st.oi5m && Number.isFinite(st.oi5m.delta) && st.oi5m.delta > 0);
  const notChase = (Number.isFinite(st.ret5m) ? st.ret5m < 0.9 : true);

  // Confirm = å¤šå€‹æ¢ä»¶åŒæ™‚æˆç«‹
  if(s >= 82 && okVol && okImb && okOI && notChase) return 'CONFIRM';
  if(s >= 72 && (okVol || okImb) && notChase) return 'IGNITE';
  if(s >= 60 && notChase) return 'SETUP';
  return 'NONE';
}

/* =========================
   Ranking (stable + champion lock)
========================= */
function updateRanking(){
  // compute features & score
  const arr = [];
  for(const sym of universe){
    const st = states[sym];
    if(!st) continue;
    computeFeatures(st);
    st.score = scoreLongOnly(st);
    st.stage = stageFrom(st);

    // åªä¿ç•™æœ‰æ„ç¾©çš„ï¼ˆé¿å…ä¸€å †äº‚è·Œçš„ï¼‰
    if(st.stage === 'NONE') continue;
    arr.push(st);
  }

  // sort by score
  arr.sort((a,b)=>b.score - a.score);

  // champion lock: only replace if clearly stronger
  const top = arr[0];
  const replaceThreshold = 1.18; // å¿…é ˆ > ç›®å‰æœ€å¼· 18% æ‰æ›ï¼Œé¿å…ä½ èªªçš„æ¦œä¸€ç›´è·³
  if(!champ.symbol && top){
    champ = { symbol: top.symbol, score: top.score, since: nowTs(), stage: top.stage };
    localStorage.setItem(LS_CHAMP, JSON.stringify(champ));
  }else if(top && champ.symbol){
    const cur = states[champ.symbol];
    const champScoreNow = cur ? cur.score : champ.score;
    // if champ disappeared or new top is much stronger
    if(!cur || (top.symbol !== champ.symbol && top.score > champScoreNow * replaceThreshold)){
      champ = { symbol: top.symbol, score: top.score, since: nowTs(), stage: top.stage };
      localStorage.setItem(LS_CHAMP, JSON.stringify(champ));
    }else{
      champ.score = champScoreNow;
      champ.stage = cur ? cur.stage : champ.stage;
    }
  }
  $('champText').innerText = champ.symbol ? `${champ.symbol} (${fmt(champ.score,1)})` : '-';

  // build top5 with champion pinned
  const pinned = champ.symbol ? arr.find(x=>x.symbol===champ.symbol) : null;
  const rest = arr.filter(x => x.symbol !== champ.symbol);

  top5 = [];
  if(pinned) top5.push(pinned);
  for(const x of rest){
    if(top5.length >= 5) break;
    top5.push(x);
  }

  // ensure 5 slots if possible
  renderTop5();
}

/* =========================
   Gemini Call (robust JSON extraction)
========================= */
function extractJsonLoose(text){
  const s = String(text||'').trim();
  if(!s) return null;

  // remove common code fences
  let t = s.replace(/^```(?:json)?/i, '').replace(/```$/,'').trim();

  // Try direct parse
  try { return JSON.parse(t); } catch(e){}

  // Try substring {...} or [...]
  const firstObj = t.indexOf('{');
  const lastObj = t.lastIndexOf('}');
  if(firstObj !== -1 && lastObj !== -1 && lastObj > firstObj){
    const sub = t.slice(firstObj, lastObj+1);
    try { return JSON.parse(sub); } catch(e){}
  }
  const firstArr = t.indexOf('[');
  const lastArr = t.lastIndexOf(']');
  if(firstArr !== -1 && lastArr !== -1 && lastArr > firstArr){
    const sub = t.slice(firstArr, lastArr+1);
    try { return JSON.parse(sub); } catch(e){}
  }
  return null;
}

function aiToPrettyZh(obj){
  if(!obj || typeof obj !== 'object'){
    return `AI(éŒ¯èª¤)ï¼šå›å‚³ä¸æ˜¯ç‰©ä»¶`;
  }
  const dir = obj.direction ?? obj.bias ?? 'è§€æœ›';
  const conf= obj.confidence ?? 0;
  const eta = obj.eta_minutes ?? obj.eta ?? '-';
  const stage= obj.stage ?? '-';
  const entry = obj.entry ?? {};
  const stop  = obj.stop ?? {};
  const tp    = obj.takeProfit ?? obj.take_profit ?? [];
  const notes = obj.notes ?? obj.reasoning ?? [];
  const invalid = obj.invalidation ?? obj.fail ?? '-';

  const tpText = Array.isArray(tp) && tp.length
    ? tp.map((x,i)=> `TP${i+1}: ${x.price ?? x}`).join(' / ')
    : '-';

  const notesText = Array.isArray(notes) && notes.length
    ? notes.map(x => `â€¢ ${x}`).join('\n')
    : '-';

  return [
    `æ–¹å‘ï¼š${dir}ï½œä¿¡å¿ƒï¼š${conf}/100`,
    `é è¨ˆè¡¨æ…‹ï¼š${eta} åˆ†é˜ï¼ˆå€é–“ï¼‰`,
    `ç‹€æ…‹ï¼š${stage}`,
    `é€²å ´ï¼š${entry.type ?? 'å¸‚åƒ¹'} ${entry.zone ?? entry.price ?? '-'}`,
    `åœæï¼š${stop.zone ?? stop.price ?? '-'}`,
    `æ­¢ç›ˆï¼š${tpText}`,
    `å¤±æ•ˆæ¢ä»¶ï¼š${invalid}`,
    `å‚™è¨»ï¼š\n${notesText}`
  ].join('\n');
}

function buildGeminiPrompt(summary){
  // åªåšå¤š + å¿…é ˆè¼¸å‡º JSONï¼ˆä½†ä»åšé˜²å‘†æŠ½å–ï¼‰
  return `
ä½ æ˜¯åˆç´„äº¤æ˜“åŠ©ç†ï¼Œç­–ç•¥åªåšã€Œå¤šå–®ã€ã€‚
ä½ æœƒæ‹¿åˆ°ä¸€å€‹å¹£ç¨®çš„ç²¾ç°¡æ‘˜è¦ï¼ˆéæ•´åŒ…Kç·šï¼‰ã€‚
è«‹ä½ è¼¸å‡ºã€Œå–®ä¸€ JSON ç‰©ä»¶ã€ï¼Œä¸è¦åŠ ä»»ä½•å¤šé¤˜æ–‡å­—ã€ä¸è¦ code fenceã€ä¸è¦ markdownã€‚

éœ€æ±‚ï¼š
- direction: åªèƒ½æ˜¯ "åšå¤š" æˆ– "è§€æœ›"
- confidence: 0~100ï¼ˆæ•´æ•¸ï¼‰
- eta_minutes: ç”¨å­—ä¸²å€é–“ï¼Œä¾‹å¦‚ "5-10"ã€"10-20"
- stage: "è“„å‹¢" / "é»ç«" / "è§¸ç™¼"ï¼ˆä¾æ‘˜è¦åˆ¤æ–·ï¼‰
- entry: { type: "å¸‚åƒ¹"|"é™åƒ¹", zone: "åƒ¹æ ¼å€é–“æˆ–å–®åƒ¹", logic: "ä¸€å¥è©±åŸå› " }
- stop: { zone: "åƒ¹æ ¼æˆ–å€é–“", logic: "ä¸€å¥è©±åŸå› " }
- takeProfit: é™£åˆ—ï¼Œæœ€å¤š3å€‹ { price: "åƒ¹ä½", logic:"ä¸€å¥è©±åŸå› " }
- invalidation: "å“ªäº›æ¢ä»¶æˆç«‹å°±ä¸åšå¤š/æ’¤é€€"
- notes: é™£åˆ—ï¼ˆ3~6é»ï¼‰ï¼Œç”¨ç¹é«”ä¸­æ–‡ï¼Œè¬›ä½ ç‚ºä»€éº¼é€™æ¨£åˆ¤æ–·ï¼ˆè¦å°æ‡‰æ‘˜è¦æ•¸æ“šï¼‰

è‹¥æ‘˜è¦é¡¯ç¤ºã€Œå·²å¤§å¹…å™´å‡ºã€æˆ–ã€Œçµæ§‹ä¸åˆ©å¤šã€ï¼Œè«‹ direction="è§€æœ›"ï¼Œä»ç„¶è¦å¡«æ»¿å…¶é¤˜æ¬„ä½ï¼ˆå¡« "-" æˆ–åˆç†ä¿å®ˆå€¼ï¼‰ã€‚

æ‘˜è¦å¦‚ä¸‹ï¼ˆJSONï¼‰ï¼š
${JSON.stringify(summary)}
`.trim();
}

async function callGemini(symbol){
  const st = states[symbol];
  if(!st) return;

  const key = getKey();
  if(!key){
    st.ai = { status:'éŒ¯èª¤', json:null, text:'', t:nowTs(), err:'æœªè¨­å®š Gemini Key' };
    renderTop5();
    alert('è«‹å…ˆè²¼ä¸Š Gemini API Key å†æ¸¬è©¦/åˆ†æã€‚');
    return;
  }

  const can = limiter.canRun();
  if(!can.ok){
    st.ai = { status:'ç¯€æµ/å†·å»', json:null, text:`AI æš«åœï¼š${can.why}`, t:nowTs(), err:can.why };
    renderTop5();
    return;
  }

  limiter.take();
  incDaily();

  const MODEL = $('modelSelect').value;
  const maxOut = clamp(parseInt($('maxOut').value||'420',10), 64, 2048);

  // ç²¾ç°¡æ‘˜è¦ï¼ˆä¸è¦ä¸Ÿæ•´åŒ…Kç·šï¼‰
  const candles = st.candle1m.slice(-30);
  const last = candles[candles.length-1] || {};
  const hi20 = candles.length ? Math.max(...candles.map(c=>c.h)) : NaN;
  const lo20 = candles.length ? Math.min(...candles.map(c=>c.l)) : NaN;

  const summary = {
    symbol,
    ts: nowTs(),
    onlyLong: true,
    score: Math.round(st.score),
    stage: st.stage,
    price: st.price,
    ret5m_pct: st.ret5m,
    premium_pct: st.premiumPct,
    funding_pct: st.fundingRate,
    vol5m_z: st.vol5mZ,
    imbalance5m: {
      takerBuy_notional: st.takerBuyNotional5m,
      takerSell_notional: st.takerSellNotional5m,
      net_notional: st.takerBuyNotional5m - st.takerSellNotional5m
    },
    oi: {
      oi5m_delta: st.oi5m ? st.oi5m.delta : null,
      oi4h_delta: st.oi4h ? st.oi4h.delta : null
    },
    takerRatio: {
      ratio_5m: st.taker5m ? st.taker5m.ratio : null,
      ratio_4h: st.taker4h ? st.taker4h.ratio : null
    },
    keyLevels: {
      high20_1m: hi20,
      low20_1m: lo20
    },
    tags: st.tags
  };

  const prompt = buildGeminiPrompt(summary);

  st.ai = { status:'åˆ†æä¸­â€¦', json:null, text:'', t:nowTs(), err:'' };
  st.lastAiReqAt = nowTs();
  renderTop5();

  const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(MODEL)}:generateContent?key=${encodeURIComponent(key)}`;

  const body = {
    contents: [{ role:'user', parts:[{ text: prompt }] }],
    generationConfig: {
      temperature: 0.2,
      maxOutputTokens: maxOut,
      responseMimeType: "application/json"
    }
  };

  try{
    const res = await fetch(url, {
      method:'POST',
      headers:{ 'Content-Type':'application/json' },
      body: JSON.stringify(body)
    });

    const rawText = await res.text();
    if(!res.ok){
      // 429/backoff
      if(res.status === 429){
        const wait = limiter.backoff();
        st.ai = { status:'429 é™é€Ÿ', json:null, text:`Gemini 429ï¼šå·²é€²å…¥å†·å» ${Math.round(wait/1000)}s`, t:nowTs(), err:'HTTP429' };
        setGeminiStatus(`429 å†·å» ${Math.round(wait/1000)}s`);
      }else{
        st.ai = { status:'éŒ¯èª¤', json:null, text:`Gemini FAILï¼šHTTP ${res.status}`, t:nowTs(), err: rawText.slice(0,300) };
        setGeminiStatus(`FAIL HTTP ${res.status}`);
      }
      console.warn('Gemini error raw:', rawText);
      renderTop5();
      return;
    }

    // parse Gemini response envelope
    let envelope = null;
    try{ envelope = JSON.parse(rawText); }catch(e){
      // sometimes response isn't JSON? rare, but handle
      envelope = null;
    }

    const parts = envelope?.candidates?.[0]?.content?.parts || [];
    const joined = parts.map(p => p.text || '').join('\n').trim();

    const obj = extractJsonLoose(joined);
    if(!obj){
      st.ai = { status:'NO_VALID_JSON', json:null, text:`AI(éŒ¯èª¤)ï¼šHTTP 200ï¼Œä½† Gemini å›çš„ä¸æ˜¯æœ‰æ•ˆ JSONï¼ˆå·²è¦æ±‚ JSON modeï¼‰`, t:nowTs(), err: joined.slice(0,300) };
      setGeminiStatus('HTTP200 ä½†é JSONï¼ˆå·²åšæŠ½å–ï¼‰');
      console.warn('Gemini raw joined:', joined);
      renderTop5();
      return;
    }

    st.ai = { status:'OK', json: obj, text: aiToPrettyZh(obj), t: nowTs(), err:'' };
    setGeminiStatus('OK');
    renderTop5();

  }catch(e){
    st.ai = { status:'éŒ¯èª¤', json:null, text:`Gemini FAILï¼š${e.message}`, t:nowTs(), err:String(e) };
    setGeminiStatus('FAILï¼ˆç¶²è·¯/è¢«é˜»æ“‹ï¼‰');
    console.warn(e);
    renderTop5();
  }
}

async function testGemini(){
  const key = getKey();
  if(!key){
    alert('è«‹å…ˆè²¼ä¸Š Gemini API Keyï¼ŒæŒ‰ Saveã€‚');
    return;
  }
  setGeminiStatus('æ¸¬è©¦ä¸­â€¦');
  const fakeSymbol = top5[0]?.symbol || universe[0];
  if(!fakeSymbol){
    alert('å°šæœªæœ‰å¹£ç¨®è³‡æ–™ï¼Œç­‰å€™æ•¸ç§’å¾Œå†è©¦ã€‚');
    return;
  }
  await callGemini(fakeSymbol);
  const st = states[fakeSymbol];
  if(st?.ai?.status === 'OK') alert('Test Gemini OK âœ…');
  else alert(`Test Gemini FAILï¼š${st?.ai?.status || 'æœªçŸ¥'}ï¼ˆçœ‹ Console æˆ– backoffï¼‰`);
}

/* =========================
   Auto Gemini (every 2 min)
   - only when Top5 has 5
   - only analyze Top 2~3 by score
   - only when stage is IGNITE/CONFIRM (çºŒåŠ›æ‰è¨ªå• AI)
========================= */
async function autoGeminiTick(){
  if(!$('autoToggle').checked) return;
  if(top5.length < 5) return;

  const now = nowTs();
  if(now - lastAutoGeminiAt < 120000) return; // every 2 min
  lastAutoGeminiAt = now;

  // pick top 2~3 (score high) and stage >= IGNITE
  const candidates = top5
    .filter(st => (st.stage === 'IGNITE' || st.stage === 'CONFIRM'))
    .slice(0,3);

  if(!candidates.length) return;

  for(const st of candidates){
    // avoid spamming same symbol too frequently
    if(st.lastAiReqAt && (now - st.lastAiReqAt) < 8*60*1000) continue;
    await callGemini(st.symbol);
    await sleep(900); // small spacing to respect RPM
  }
}

/* =========================
   Render
========================= */
function stageBadge(stage){
  if(stage==='CONFIRM') return `<span class="badge badge-green">ğŸŸ© è§¸ç™¼</span>`;
  if(stage==='IGNITE')  return `<span class="badge badge-orange">ğŸŸ§ é»ç«</span>`;
  if(stage==='SETUP')   return `<span class="badge badge-yellow">ğŸŸ¨ è“„å‹¢</span>`;
  return `<span class="badge">â€”</span>`;
}

function renderTop5(){
  const wrap = $('top5');
  wrap.innerHTML = '';

  const list = top5.slice(0,5);
  list.forEach((st, idx) => {
    const isChamp = (st.symbol === champ.symbol);
    const aiText = st.ai?.text || (st.ai?.status ? `å°šæœªåˆ†æï¼šæŒ‰å³ä¸Šã€Geminiã€‘æˆ–ã€Analyze Topã€‘` : 'å°šæœªåˆ†æ');
    const aiStatus = st.ai?.status || 'â€”';

    const left = `
      <div class="flex items-center justify-between gap-2">
        <div class="flex items-center gap-2">
          <div class="text-lg font-black text-white">${escapeHtml(st.symbol)}</div>
          ${isChamp ? `<span class="badge badge-green">ğŸ”¥ æœ€å¼·é–å®š</span>` : `<span class="badge">ç¬¬${idx+1}å</span>`}
          <span class="badge">score ${fmt(st.score,1)}</span>
          ${stageBadge(st.stage)}
        </div>
        <div class="flex items-center gap-2">
          <button class="btn btn-amber" data-g="${st.symbol}">Gemini</button>
        </div>
      </div>

      <div class="gridKpi mt-3">
        <div class="kpi"><div class="k">æ³¢å‹•ç•°å¸¸Z(5mé‡èƒ½)</div><div class="v">${fmt(st.vol5mZ,2)}</div></div>
        <div class="kpi"><div class="k">5åˆ†é˜æ¼²è·Œ</div><div class="v">${fmt(st.ret5m,2)}%</div></div>
        <div class="kpi"><div class="k">æº¢åƒ¹(æ¨™è¨˜-æŒ‡æ•¸)</div><div class="v">${fmt(st.premiumPct,3)}%</div></div>

        <div class="kpi"><div class="k">ä¸»å‹•è²·å…¥å·®é¡(5m, é‡‘é¡)</div><div class="v">${fmt((st.takerBuyNotional5m - st.takerSellNotional5m),0)}</div></div>
        <div class="kpi"><div class="k">ä¸»å‹•è²·å…¥é¡(5m)</div><div class="v">${fmt(st.takerBuyNotional5m,0)}</div></div>
        <div class="kpi"><div class="k">ä¸»å‹•è³£å‡ºé¡(5m)</div><div class="v">${fmt(st.takerSellNotional5m,0)}</div></div>

        <div class="kpi"><div class="k">OIè®ŠåŒ–(5m)</div><div class="v">${st.oi5m ? fmt(st.oi5m.delta,2) : '--'}</div></div>
        <div class="kpi"><div class="k">OIè®ŠåŒ–(4h)</div><div class="v">${st.oi4h ? fmt(st.oi4h.delta,2) : '--'}</div></div>
        <div class="kpi"><div class="k">ä¸»å‹•è²·è³£æ¯”(5m)</div><div class="v">${st.taker5m ? fmt(st.taker5m.ratio,3) : '--'}</div></div>

        <div class="kpi"><div class="k">è³‡é‡‘è²»ç‡(åƒè€ƒ)</div><div class="v">${fmt(st.fundingRate,4)}%</div></div>
        <div class="kpi"><div class="k">åƒ¹æ ¼</div><div class="v">${Number.isFinite(st.price) ? fmt(st.price,6) : '--'}</div></div>
        <div class="kpi"><div class="k">å‹æ…‹æ¨™ç±¤</div><div class="v">${escapeHtml(st.tags.join(' / ') || '-')}</div></div>
      </div>
    `;

    const right = `
      <div class="aiBox whitespace-pre-wrap leading-relaxed text-[12px]">
        <div class="flex items-center justify-between mb-2">
          <div class="text-[12px] font-black text-white">AI åˆ¤è®€ï¼ˆä¸­æ–‡ï¼‰</div>
          <div class="text-[11px] text-zinc-500">status: ${escapeHtml(aiStatus)}</div>
        </div>
        <div class="text-zinc-200">${escapeHtml(aiText)}</div>
        ${st.ai?.err ? `<div class="mt-2 text-[11px] text-red-300">å‚™è¨»ï¼š${escapeHtml(st.ai.err)}</div>` : ''}
      </div>
    `;

    const card = document.createElement('div');
    card.className = 'card p-4';
    card.innerHTML = `
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-3">
        <div class="lg:col-span-2">${left}</div>
        <div class="lg:col-span-1">${right}</div>
      </div>
    `;
    wrap.appendChild(card);
  });

  // bind per-card Gemini buttons
  wrap.querySelectorAll('button[data-g]').forEach(btn => {
    btn.addEventListener('click', async () => {
      const sym = btn.getAttribute('data-g');
      await seedCandles(sym);
      await refreshDerivativesStats(sym);
      await callGemini(sym);
    });
  });
}

/* =========================
   Main Loop
========================= */
async function mainLoop(){
  try{
    setStatus('è¼‰å…¥æ’é™¤æ¸…å–®â€¦');
    await loadTopCap25();

    setStatus('å»ºç«‹ Universeâ€¦');
    await refreshUniverse();

    setStatus('é–‹å•Ÿä¸²æµâ€¦');
    openAggTrades();
    openMarkPrices();

    // seed top few quickly
    for(const s of universe.slice(0, 10)){
      await seedCandles(s);
      await sleep(120);
    }

    $('dailyInfo').innerText = String(getDailyCount());
    setGeminiStatus(getKey() ? 'å·²ä¿å­˜ï¼ˆæœªæ¸¬è©¦ï¼‰' : 'æœªè¨­å®š');
    setStatus('é‹è¡Œä¸­');

    // periodic ranking
    setInterval(async () => {
      // lazy seed for symbols that enter top candidate zone
      const candidates = universe.slice(0, 40); // rough
      for(const s of candidates.slice(0, 6)){
        if(states[s] && !states[s].seeded) seedCandles(s);
      }
      updateRanking();
    }, 3000);

    // fetch OI/taker stats only for current top candidates
    setInterval(async () => {
      const cur = top5.slice(0, 5);
      for(const st of cur){
        await refreshDerivativesStats(st.symbol);
        await sleep(120);
      }
    }, 5000);

    // universe refresh each 60s (liquidity changes)
    setInterval(async () => {
      try{
        await loadTopCap25();
        await refreshUniverse();
        openAggTrades(); // refresh streams to match new universe
      }catch(e){
        console.warn('refreshUniverse loop fail', e);
      }
    }, 60000);

    // auto gemini
    setInterval(autoGeminiTick, 5000);

  }catch(e){
    console.error(e);
    setStatus('å•Ÿå‹•å¤±æ•—ï¼šçœ‹ Console');
  }
}

/* =========================
   UI bindings
========================= */
$('saveKeyBtn').addEventListener('click', saveKey);
$('clearKeyBtn').addEventListener('click', clearKey);
$('testGeminiBtn').addEventListener('click', testGemini);

$('analyzeTopBtn').addEventListener('click', async () => {
  if(top5.length < 5){
    alert('Top5 å°šæœªæ¹Šæ»¿ 5 æ”¯ï¼Œç¨ç­‰ä¸€ä¸‹ã€‚');
    return;
  }
  // æ‰‹å‹•ï¼šåˆ†æ Top 2~3
  const picks = top5.slice(0,3);
  for(const st of picks){
    await seedCandles(st.symbol);
    await refreshDerivativesStats(st.symbol);
    await callGemini(st.symbol);
    await sleep(900);
  }
});

$('resetBtn').addEventListener('click', () => location.reload());

// load champ if exists
try{
  const c = JSON.parse(localStorage.getItem(LS_CHAMP) || 'null');
  if(c && c.symbol) champ = c;
}catch(e){}

loadKey();
$('dailyInfo').innerText = String(getDailyCount());
mainLoop();
</script>
</body>
</html>
